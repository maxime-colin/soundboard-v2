webpackJsonp([1,3],{232:function(t,n){t.exports=function(t){"undefined"!=typeof execScript?execScript(t):eval.call(null,t)}},382:function(t,n,r){r(232)(r(680))},383:function(t,n,r){r(232)(r(681))},384:function(t,n,r){r(232)(r(682))},680:function(t,n){t.exports="/*!\r\n * Paper.js v0.9.25 - The Swiss Army Knife of Vector Graphics Scripting.\r\n * http://paperjs.org/\r\n *\r\n * Copyright (c) 2011 - 2014, Juerg Lehni & Jonathan Puckey\r\n * http://scratchdisk.com/ & http://jonathanpuckey.com/\r\n *\r\n * Distributed under the MIT license. See LICENSE file for details.\r\n *\r\n * All rights reserved.\r\n *\r\n * Date: Sun Oct 25 11:23:38 2015 +0100\r\n *\r\n ***\r\n *\r\n * Straps.js - Class inheritance library with support for bean-style accessors\r\n *\r\n * Copyright (c) 2006 - 2013 Juerg Lehni\r\n * http://scratchdisk.com/\r\n *\r\n * Distributed under the MIT license.\r\n *\r\n ***\r\n *\r\n * Acorn.js\r\n * http://marijnhaverbeke.nl/acorn/\r\n *\r\n * Acorn is a tiny, fast JavaScript parser written in JavaScript,\r\n * created by Marijn Haverbeke and released under an MIT license.\r\n *\r\n */\r\n\r\nvar paper = new function(undefined) {\r\n\r\nvar Base = new function() {\r\n\tvar hidden = /^(statics|enumerable|beans|preserve)$/,\r\n\r\n\t\tforEach = [].forEach || function(iter, bind) {\r\n\t\t\tfor (var i = 0, l = this.length; i < l; i++)\r\n\t\t\t\titer.call(bind, this[i], i, this);\r\n\t\t},\r\n\r\n\t\tforIn = function(iter, bind) {\r\n\t\t\tfor (var i in this)\r\n\t\t\t\tif (this.hasOwnProperty(i))\r\n\t\t\t\t\titer.call(bind, this[i], i, this);\r\n\t\t},\r\n\r\n\t\tcreate = Object.create || function(proto) {\r\n\t\t\treturn { __proto__: proto };\r\n\t\t},\r\n\r\n\t\tdescribe = Object.getOwnPropertyDescriptor || function(obj, name) {\r\n\t\t\tvar get = obj.__lookupGetter__ && obj.__lookupGetter__(name);\r\n\t\t\treturn get\r\n\t\t\t\t\t? { get: get, set: obj.__lookupSetter__(name),\r\n\t\t\t\t\t\tenumerable: true, configurable: true }\r\n\t\t\t\t\t: obj.hasOwnProperty(name)\r\n\t\t\t\t\t\t? { value: obj[name], enumerable: true,\r\n\t\t\t\t\t\t\tconfigurable: true, writable: true }\r\n\t\t\t\t\t\t: null;\r\n\t\t},\r\n\r\n\t\t_define = Object.defineProperty || function(obj, name, desc) {\r\n\t\t\tif ((desc.get || desc.set) && obj.__defineGetter__) {\r\n\t\t\t\tif (desc.get)\r\n\t\t\t\t\tobj.__defineGetter__(name, desc.get);\r\n\t\t\t\tif (desc.set)\r\n\t\t\t\t\tobj.__defineSetter__(name, desc.set);\r\n\t\t\t} else {\r\n\t\t\t\tobj[name] = desc.value;\r\n\t\t\t}\r\n\t\t\treturn obj;\r\n\t\t},\r\n\r\n\t\tdefine = function(obj, name, desc) {\r\n\t\t\tdelete obj[name];\r\n\t\t\treturn _define(obj, name, desc);\r\n\t\t};\r\n\r\n\tfunction inject(dest, src, enumerable, beans, preserve) {\r\n\t\tvar beansNames = {};\r\n\r\n\t\tfunction field(name, val) {\r\n\t\t\tval = val || (val = describe(src, name))\r\n\t\t\t\t\t&& (val.get ? val : val.value);\r\n\t\t\tif (typeof val === 'string' && val[0] === '#')\r\n\t\t\t\tval = dest[val.substring(1)] || val;\r\n\t\t\tvar isFunc = typeof val === 'function',\r\n\t\t\t\tres = val,\r\n\t\t\t\tprev = preserve || isFunc && !val.base\r\n\t\t\t\t\t\t? (val && val.get ? name in dest : dest[name])\r\n\t\t\t\t\t\t: null,\r\n\t\t\t\tbean;\r\n\t\t\tif (!preserve || !prev) {\r\n\t\t\t\tif (isFunc && prev)\r\n\t\t\t\t\tval.base = prev;\r\n\t\t\t\tif (isFunc && beans !== false\r\n\t\t\t\t\t\t&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))\r\n\t\t\t\t\tbeansNames[bean[3].toLowerCase() + bean[4]] = bean[2];\r\n\t\t\t\tif (!res || isFunc || !res.get || typeof res.get !== 'function'\r\n\t\t\t\t\t\t|| !Base.isPlainObject(res))\r\n\t\t\t\t\tres = { value: res, writable: true };\r\n\t\t\t\tif ((describe(dest, name)\r\n\t\t\t\t\t\t|| { configurable: true }).configurable) {\r\n\t\t\t\t\tres.configurable = true;\r\n\t\t\t\t\tres.enumerable = enumerable;\r\n\t\t\t\t}\r\n\t\t\t\tdefine(dest, name, res);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (src) {\r\n\t\t\tfor (var name in src) {\r\n\t\t\t\tif (src.hasOwnProperty(name) && !hidden.test(name))\r\n\t\t\t\t\tfield(name);\r\n\t\t\t}\r\n\t\t\tfor (var name in beansNames) {\r\n\t\t\t\tvar part = beansNames[name],\r\n\t\t\t\t\tset = dest['set' + part],\r\n\t\t\t\t\tget = dest['get' + part] || set && dest['is' + part];\r\n\t\t\t\tif (get && (beans === true || get.length === 0))\r\n\t\t\t\t\tfield(name, { get: get, set: set });\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dest;\r\n\t}\r\n\r\n\tfunction each(obj, iter, bind) {\r\n\t\tif (obj)\r\n\t\t\t('length' in obj && !obj.getLength\r\n\t\t\t\t\t&& typeof obj.length === 'number'\r\n\t\t\t\t? forEach\r\n\t\t\t\t: forIn).call(obj, iter, bind = bind || obj);\r\n\t\treturn bind;\r\n\t}\r\n\r\n\tfunction set(obj, props, exclude) {\r\n\t\tfor (var key in props)\r\n\t\t\tif (props.hasOwnProperty(key) && !(exclude && exclude[key]))\r\n\t\t\t\tobj[key] = props[key];\r\n\t\treturn obj;\r\n\t}\r\n\r\n\treturn inject(function Base() {\r\n\t\tfor (var i = 0, l = arguments.length; i < l; i++)\r\n\t\t\tset(this, arguments[i]);\r\n\t}, {\r\n\t\tinject: function(src) {\r\n\t\t\tif (src) {\r\n\t\t\t\tvar statics = src.statics === true ? src : src.statics,\r\n\t\t\t\t\tbeans = src.beans,\r\n\t\t\t\t\tpreserve = src.preserve;\r\n\t\t\t\tif (statics !== src)\r\n\t\t\t\t\tinject(this.prototype, src, src.enumerable, beans, preserve);\r\n\t\t\t\tinject(this, statics, true, beans, preserve);\r\n\t\t\t}\r\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++)\r\n\t\t\t\tthis.inject(arguments[i]);\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\textend: function() {\r\n\t\t\tvar base = this,\r\n\t\t\t\tctor,\r\n\t\t\t\tproto;\r\n\t\t\tfor (var i = 0, l = arguments.length; i < l; i++)\r\n\t\t\t\tif (ctor = arguments[i].initialize)\r\n\t\t\t\t\tbreak;\r\n\t\t\tctor = ctor || function() {\r\n\t\t\t\tbase.apply(this, arguments);\r\n\t\t\t};\r\n\t\t\tproto = ctor.prototype = create(this.prototype);\r\n\t\t\tdefine(proto, 'constructor',\r\n\t\t\t\t\t{ value: ctor, writable: true, configurable: true });\r\n\t\t\tinject(ctor, this, true);\r\n\t\t\tif (arguments.length)\r\n\t\t\t\tthis.inject.apply(ctor, arguments);\r\n\t\t\tctor.base = base;\r\n\t\t\treturn ctor;\r\n\t\t}\r\n\t}, true).inject({\r\n\t\tinject: function() {\r\n\t\t\tfor (var i = 0, l = arguments.length; i < l; i++) {\r\n\t\t\t\tvar src = arguments[i];\r\n\t\t\t\tif (src)\r\n\t\t\t\t\tinject(this, src, src.enumerable, src.beans, src.preserve);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\textend: function() {\r\n\t\t\tvar res = create(this);\r\n\t\t\treturn res.inject.apply(res, arguments);\r\n\t\t},\r\n\r\n\t\teach: function(iter, bind) {\r\n\t\t\treturn each(this, iter, bind);\r\n\t\t},\r\n\r\n\t\tset: function(props) {\r\n\t\t\treturn set(this, props);\r\n\t\t},\r\n\r\n\t\tclone: function() {\r\n\t\t\treturn new this.constructor(this);\r\n\t\t},\r\n\r\n\t\tstatics: {\r\n\t\t\teach: each,\r\n\t\t\tcreate: create,\r\n\t\t\tdefine: define,\r\n\t\t\tdescribe: describe,\r\n\t\t\tset: set,\r\n\r\n\t\t\tclone: function(obj) {\r\n\t\t\t\treturn set(new obj.constructor(), obj);\r\n\t\t\t},\r\n\r\n\t\t\tisPlainObject: function(obj) {\r\n\t\t\t\tvar ctor = obj != null && obj.constructor;\r\n\t\t\t\treturn ctor && (ctor === Object || ctor === Base\r\n\t\t\t\t\t\t|| ctor.name === 'Object');\r\n\t\t\t},\r\n\r\n\t\t\tpick: function(a, b) {\r\n\t\t\t\treturn a !== undefined ? a : b;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n};\r\n\r\nif (typeof module !== 'undefined')\r\n\tmodule.exports = Base;\r\n\r\nBase.inject({\r\n\ttoString: function() {\r\n\t\treturn this._id != null\r\n\t\t\t?  (this._class || 'Object') + (this._name\r\n\t\t\t\t? \" '\" + this._name + \"'\"\r\n\t\t\t\t: ' @' + this._id)\r\n\t\t\t: '{ ' + Base.each(this, function(value, key) {\r\n\t\t\t\tif (!/^_/.test(key)) {\r\n\t\t\t\t\tvar type = typeof value;\r\n\t\t\t\t\tthis.push(key + ': ' + (type === 'number'\r\n\t\t\t\t\t\t\t? Formatter.instance.number(value)\r\n\t\t\t\t\t\t\t: type === 'string' ? \"'\" + value + \"'\" : value));\r\n\t\t\t\t}\r\n\t\t\t}, []).join(', ') + ' }';\r\n\t},\r\n\r\n\tgetClassName: function() {\r\n\t\treturn this._class || '';\r\n\t},\r\n\r\n\texportJSON: function(options) {\r\n\t\treturn Base.exportJSON(this, options);\r\n\t},\r\n\r\n\ttoJSON: function() {\r\n\t\treturn Base.serialize(this);\r\n\t},\r\n\r\n\t_set: function(props, exclude, dontCheck) {\r\n\t\tif (props && (dontCheck || Base.isPlainObject(props))) {\r\n\t\t\tvar keys = Object.keys(props._filtering || props);\r\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\tvar key = keys[i];\r\n\t\t\t\tif (!(exclude && exclude[key])) {\r\n\t\t\t\t\tvar value = props[key];\r\n\t\t\t\t\tif (value !== undefined)\r\n\t\t\t\t\t\tthis[key] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t},\r\n\r\n\tstatics: {\r\n\r\n\t\texports: {\r\n\t\t\tenumerable: true\r\n\t\t},\r\n\r\n\t\textend: function extend() {\r\n\t\t\tvar res = extend.base.apply(this, arguments),\r\n\t\t\t\tname = res.prototype._class;\r\n\t\t\tif (name && !Base.exports[name])\r\n\t\t\t\tBase.exports[name] = res;\r\n\t\t\treturn res;\r\n\t\t},\r\n\r\n\t\tequals: function(obj1, obj2) {\r\n\t\t\tif (obj1 === obj2)\r\n\t\t\t\treturn true;\r\n\t\t\tif (obj1 && obj1.equals)\r\n\t\t\t\treturn obj1.equals(obj2);\r\n\t\t\tif (obj2 && obj2.equals)\r\n\t\t\t\treturn obj2.equals(obj1);\r\n\t\t\tif (obj1 && obj2\r\n\t\t\t\t\t&& typeof obj1 === 'object' && typeof obj2 === 'object') {\r\n\t\t\t\tif (Array.isArray(obj1) && Array.isArray(obj2)) {\r\n\t\t\t\t\tvar length = obj1.length;\r\n\t\t\t\t\tif (length !== obj2.length)\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\twhile (length--) {\r\n\t\t\t\t\t\tif (!Base.equals(obj1[length], obj2[length]))\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar keys = Object.keys(obj1),\r\n\t\t\t\t\t\tlength = keys.length;\r\n\t\t\t\t\tif (length !== Object.keys(obj2).length)\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\twhile (length--) {\r\n\t\t\t\t\t\tvar key = keys[length];\r\n\t\t\t\t\t\tif (!(obj2.hasOwnProperty(key)\r\n\t\t\t\t\t\t\t\t&& Base.equals(obj1[key], obj2[key])))\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tread: function(list, start, options, length) {\r\n\t\t\tif (this === Base) {\r\n\t\t\t\tvar value = this.peek(list, start);\r\n\t\t\t\tlist.__index++;\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t\tvar proto = this.prototype,\r\n\t\t\t\treadIndex = proto._readIndex,\r\n\t\t\t\tindex = start || readIndex && list.__index || 0;\r\n\t\t\tif (!length)\r\n\t\t\t\tlength = list.length - index;\r\n\t\t\tvar obj = list[index];\r\n\t\t\tif (obj instanceof this\r\n\t\t\t\t|| options && options.readNull && obj == null && length <= 1) {\r\n\t\t\t\tif (readIndex)\r\n\t\t\t\t\tlist.__index = index + 1;\r\n\t\t\t\treturn obj && options && options.clone ? obj.clone() : obj;\r\n\t\t\t}\r\n\t\t\tobj = Base.create(this.prototype);\r\n\t\t\tif (readIndex)\r\n\t\t\t\tobj.__read = true;\r\n\t\t\tobj = obj.initialize.apply(obj, index > 0 || length < list.length\r\n\t\t\t\t? Array.prototype.slice.call(list, index, index + length)\r\n\t\t\t\t: list) || obj;\r\n\t\t\tif (readIndex) {\r\n\t\t\t\tlist.__index = index + obj.__read;\r\n\t\t\t\tobj.__read = undefined;\r\n\t\t\t}\r\n\t\t\treturn obj;\r\n\t\t},\r\n\r\n\t\tpeek: function(list, start) {\r\n\t\t\treturn list[list.__index = start || list.__index || 0];\r\n\t\t},\r\n\r\n\t\tremain: function(list) {\r\n\t\t\treturn list.length - (list.__index || 0);\r\n\t\t},\r\n\r\n\t\treadAll: function(list, start, options) {\r\n\t\t\tvar res = [],\r\n\t\t\t\tentry;\r\n\t\t\tfor (var i = start || 0, l = list.length; i < l; i++) {\r\n\t\t\t\tres.push(Array.isArray(entry = list[i])\r\n\t\t\t\t\t\t? this.read(entry, 0, options)\r\n\t\t\t\t\t\t: this.read(list, i, options, 1));\r\n\t\t\t}\r\n\t\t\treturn res;\r\n\t\t},\r\n\r\n\t\treadNamed: function(list, name, start, options, length) {\r\n\t\t\tvar value = this.getNamed(list, name),\r\n\t\t\t\thasObject = value !== undefined;\r\n\t\t\tif (hasObject) {\r\n\t\t\t\tvar filtered = list._filtered;\r\n\t\t\t\tif (!filtered) {\r\n\t\t\t\t\tfiltered = list._filtered = Base.create(list[0]);\r\n\t\t\t\t\tfiltered._filtering = list[0];\r\n\t\t\t\t}\r\n\t\t\t\tfiltered[name] = undefined;\r\n\t\t\t}\r\n\t\t\treturn this.read(hasObject ? [value] : list, start, options, length);\r\n\t\t},\r\n\r\n\t\tgetNamed: function(list, name) {\r\n\t\t\tvar arg = list[0];\r\n\t\t\tif (list._hasObject === undefined)\r\n\t\t\t\tlist._hasObject = list.length === 1 && Base.isPlainObject(arg);\r\n\t\t\tif (list._hasObject)\r\n\t\t\t\treturn name ? arg[name] : list._filtered || arg;\r\n\t\t},\r\n\r\n\t\thasNamed: function(list, name) {\r\n\t\t\treturn !!this.getNamed(list, name);\r\n\t\t},\r\n\r\n\t\tisPlainValue: function(obj, asString) {\r\n\t\t\treturn this.isPlainObject(obj) || Array.isArray(obj)\r\n\t\t\t\t\t|| asString && typeof obj === 'string';\r\n\t\t},\r\n\r\n\t\tserialize: function(obj, options, compact, dictionary) {\r\n\t\t\toptions = options || {};\r\n\r\n\t\t\tvar root = !dictionary,\r\n\t\t\t\tres;\r\n\t\t\tif (root) {\r\n\t\t\t\toptions.formatter = new Formatter(options.precision);\r\n\t\t\t\tdictionary = {\r\n\t\t\t\t\tlength: 0,\r\n\t\t\t\t\tdefinitions: {},\r\n\t\t\t\t\treferences: {},\r\n\t\t\t\t\tadd: function(item, create) {\r\n\t\t\t\t\t\tvar id = '#' + item._id,\r\n\t\t\t\t\t\t\tref = this.references[id];\r\n\t\t\t\t\t\tif (!ref) {\r\n\t\t\t\t\t\t\tthis.length++;\r\n\t\t\t\t\t\t\tvar res = create.call(item),\r\n\t\t\t\t\t\t\t\tname = item._class;\r\n\t\t\t\t\t\t\tif (name && res[0] !== name)\r\n\t\t\t\t\t\t\t\tres.unshift(name);\r\n\t\t\t\t\t\t\tthis.definitions[id] = res;\r\n\t\t\t\t\t\t\tref = this.references[id] = [id];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn ref;\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\tif (obj && obj._serialize) {\r\n\t\t\t\tres = obj._serialize(options, dictionary);\r\n\t\t\t\tvar name = obj._class;\r\n\t\t\t\tif (name && !compact && !res._compact && res[0] !== name)\r\n\t\t\t\t\tres.unshift(name);\r\n\t\t\t} else if (Array.isArray(obj)) {\r\n\t\t\t\tres = [];\r\n\t\t\t\tfor (var i = 0, l = obj.length; i < l; i++)\r\n\t\t\t\t\tres[i] = Base.serialize(obj[i], options, compact,\r\n\t\t\t\t\t\t\tdictionary);\r\n\t\t\t\tif (compact)\r\n\t\t\t\t\tres._compact = true;\r\n\t\t\t} else if (Base.isPlainObject(obj)) {\r\n\t\t\t\tres = {};\r\n\t\t\t\tvar keys = Object.keys(obj);\r\n\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\tvar key = keys[i];\r\n\t\t\t\t\tres[key] = Base.serialize(obj[key], options, compact,\r\n\t\t\t\t\t\t\tdictionary);\r\n\t\t\t\t}\r\n\t\t\t} else if (typeof obj === 'number') {\r\n\t\t\t\tres = options.formatter.number(obj, options.precision);\r\n\t\t\t} else {\r\n\t\t\t\tres = obj;\r\n\t\t\t}\r\n\t\t\treturn root && dictionary.length > 0\r\n\t\t\t\t\t? [['dictionary', dictionary.definitions], res]\r\n\t\t\t\t\t: res;\r\n\t\t},\r\n\r\n\t\tdeserialize: function(json, create, _data, _isDictionary) {\r\n\t\t\tvar res = json,\r\n\t\t\t\tisRoot = !_data;\r\n\t\t\t_data = _data || {};\r\n\t\t\tif (Array.isArray(json)) {\r\n\t\t\t\tvar type = json[0],\r\n\t\t\t\t\tisDictionary = type === 'dictionary';\r\n\t\t\t\tif (json.length == 1 && /^#/.test(type))\r\n\t\t\t\t\treturn _data.dictionary[type];\r\n\t\t\t\ttype = Base.exports[type];\r\n\t\t\t\tres = [];\r\n\t\t\t\tif (_isDictionary)\r\n\t\t\t\t\t_data.dictionary = res;\r\n\t\t\t\tfor (var i = type ? 1 : 0, l = json.length; i < l; i++)\r\n\t\t\t\t\tres.push(Base.deserialize(json[i], create, _data,\r\n\t\t\t\t\t\t\tisDictionary));\r\n\t\t\t\tif (type) {\r\n\t\t\t\t\tvar args = res;\r\n\t\t\t\t\tif (create) {\r\n\t\t\t\t\t\tres = create(type, args);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tres = Base.create(type.prototype);\r\n\t\t\t\t\t\ttype.apply(res, args);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (Base.isPlainObject(json)) {\r\n\t\t\t\tres = {};\r\n\t\t\t\tif (_isDictionary)\r\n\t\t\t\t\t_data.dictionary = res;\r\n\t\t\t\tfor (var key in json)\r\n\t\t\t\t\tres[key] = Base.deserialize(json[key], create, _data);\r\n\t\t\t}\r\n\t\t\treturn isRoot && json && json.length && json[0][0] === 'dictionary'\r\n\t\t\t\t\t? res[1]\r\n\t\t\t\t\t: res;\r\n\t\t},\r\n\r\n\t\texportJSON: function(obj, options) {\r\n\t\t\tvar json = Base.serialize(obj, options);\r\n\t\t\treturn options && options.asString === false\r\n\t\t\t\t\t? json\r\n\t\t\t\t\t: JSON.stringify(json);\r\n\t\t},\r\n\r\n\t\timportJSON: function(json, target) {\r\n\t\t\treturn Base.deserialize(\r\n\t\t\t\t\ttypeof json === 'string' ? JSON.parse(json) : json,\r\n\t\t\t\t\tfunction(type, args) {\r\n\t\t\t\t\t\tvar obj = target && target.constructor === type\r\n\t\t\t\t\t\t\t\t? target\r\n\t\t\t\t\t\t\t\t: Base.create(type.prototype),\r\n\t\t\t\t\t\t\tisTarget = obj === target;\r\n\t\t\t\t\t\tif (args.length === 1 && obj instanceof Item\r\n\t\t\t\t\t\t\t\t&& (isTarget || !(obj instanceof Layer))) {\r\n\t\t\t\t\t\t\tvar arg = args[0];\r\n\t\t\t\t\t\t\tif (Base.isPlainObject(arg))\r\n\t\t\t\t\t\t\t\targ.insert = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttype.apply(obj, args);\r\n\t\t\t\t\t\tif (isTarget)\r\n\t\t\t\t\t\t\ttarget = null;\r\n\t\t\t\t\t\treturn obj;\r\n\t\t\t\t\t});\r\n\t\t},\r\n\r\n\t\tsplice: function(list, items, index, remove) {\r\n\t\t\tvar amount = items && items.length,\r\n\t\t\t\tappend = index === undefined;\r\n\t\t\tindex = append ? list.length : index;\r\n\t\t\tif (index > list.length)\r\n\t\t\t\tindex = list.length;\r\n\t\t\tfor (var i = 0; i < amount; i++)\r\n\t\t\t\titems[i]._index = index + i;\r\n\t\t\tif (append) {\r\n\t\t\t\tlist.push.apply(list, items);\r\n\t\t\t\treturn [];\r\n\t\t\t} else {\r\n\t\t\t\tvar args = [index, remove];\r\n\t\t\t\tif (items)\r\n\t\t\t\t\targs.push.apply(args, items);\r\n\t\t\t\tvar removed = list.splice.apply(list, args);\r\n\t\t\t\tfor (var i = 0, l = removed.length; i < l; i++)\r\n\t\t\t\t\tremoved[i]._index = undefined;\r\n\t\t\t\tfor (var i = index + amount, l = list.length; i < l; i++)\r\n\t\t\t\t\tlist[i]._index = i;\r\n\t\t\t\treturn removed;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tcapitalize: function(str) {\r\n\t\t\treturn str.replace(/\\b[a-z]/g, function(match) {\r\n\t\t\t\treturn match.toUpperCase();\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tcamelize: function(str) {\r\n\t\t\treturn str.replace(/-(.)/g, function(all, chr) {\r\n\t\t\t\treturn chr.toUpperCase();\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\thyphenate: function(str) {\r\n\t\t\treturn str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar Emitter = {\r\n\ton: function(type, func) {\r\n\t\tif (typeof type !== 'string') {\r\n\t\t\tBase.each(type, function(value, key) {\r\n\t\t\t\tthis.on(key, value);\r\n\t\t\t}, this);\r\n\t\t} else {\r\n\t\t\tvar types = this._eventTypes,\r\n\t\t\t\tentry = types && types[type],\r\n\t\t\t\thandlers = this._callbacks = this._callbacks || {};\r\n\t\t\thandlers = handlers[type] = handlers[type] || [];\r\n\t\t\tif (handlers.indexOf(func) === -1) {\r\n\t\t\t\thandlers.push(func);\r\n\t\t\t\tif (entry && entry.install && handlers.length === 1)\r\n\t\t\t\t\tentry.install.call(this, type);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\toff: function(type, func) {\r\n\t\tif (typeof type !== 'string') {\r\n\t\t\tBase.each(type, function(value, key) {\r\n\t\t\t\tthis.off(key, value);\r\n\t\t\t}, this);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar types = this._eventTypes,\r\n\t\t\tentry = types && types[type],\r\n\t\t\thandlers = this._callbacks && this._callbacks[type],\r\n\t\t\tindex;\r\n\t\tif (handlers) {\r\n\t\t\tif (!func || (index = handlers.indexOf(func)) !== -1\r\n\t\t\t\t\t&& handlers.length === 1) {\r\n\t\t\t\tif (entry && entry.uninstall)\r\n\t\t\t\t\tentry.uninstall.call(this, type);\r\n\t\t\t\tdelete this._callbacks[type];\r\n\t\t\t} else if (index !== -1) {\r\n\t\t\t\thandlers.splice(index, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonce: function(type, func) {\r\n\t\treturn this.on(type, function() {\r\n\t\t\tfunc.apply(this, arguments);\r\n\t\t\tthis.off(type, func);\r\n\t\t});\r\n\t},\r\n\r\n\temit: function(type, event) {\r\n\t\tvar handlers = this._callbacks && this._callbacks[type];\r\n\t\tif (!handlers)\r\n\t\t\treturn false;\r\n\t\tvar args = [].slice.call(arguments, 1);\r\n\t\thandlers = handlers.slice();\r\n\t\tfor (var i = 0, l = handlers.length; i < l; i++) {\r\n\t\t\tif (handlers[i].apply(this, args) === false) {\r\n\t\t\t\tif (event && event.stop)\r\n\t\t\t\t\tevent.stop();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t},\r\n\r\n\tresponds: function(type) {\r\n\t\treturn !!(this._callbacks && this._callbacks[type]);\r\n\t},\r\n\r\n\tattach: '#on',\r\n\tdetach: '#off',\r\n\tfire: '#emit',\r\n\r\n\t_installEvents: function(install) {\r\n\t\tvar handlers = this._callbacks,\r\n\t\t\tkey = install ? 'install' : 'uninstall';\r\n\t\tfor (var type in handlers) {\r\n\t\t\tif (handlers[type].length > 0) {\r\n\t\t\t\tvar types = this._eventTypes,\r\n\t\t\t\t\tentry = types && types[type],\r\n\t\t\t\t\tfunc = entry && entry[key];\r\n\t\t\t\tif (func)\r\n\t\t\t\t\tfunc.call(this, type);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tstatics: {\r\n\t\tinject: function inject(src) {\r\n\t\t\tvar events = src._events;\r\n\t\t\tif (events) {\r\n\t\t\t\tvar types = {};\r\n\t\t\t\tBase.each(events, function(entry, key) {\r\n\t\t\t\t\tvar isString = typeof entry === 'string',\r\n\t\t\t\t\t\tname = isString ? entry : key,\r\n\t\t\t\t\t\tpart = Base.capitalize(name),\r\n\t\t\t\t\t\ttype = name.substring(2).toLowerCase();\r\n\t\t\t\t\ttypes[type] = isString ? {} : entry;\r\n\t\t\t\t\tname = '_' + name;\r\n\t\t\t\t\tsrc['get' + part] = function() {\r\n\t\t\t\t\t\treturn this[name];\r\n\t\t\t\t\t};\r\n\t\t\t\t\tsrc['set' + part] = function(func) {\r\n\t\t\t\t\t\tvar prev = this[name];\r\n\t\t\t\t\t\tif (prev)\r\n\t\t\t\t\t\t\tthis.off(type, prev);\r\n\t\t\t\t\t\tif (func)\r\n\t\t\t\t\t\t\tthis.on(type, func);\r\n\t\t\t\t\t\tthis[name] = func;\r\n\t\t\t\t\t};\r\n\t\t\t\t});\r\n\t\t\t\tsrc._eventTypes = types;\r\n\t\t\t}\r\n\t\t\treturn inject.base.apply(this, arguments);\r\n\t\t}\r\n\t}\r\n};\r\n\r\nvar PaperScope = Base.extend({\r\n\t_class: 'PaperScope',\r\n\r\n\tinitialize: function PaperScope() {\r\n\t\tpaper = this;\r\n\t\tthis.settings = new Base({\r\n\t\t\tapplyMatrix: true,\r\n\t\t\thandleSize: 4,\r\n\t\t\thitTolerance: 0\r\n\t\t});\r\n\t\tthis.project = null;\r\n\t\tthis.projects = [];\r\n\t\tthis.tools = [];\r\n\t\tthis.palettes = [];\r\n\t\tthis._id = PaperScope._id++;\r\n\t\tPaperScope._scopes[this._id] = this;\r\n\t\tvar proto = PaperScope.prototype;\r\n\t\tif (!this.support) {\r\n\t\t\tvar ctx = CanvasProvider.getContext(1, 1);\r\n\t\t\tproto.support = {\r\n\t\t\t\tnativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,\r\n\t\t\t\tnativeBlendModes: BlendMode.nativeModes\r\n\t\t\t};\r\n\t\t\tCanvasProvider.release(ctx);\r\n\t\t}\r\n\r\n\t\tif (!this.browser) {\r\n\t\t\tvar agent = navigator.userAgent.toLowerCase(),\r\n\t\t\t\tplatform = (/(win)/.exec(agent)\r\n\t\t\t\t\t\t|| /(mac)/.exec(agent)\r\n\t\t\t\t\t\t|| /(linux)/.exec(agent)\r\n\t\t\t\t\t\t|| [])[0],\r\n\t\t\t\tbrowser = proto.browser = { platform: platform };\r\n\t\t\tif (platform)\r\n\t\t\t\tbrowser[platform] = true;\r\n\t\t\tagent.replace(\r\n\t\t\t\t/(opera|chrome|safari|webkit|firefox|msie|trident|atom)\\/?\\s*([.\\d]+)(?:.*version\\/([.\\d]+))?(?:.*rv\\:([.\\d]+))?/g,\r\n\t\t\t\tfunction(all, n, v1, v2, rv) {\r\n\t\t\t\t\tif (!browser.chrome) {\r\n\t\t\t\t\t\tvar v = n === 'opera' ? v2 : v1;\r\n\t\t\t\t\t\tif (n === 'trident') {\r\n\t\t\t\t\t\t\tv = rv;\r\n\t\t\t\t\t\t\tn = 'msie';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbrowser.version = v;\r\n\t\t\t\t\t\tbrowser.versionNumber = parseFloat(v);\r\n\t\t\t\t\t\tbrowser.name = n;\r\n\t\t\t\t\t\tbrowser[n] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t\tif (browser.chrome)\r\n\t\t\t\tdelete browser.webkit;\r\n\t\t\tif (browser.atom)\r\n\t\t\t\tdelete browser.chrome;\r\n\t\t}\r\n\t},\r\n\r\n\tversion: \"0.9.25\",\r\n\r\n\tgetView: function() {\r\n\t\treturn this.project && this.project.getView();\r\n\t},\r\n\r\n\tgetPaper: function() {\r\n\t\treturn this;\r\n\t},\r\n\r\n\texecute: function(code, url, options) {\r\n\t\tpaper.PaperScript.execute(code, this, url, options);\r\n\t\tView.updateFocus();\r\n\t},\r\n\r\n\tinstall: function(scope) {\r\n\t\tvar that = this;\r\n\t\tBase.each(['project', 'view', 'tool'], function(key) {\r\n\t\t\tBase.define(scope, key, {\r\n\t\t\t\tconfigurable: true,\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn that[key];\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\t\tfor (var key in this)\r\n\t\t\tif (!/^_/.test(key) && this[key])\r\n\t\t\t\tscope[key] = this[key];\r\n\t},\r\n\r\n\tsetup: function(element) {\r\n\t\tpaper = this;\r\n\t\tthis.project = new Project(element);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tactivate: function() {\r\n\t\tpaper = this;\r\n\t},\r\n\r\n\tclear: function() {\r\n\t\tfor (var i = this.projects.length - 1; i >= 0; i--)\r\n\t\t\tthis.projects[i].remove();\r\n\t\tfor (var i = this.tools.length - 1; i >= 0; i--)\r\n\t\t\tthis.tools[i].remove();\r\n\t\tfor (var i = this.palettes.length - 1; i >= 0; i--)\r\n\t\t\tthis.palettes[i].remove();\r\n\t},\r\n\r\n\tremove: function() {\r\n\t\tthis.clear();\r\n\t\tdelete PaperScope._scopes[this._id];\r\n\t},\r\n\r\n\tstatics: new function() {\r\n\t\tfunction handleAttribute(name) {\r\n\t\t\tname += 'Attribute';\r\n\t\t\treturn function(el, attr) {\r\n\t\t\t\treturn el[name](attr) || el[name]('data-paper-' + attr);\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\t_scopes: {},\r\n\t\t\t_id: 0,\r\n\r\n\t\t\tget: function(id) {\r\n\t\t\t\treturn this._scopes[id] || null;\r\n\t\t\t},\r\n\r\n\t\t\tgetAttribute: handleAttribute('get'),\r\n\t\t\thasAttribute: handleAttribute('has')\r\n\t\t};\r\n\t}\r\n});\r\n\r\nvar PaperScopeItem = Base.extend(Emitter, {\r\n\r\n\tinitialize: function(activate) {\r\n\t\tthis._scope = paper;\r\n\t\tthis._index = this._scope[this._list].push(this) - 1;\r\n\t\tif (activate || !this._scope[this._reference])\r\n\t\t\tthis.activate();\r\n\t},\r\n\r\n\tactivate: function() {\r\n\t\tif (!this._scope)\r\n\t\t\treturn false;\r\n\t\tvar prev = this._scope[this._reference];\r\n\t\tif (prev && prev !== this)\r\n\t\t\tprev.emit('deactivate');\r\n\t\tthis._scope[this._reference] = this;\r\n\t\tthis.emit('activate', prev);\r\n\t\treturn true;\r\n\t},\r\n\r\n\tisActive: function() {\r\n\t\treturn this._scope[this._reference] === this;\r\n\t},\r\n\r\n\tremove: function() {\r\n\t\tif (this._index == null)\r\n\t\t\treturn false;\r\n\t\tBase.splice(this._scope[this._list], null, this._index, 1);\r\n\t\tif (this._scope[this._reference] == this)\r\n\t\t\tthis._scope[this._reference] = null;\r\n\t\tthis._scope = null;\r\n\t\treturn true;\r\n\t}\r\n});\r\n\r\nvar Formatter = Base.extend({\r\n\tinitialize: function(precision) {\r\n\t\tthis.precision = precision || 5;\r\n\t\tthis.multiplier = Math.pow(10, this.precision);\r\n\t},\r\n\r\n\tnumber: function(val) {\r\n\t\treturn Math.round(val * this.multiplier) / this.multiplier;\r\n\t},\r\n\r\n\tpair: function(val1, val2, separator) {\r\n\t\treturn this.number(val1) + (separator || ',') + this.number(val2);\r\n\t},\r\n\r\n\tpoint: function(val, separator) {\r\n\t\treturn this.number(val.x) + (separator || ',') + this.number(val.y);\r\n\t},\r\n\r\n\tsize: function(val, separator) {\r\n\t\treturn this.number(val.width) + (separator || ',')\r\n\t\t\t\t+ this.number(val.height);\r\n\t},\r\n\r\n\trectangle: function(val, separator) {\r\n\t\treturn this.point(val, separator) + (separator || ',')\r\n\t\t\t\t+ this.size(val, separator);\r\n\t}\r\n});\r\n\r\nFormatter.instance = new Formatter();\r\n\r\nvar Numerical = new function() {\r\n\r\n\tvar abscissas = [\r\n\t\t[  0.5773502691896257645091488],\r\n\t\t[0,0.7745966692414833770358531],\r\n\t\t[  0.3399810435848562648026658,0.8611363115940525752239465],\r\n\t\t[0,0.5384693101056830910363144,0.9061798459386639927976269],\r\n\t\t[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],\r\n\t\t[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],\r\n\t\t[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],\r\n\t\t[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],\r\n\t\t[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],\r\n\t\t[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],\r\n\t\t[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],\r\n\t\t[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],\r\n\t\t[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],\r\n\t\t[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],\r\n\t\t[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]\r\n\t];\r\n\r\n\tvar weights = [\r\n\t\t[1],\r\n\t\t[0.8888888888888888888888889,0.5555555555555555555555556],\r\n\t\t[0.6521451548625461426269361,0.3478548451374538573730639],\r\n\t\t[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],\r\n\t\t[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],\r\n\t\t[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],\r\n\t\t[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],\r\n\t\t[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],\r\n\t\t[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],\r\n\t\t[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],\r\n\t\t[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],\r\n\t\t[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],\r\n\t\t[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],\r\n\t\t[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],\r\n\t\t[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]\r\n\t];\r\n\r\n\tvar abs = Math.abs,\r\n\t\tsqrt = Math.sqrt,\r\n\t\tpow = Math.pow,\r\n\t\tEPSILON = 1e-12,\r\n\t\tMACHINE_EPSILON = 1.12e-16;\r\n\r\n\tfunction clip(value, min, max) {\r\n\t\treturn value < min ? min : value > max ? max : value;\r\n\t}\r\n\r\n\treturn {\r\n\t\tTOLERANCE: 1e-6,\r\n\t\tEPSILON: EPSILON,\r\n\t\tMACHINE_EPSILON: MACHINE_EPSILON,\r\n\t\tCURVETIME_EPSILON: 4e-7,\r\n\t\tGEOMETRIC_EPSILON: 2e-7,\r\n\t\tWINDING_EPSILON: 2e-7,\r\n\t\tTRIGONOMETRIC_EPSILON: 1e-7,\r\n\t\tCLIPPING_EPSILON: 1e-7,\r\n\t\tKAPPA: 4 * (sqrt(2) - 1) / 3,\r\n\r\n\t\tisZero: function(val) {\r\n\t\t\treturn val >= -EPSILON && val <= EPSILON;\r\n\t\t},\r\n\r\n\t\tintegrate: function(f, a, b, n) {\r\n\t\t\tvar x = abscissas[n - 2],\r\n\t\t\t\tw = weights[n - 2],\r\n\t\t\t\tA = (b - a) * 0.5,\r\n\t\t\t\tB = A + a,\r\n\t\t\t\ti = 0,\r\n\t\t\t\tm = (n + 1) >> 1,\r\n\t\t\t\tsum = n & 1 ? w[i++] * f(B) : 0;\r\n\t\t\twhile (i < m) {\r\n\t\t\t\tvar Ax = A * x[i];\r\n\t\t\t\tsum += w[i++] * (f(B + Ax) + f(B - Ax));\r\n\t\t\t}\r\n\t\t\treturn A * sum;\r\n\t\t},\r\n\r\n\t\tfindRoot: function(f, df, x, a, b, n, tolerance) {\r\n\t\t\tfor (var i = 0; i < n; i++) {\r\n\t\t\t\tvar fx = f(x),\r\n\t\t\t\t\tdx = fx / df(x),\r\n\t\t\t\t\tnx = x - dx;\r\n\t\t\t\tif (abs(dx) < tolerance)\r\n\t\t\t\t\treturn nx;\r\n\t\t\t\tif (fx > 0) {\r\n\t\t\t\t\tb = x;\r\n\t\t\t\t\tx = nx <= a ? (a + b) * 0.5 : nx;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ta = x;\r\n\t\t\t\t\tx = nx >= b ? (a + b) * 0.5 : nx;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn x;\r\n\t\t},\r\n\r\n\t\tsolveQuadratic: function(a, b, c, roots, min, max) {\r\n\t\t\tvar count = 0,\r\n\t\t\t\teMin = min - EPSILON,\r\n\t\t\t\teMax = max + EPSILON,\r\n\t\t\t\tx1, x2 = Infinity,\r\n\t\t\t\tB = b,\r\n\t\t\t\tD;\r\n\t\t\tb /= -2;\r\n\t\t\tD = b * b - a * c;\r\n\t\t\tif (D !== 0 && abs(D) < MACHINE_EPSILON) {\r\n\t\t\t\tvar gmC = pow(abs(a * b * c), 1 / 3);\r\n\t\t\t\tif (gmC < 1e-8) {\r\n\t\t\t\t\tvar mult = pow(10,\r\n\t\t\t\t\t\t\tabs(Math.floor(Math.log(gmC) * Math.LOG10E)));\r\n\t\t\t\t\tif (!isFinite(mult))\r\n\t\t\t\t\t\tmult = 0;\r\n\t\t\t\t\ta *= mult;\r\n\t\t\t\t\tb *= mult;\r\n\t\t\t\t\tc *= mult;\r\n\t\t\t\t\tD = b * b - a * c;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (abs(a) < EPSILON) {\r\n\t\t\t\tif (abs(B) < EPSILON)\r\n\t\t\t\t\treturn abs(c) < EPSILON ? -1 : 0;\r\n\t\t\t\tx1 = -c / B;\r\n\t\t\t} else if (D >= -MACHINE_EPSILON) {\r\n\t\t\t\tvar Q = D < 0 ? 0 : sqrt(D),\r\n\t\t\t\t\tR = b + (b < 0 ? -Q : Q);\r\n\t\t\t\tif (R === 0) {\r\n\t\t\t\t\tx1 = c / a;\r\n\t\t\t\t\tx2 = -x1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tx1 = R / a;\r\n\t\t\t\t\tx2 = c / R;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (isFinite(x1) && (min == null || x1 > eMin && x1 < eMax))\r\n\t\t\t\troots[count++] = min == null ? x1 : clip(x1, min, max);\r\n\t\t\tif (x2 !== x1\r\n\t\t\t\t\t&& isFinite(x2) && (min == null || x2 > eMin && x2 < eMax))\r\n\t\t\t\troots[count++] = min == null ? x2 : clip(x2, min, max);\r\n\t\t\treturn count;\r\n\t\t},\r\n\r\n\t\tsolveCubic: function(a, b, c, d, roots, min, max) {\r\n\t\t\tvar count = 0,\r\n\t\t\t\tx, b1, c2;\r\n\t\t\tif (abs(a) < EPSILON) {\r\n\t\t\t\ta = b;\r\n\t\t\t\tb1 = c;\r\n\t\t\t\tc2 = d;\r\n\t\t\t\tx = Infinity;\r\n\t\t\t} else if (abs(d) < EPSILON) {\r\n\t\t\t\tb1 = b;\r\n\t\t\t\tc2 = c;\r\n\t\t\t\tx = 0;\r\n\t\t\t} else {\r\n\t\t\t\tvar ec = 1 + MACHINE_EPSILON,\r\n\t\t\t\t\tx0, q, qd, t, r, s, tmp;\r\n\t\t\t\tx = -(b / a) / 3;\r\n\t\t\t\ttmp = a * x,\r\n\t\t\t\tb1 = tmp + b,\r\n\t\t\t\tc2 = b1 * x + c,\r\n\t\t\t\tqd = (tmp + b1) * x + c2,\r\n\t\t\t\tq = c2 * x + d;\r\n\t\t\t\tt = q /a;\r\n\t\t\t\tr = pow(abs(t), 1/3);\r\n\t\t\t\ts = t < 0 ? -1 : 1;\r\n\t\t\t\tt = -qd / a;\r\n\t\t\t\tr = t > 0 ? 1.3247179572 * Math.max(r, sqrt(t)) : r;\r\n\t\t\t\tx0 = x - s * r;\r\n\t\t\t\tif (x0 !== x) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tx = x0;\r\n\t\t\t\t\t\ttmp = a * x,\r\n\t\t\t\t\t\tb1 = tmp + b,\r\n\t\t\t\t\t\tc2 = b1 * x + c,\r\n\t\t\t\t\t\tqd = (tmp + b1) * x + c2,\r\n\t\t\t\t\t\tq = c2 * x + d;\r\n\t\t\t\t\t\tx0 = qd === 0 ? x : x - q / qd / ec;\r\n\t\t\t\t\t\tif (x0 === x) {\r\n\t\t\t\t\t\t\tx = x0;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} while (s * x0 > s * x);\r\n\t\t\t\t\tif (abs(a) * x * x > abs(d / x)) {\r\n\t\t\t\t\t\tc2 = -d / x;\r\n\t\t\t\t\t\tb1 = (c2 - c) / x;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar count = Numerical.solveQuadratic(a, b1, c2, roots, min, max);\r\n\t\t\tif (isFinite(x) && (count === 0 || x !== roots[count - 1])\r\n\t\t\t\t\t&& (min == null || x > min - EPSILON && x < max + EPSILON))\r\n\t\t\t\troots[count++] = min == null ? x : clip(x, min, max);\r\n\t\t\treturn count;\r\n\t\t}\r\n\t};\r\n};\r\n\r\nvar UID = {\r\n\t_id: 1,\r\n\t_pools: {},\r\n\r\n\tget: function(ctor) {\r\n\t\tif (ctor) {\r\n\t\t\tvar name = ctor._class,\r\n\t\t\t\tpool = this._pools[name];\r\n\t\t\tif (!pool)\r\n\t\t\t\tpool = this._pools[name] = { _id: 1 };\r\n\t\t\treturn pool._id++;\r\n\t\t} else {\r\n\t\t\treturn this._id++;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nvar Point = Base.extend({\r\n\t_class: 'Point',\r\n\t_readIndex: true,\r\n\r\n\tinitialize: function Point(arg0, arg1) {\r\n\t\tvar type = typeof arg0;\r\n\t\tif (type === 'number') {\r\n\t\t\tvar hasY = typeof arg1 === 'number';\r\n\t\t\tthis.x = arg0;\r\n\t\t\tthis.y = hasY ? arg1 : arg0;\r\n\t\t\tif (this.__read)\r\n\t\t\t\tthis.__read = hasY ? 2 : 1;\r\n\t\t} else if (type === 'undefined' || arg0 === null) {\r\n\t\t\tthis.x = this.y = 0;\r\n\t\t\tif (this.__read)\r\n\t\t\t\tthis.__read = arg0 === null ? 1 : 0;\r\n\t\t} else {\r\n\t\t\tif (Array.isArray(arg0)) {\r\n\t\t\t\tthis.x = arg0[0];\r\n\t\t\t\tthis.y = arg0.length > 1 ? arg0[1] : arg0[0];\r\n\t\t\t} else if (arg0.x != null) {\r\n\t\t\t\tthis.x = arg0.x;\r\n\t\t\t\tthis.y = arg0.y;\r\n\t\t\t} else if (arg0.width != null) {\r\n\t\t\t\tthis.x = arg0.width;\r\n\t\t\t\tthis.y = arg0.height;\r\n\t\t\t} else if (arg0.angle != null) {\r\n\t\t\t\tthis.x = arg0.length;\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.setAngle(arg0.angle);\r\n\t\t\t} else {\r\n\t\t\t\tthis.x = this.y = 0;\r\n\t\t\t\tif (this.__read)\r\n\t\t\t\t\tthis.__read = 0;\r\n\t\t\t}\r\n\t\t\tif (this.__read)\r\n\t\t\t\tthis.__read = 1;\r\n\t\t}\r\n\t},\r\n\r\n\tset: function(x, y) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tequals: function(point) {\r\n\t\treturn this === point || point\r\n\t\t\t\t&& (this.x === point.x && this.y === point.y\r\n\t\t\t\t\t|| Array.isArray(point)\r\n\t\t\t\t\t\t&& this.x === point[0] && this.y === point[1])\r\n\t\t\t\t|| false;\r\n\t},\r\n\r\n\tclone: function() {\r\n\t\treturn new Point(this.x, this.y);\r\n\t},\r\n\r\n\ttoString: function() {\r\n\t\tvar f = Formatter.instance;\r\n\t\treturn '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';\r\n\t},\r\n\r\n\t_serialize: function(options) {\r\n\t\tvar f = options.formatter;\r\n\t\treturn [f.number(this.x), f.number(this.y)];\r\n\t},\r\n\r\n\tgetLength: function() {\r\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\r\n\t},\r\n\r\n\tsetLength: function(length) {\r\n\t\tif (this.isZero()) {\r\n\t\t\tvar angle = this._angle || 0;\r\n\t\t\tthis.set(\r\n\t\t\t\tMath.cos(angle) * length,\r\n\t\t\t\tMath.sin(angle) * length\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tvar scale = length / this.getLength();\r\n\t\t\tif (Numerical.isZero(scale))\r\n\t\t\t\tthis.getAngle();\r\n\t\t\tthis.set(\r\n\t\t\t\tthis.x * scale,\r\n\t\t\t\tthis.y * scale\r\n\t\t\t);\r\n\t\t}\r\n\t},\r\n\tgetAngle: function() {\r\n\t\treturn this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;\r\n\t},\r\n\r\n\tsetAngle: function(angle) {\r\n\t\tthis.setAngleInRadians.call(this, angle * Math.PI / 180);\r\n\t},\r\n\r\n\tgetAngleInDegrees: '#getAngle',\r\n\tsetAngleInDegrees: '#setAngle',\r\n\r\n\tgetAngleInRadians: function() {\r\n\t\tif (!arguments.length) {\r\n\t\t\treturn this.isZero()\r\n\t\t\t\t\t? this._angle || 0\r\n\t\t\t\t\t: this._angle = Math.atan2(this.y, this.x);\r\n\t\t} else {\r\n\t\t\tvar point = Point.read(arguments),\r\n\t\t\t\tdiv = this.getLength() * point.getLength();\r\n\t\t\tif (Numerical.isZero(div)) {\r\n\t\t\t\treturn NaN;\r\n\t\t\t} else {\r\n\t\t\t\tvar a = this.dot(point) / div;\r\n\t\t\t\treturn Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tsetAngleInRadians: function(angle) {\r\n\t\tthis._angle = angle;\r\n\t\tif (!this.isZero()) {\r\n\t\t\tvar length = this.getLength();\r\n\t\t\tthis.set(\r\n\t\t\t\tMath.cos(angle) * length,\r\n\t\t\t\tMath.sin(angle) * length\r\n\t\t\t);\r\n\t\t}\r\n\t},\r\n\r\n\tgetQuadrant: function() {\r\n\t\treturn this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;\r\n\t}\r\n}, {\r\n\tbeans: false,\r\n\r\n\tgetDirectedAngle: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\treturn Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;\r\n\t},\r\n\r\n\tgetDistance: function() {\r\n\t\tvar point = Point.read(arguments),\r\n\t\t\tx = point.x - this.x,\r\n\t\t\ty = point.y - this.y,\r\n\t\t\td = x * x + y * y,\r\n\t\t\tsquared = Base.read(arguments);\r\n\t\treturn squared ? d : Math.sqrt(d);\r\n\t},\r\n\r\n\tnormalize: function(length) {\r\n\t\tif (length === undefined)\r\n\t\t\tlength = 1;\r\n\t\tvar current = this.getLength(),\r\n\t\t\tscale = current !== 0 ? length / current : 0,\r\n\t\t\tpoint = new Point(this.x * scale, this.y * scale);\r\n\t\tif (scale >= 0)\r\n\t\t\tpoint._angle = this._angle;\r\n\t\treturn point;\r\n\t},\r\n\r\n\trotate: function(angle, center) {\r\n\t\tif (angle === 0)\r\n\t\t\treturn this.clone();\r\n\t\tangle = angle * Math.PI / 180;\r\n\t\tvar point = center ? this.subtract(center) : this,\r\n\t\t\tsin = Math.sin(angle),\r\n\t\t\tcos = Math.cos(angle);\r\n\t\tpoint = new Point(\r\n\t\t\tpoint.x * cos - point.y * sin,\r\n\t\t\tpoint.x * sin + point.y * cos\r\n\t\t);\r\n\t\treturn center ? point.add(center) : point;\r\n\t},\r\n\r\n\ttransform: function(matrix) {\r\n\t\treturn matrix ? matrix._transformPoint(this) : this;\r\n\t},\r\n\r\n\tadd: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\treturn new Point(this.x + point.x, this.y + point.y);\r\n\t},\r\n\r\n\tsubtract: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\treturn new Point(this.x - point.x, this.y - point.y);\r\n\t},\r\n\r\n\tmultiply: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\treturn new Point(this.x * point.x, this.y * point.y);\r\n\t},\r\n\r\n\tdivide: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\treturn new Point(this.x / point.x, this.y / point.y);\r\n\t},\r\n\r\n\tmodulo: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\treturn new Point(this.x % point.x, this.y % point.y);\r\n\t},\r\n\r\n\tnegate: function() {\r\n\t\treturn new Point(-this.x, -this.y);\r\n\t},\r\n\r\n\tisInside: function() {\r\n\t\treturn Rectangle.read(arguments).contains(this);\r\n\t},\r\n\r\n\tisClose: function() {\r\n\t\tvar point = Point.read(arguments),\r\n\t\t\ttolerance = Base.read(arguments);\r\n\t\treturn this.getDistance(point) < tolerance;\r\n\t},\r\n\r\n\tisCollinear: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\treturn Point.isCollinear(this.x, this.y, point.x, point.y);\r\n\t},\r\n\r\n\tisColinear: '#isCollinear',\r\n\r\n\tisOrthogonal: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\treturn Point.isOrthogonal(this.x, this.y, point.x, point.y);\r\n\t},\r\n\r\n\tisZero: function() {\r\n\t\treturn Numerical.isZero(this.x) && Numerical.isZero(this.y);\r\n\t},\r\n\r\n\tisNaN: function() {\r\n\t\treturn isNaN(this.x) || isNaN(this.y);\r\n\t},\r\n\r\n\tdot: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\treturn this.x * point.x + this.y * point.y;\r\n\t},\r\n\r\n\tcross: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\treturn this.x * point.y - this.y * point.x;\r\n\t},\r\n\r\n\tproject: function() {\r\n\t\tvar point = Point.read(arguments),\r\n\t\t\tscale = point.isZero() ? 0 : this.dot(point) / point.dot(point);\r\n\t\treturn new Point(\r\n\t\t\tpoint.x * scale,\r\n\t\t\tpoint.y * scale\r\n\t\t);\r\n\t},\r\n\r\n\tstatics: {\r\n\t\tmin: function() {\r\n\t\t\tvar point1 = Point.read(arguments),\r\n\t\t\t\tpoint2 = Point.read(arguments);\r\n\t\t\treturn new Point(\r\n\t\t\t\tMath.min(point1.x, point2.x),\r\n\t\t\t\tMath.min(point1.y, point2.y)\r\n\t\t\t);\r\n\t\t},\r\n\r\n\t\tmax: function() {\r\n\t\t\tvar point1 = Point.read(arguments),\r\n\t\t\t\tpoint2 = Point.read(arguments);\r\n\t\t\treturn new Point(\r\n\t\t\t\tMath.max(point1.x, point2.x),\r\n\t\t\t\tMath.max(point1.y, point2.y)\r\n\t\t\t);\r\n\t\t},\r\n\r\n\t\trandom: function() {\r\n\t\t\treturn new Point(Math.random(), Math.random());\r\n\t\t},\r\n\r\n\t\tisCollinear: function(x1, y1, x2, y2) {\r\n\t\t\treturn Math.abs(x1 * y2 - y1 * x2)\r\n\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\r\n\t\t\t\t\t\t* 1e-7;\r\n\t\t},\r\n\r\n\t\tisOrthogonal: function(x1, y1, x2, y2) {\r\n\t\t\treturn Math.abs(x1 * x2 + y1 * y2)\r\n\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\r\n\t\t\t\t\t\t* 1e-7;\r\n\t\t}\r\n\t}\r\n}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {\r\n\tvar op = Math[name];\r\n\tthis[name] = function() {\r\n\t\treturn new Point(op(this.x), op(this.y));\r\n\t};\r\n}, {}));\r\n\r\nvar LinkedPoint = Point.extend({\r\n\tinitialize: function Point(x, y, owner, setter) {\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._owner = owner;\r\n\t\tthis._setter = setter;\r\n\t},\r\n\r\n\tset: function(x, y, _dontNotify) {\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tif (!_dontNotify)\r\n\t\t\tthis._owner[this._setter](this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetX: function() {\r\n\t\treturn this._x;\r\n\t},\r\n\r\n\tsetX: function(x) {\r\n\t\tthis._x = x;\r\n\t\tthis._owner[this._setter](this);\r\n\t},\r\n\r\n\tgetY: function() {\r\n\t\treturn this._y;\r\n\t},\r\n\r\n\tsetY: function(y) {\r\n\t\tthis._y = y;\r\n\t\tthis._owner[this._setter](this);\r\n\t}\r\n});\r\n\r\nvar Size = Base.extend({\r\n\t_class: 'Size',\r\n\t_readIndex: true,\r\n\r\n\tinitialize: function Size(arg0, arg1) {\r\n\t\tvar type = typeof arg0;\r\n\t\tif (type === 'number') {\r\n\t\t\tvar hasHeight = typeof arg1 === 'number';\r\n\t\t\tthis.width = arg0;\r\n\t\t\tthis.height = hasHeight ? arg1 : arg0;\r\n\t\t\tif (this.__read)\r\n\t\t\t\tthis.__read = hasHeight ? 2 : 1;\r\n\t\t} else if (type === 'undefined' || arg0 === null) {\r\n\t\t\tthis.width = this.height = 0;\r\n\t\t\tif (this.__read)\r\n\t\t\t\tthis.__read = arg0 === null ? 1 : 0;\r\n\t\t} else {\r\n\t\t\tif (Array.isArray(arg0)) {\r\n\t\t\t\tthis.width = arg0[0];\r\n\t\t\t\tthis.height = arg0.length > 1 ? arg0[1] : arg0[0];\r\n\t\t\t} else if (arg0.width != null) {\r\n\t\t\t\tthis.width = arg0.width;\r\n\t\t\t\tthis.height = arg0.height;\r\n\t\t\t} else if (arg0.x != null) {\r\n\t\t\t\tthis.width = arg0.x;\r\n\t\t\t\tthis.height = arg0.y;\r\n\t\t\t} else {\r\n\t\t\t\tthis.width = this.height = 0;\r\n\t\t\t\tif (this.__read)\r\n\t\t\t\t\tthis.__read = 0;\r\n\t\t\t}\r\n\t\t\tif (this.__read)\r\n\t\t\t\tthis.__read = 1;\r\n\t\t}\r\n\t},\r\n\r\n\tset: function(width, height) {\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tequals: function(size) {\r\n\t\treturn size === this || size && (this.width === size.width\r\n\t\t\t\t&& this.height === size.height\r\n\t\t\t\t|| Array.isArray(size) && this.width === size[0]\r\n\t\t\t\t\t&& this.height === size[1]) || false;\r\n\t},\r\n\r\n\tclone: function() {\r\n\t\treturn new Size(this.width, this.height);\r\n\t},\r\n\r\n\ttoString: function() {\r\n\t\tvar f = Formatter.instance;\r\n\t\treturn '{ width: ' + f.number(this.width)\r\n\t\t\t\t+ ', height: ' + f.number(this.height) + ' }';\r\n\t},\r\n\r\n\t_serialize: function(options) {\r\n\t\tvar f = options.formatter;\r\n\t\treturn [f.number(this.width),\r\n\t\t\t\tf.number(this.height)];\r\n\t},\r\n\r\n\tadd: function() {\r\n\t\tvar size = Size.read(arguments);\r\n\t\treturn new Size(this.width + size.width, this.height + size.height);\r\n\t},\r\n\r\n\tsubtract: function() {\r\n\t\tvar size = Size.read(arguments);\r\n\t\treturn new Size(this.width - size.width, this.height - size.height);\r\n\t},\r\n\r\n\tmultiply: function() {\r\n\t\tvar size = Size.read(arguments);\r\n\t\treturn new Size(this.width * size.width, this.height * size.height);\r\n\t},\r\n\r\n\tdivide: function() {\r\n\t\tvar size = Size.read(arguments);\r\n\t\treturn new Size(this.width / size.width, this.height / size.height);\r\n\t},\r\n\r\n\tmodulo: function() {\r\n\t\tvar size = Size.read(arguments);\r\n\t\treturn new Size(this.width % size.width, this.height % size.height);\r\n\t},\r\n\r\n\tnegate: function() {\r\n\t\treturn new Size(-this.width, -this.height);\r\n\t},\r\n\r\n\tisZero: function() {\r\n\t\treturn Numerical.isZero(this.width) && Numerical.isZero(this.height);\r\n\t},\r\n\r\n\tisNaN: function() {\r\n\t\treturn isNaN(this.width) || isNaN(this.height);\r\n\t},\r\n\r\n\tstatics: {\r\n\t\tmin: function(size1, size2) {\r\n\t\t\treturn new Size(\r\n\t\t\t\tMath.min(size1.width, size2.width),\r\n\t\t\t\tMath.min(size1.height, size2.height));\r\n\t\t},\r\n\r\n\t\tmax: function(size1, size2) {\r\n\t\t\treturn new Size(\r\n\t\t\t\tMath.max(size1.width, size2.width),\r\n\t\t\t\tMath.max(size1.height, size2.height));\r\n\t\t},\r\n\r\n\t\trandom: function() {\r\n\t\t\treturn new Size(Math.random(), Math.random());\r\n\t\t}\r\n\t}\r\n}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {\r\n\tvar op = Math[name];\r\n\tthis[name] = function() {\r\n\t\treturn new Size(op(this.width), op(this.height));\r\n\t};\r\n}, {}));\r\n\r\nvar LinkedSize = Size.extend({\r\n\tinitialize: function Size(width, height, owner, setter) {\r\n\t\tthis._width = width;\r\n\t\tthis._height = height;\r\n\t\tthis._owner = owner;\r\n\t\tthis._setter = setter;\r\n\t},\r\n\r\n\tset: function(width, height, _dontNotify) {\r\n\t\tthis._width = width;\r\n\t\tthis._height = height;\r\n\t\tif (!_dontNotify)\r\n\t\t\tthis._owner[this._setter](this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetWidth: function() {\r\n\t\treturn this._width;\r\n\t},\r\n\r\n\tsetWidth: function(width) {\r\n\t\tthis._width = width;\r\n\t\tthis._owner[this._setter](this);\r\n\t},\r\n\r\n\tgetHeight: function() {\r\n\t\treturn this._height;\r\n\t},\r\n\r\n\tsetHeight: function(height) {\r\n\t\tthis._height = height;\r\n\t\tthis._owner[this._setter](this);\r\n\t}\r\n});\r\n\r\nvar Rectangle = Base.extend({\r\n\t_class: 'Rectangle',\r\n\t_readIndex: true,\r\n\tbeans: true,\r\n\r\n\tinitialize: function Rectangle(arg0, arg1, arg2, arg3) {\r\n\t\tvar type = typeof arg0,\r\n\t\t\tread = 0;\r\n\t\tif (type === 'number') {\r\n\t\t\tthis.x = arg0;\r\n\t\t\tthis.y = arg1;\r\n\t\t\tthis.width = arg2;\r\n\t\t\tthis.height = arg3;\r\n\t\t\tread = 4;\r\n\t\t} else if (type === 'undefined' || arg0 === null) {\r\n\t\t\tthis.x = this.y = this.width = this.height = 0;\r\n\t\t\tread = arg0 === null ? 1 : 0;\r\n\t\t} else if (arguments.length === 1) {\r\n\t\t\tif (Array.isArray(arg0)) {\r\n\t\t\t\tthis.x = arg0[0];\r\n\t\t\t\tthis.y = arg0[1];\r\n\t\t\t\tthis.width = arg0[2];\r\n\t\t\t\tthis.height = arg0[3];\r\n\t\t\t\tread = 1;\r\n\t\t\t} else if (arg0.x !== undefined || arg0.width !== undefined) {\r\n\t\t\t\tthis.x = arg0.x || 0;\r\n\t\t\t\tthis.y = arg0.y || 0;\r\n\t\t\t\tthis.width = arg0.width || 0;\r\n\t\t\t\tthis.height = arg0.height || 0;\r\n\t\t\t\tread = 1;\r\n\t\t\t} else if (arg0.from === undefined && arg0.to === undefined) {\r\n\t\t\t\tthis.x = this.y = this.width = this.height = 0;\r\n\t\t\t\tthis._set(arg0);\r\n\t\t\t\tread = 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!read) {\r\n\t\t\tvar point = Point.readNamed(arguments, 'from'),\r\n\t\t\t\tnext = Base.peek(arguments);\r\n\t\t\tthis.x = point.x;\r\n\t\t\tthis.y = point.y;\r\n\t\t\tif (next && next.x !== undefined || Base.hasNamed(arguments, 'to')) {\r\n\t\t\t\tvar to = Point.readNamed(arguments, 'to');\r\n\t\t\t\tthis.width = to.x - point.x;\r\n\t\t\t\tthis.height = to.y - point.y;\r\n\t\t\t\tif (this.width < 0) {\r\n\t\t\t\t\tthis.x = to.x;\r\n\t\t\t\t\tthis.width = -this.width;\r\n\t\t\t\t}\r\n\t\t\t\tif (this.height < 0) {\r\n\t\t\t\t\tthis.y = to.y;\r\n\t\t\t\t\tthis.height = -this.height;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar size = Size.read(arguments);\r\n\t\t\t\tthis.width = size.width;\r\n\t\t\t\tthis.height = size.height;\r\n\t\t\t}\r\n\t\t\tread = arguments.__index;\r\n\t\t}\r\n\t\tif (this.__read)\r\n\t\t\tthis.__read = read;\r\n\t},\r\n\r\n\tset: function(x, y, width, height) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclone: function() {\r\n\t\treturn new Rectangle(this.x, this.y, this.width, this.height);\r\n\t},\r\n\r\n\tequals: function(rect) {\r\n\t\tvar rt = Base.isPlainValue(rect)\r\n\t\t\t\t? Rectangle.read(arguments)\r\n\t\t\t\t: rect;\r\n\t\treturn rt === this\r\n\t\t\t\t|| rt && this.x === rt.x && this.y === rt.y\r\n\t\t\t\t\t&& this.width === rt.width && this.height === rt.height\r\n\t\t\t\t|| false;\r\n\t},\r\n\r\n\ttoString: function() {\r\n\t\tvar f = Formatter.instance;\r\n\t\treturn '{ x: ' + f.number(this.x)\r\n\t\t\t\t+ ', y: ' + f.number(this.y)\r\n\t\t\t\t+ ', width: ' + f.number(this.width)\r\n\t\t\t\t+ ', height: ' + f.number(this.height)\r\n\t\t\t\t+ ' }';\r\n\t},\r\n\r\n\t_serialize: function(options) {\r\n\t\tvar f = options.formatter;\r\n\t\treturn [f.number(this.x),\r\n\t\t\t\tf.number(this.y),\r\n\t\t\t\tf.number(this.width),\r\n\t\t\t\tf.number(this.height)];\r\n\t},\r\n\r\n\tgetPoint: function(_dontLink) {\r\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\r\n\t\treturn new ctor(this.x, this.y, this, 'setPoint');\r\n\t},\r\n\r\n\tsetPoint: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\tthis.x = point.x;\r\n\t\tthis.y = point.y;\r\n\t},\r\n\r\n\tgetSize: function(_dontLink) {\r\n\t\tvar ctor = _dontLink ? Size : LinkedSize;\r\n\t\treturn new ctor(this.width, this.height, this, 'setSize');\r\n\t},\r\n\r\n\tsetSize: function() {\r\n\t\tvar size = Size.read(arguments);\r\n\t\tif (this._fixX)\r\n\t\t\tthis.x += (this.width - size.width) * this._fixX;\r\n\t\tif (this._fixY)\r\n\t\t\tthis.y += (this.height - size.height) * this._fixY;\r\n\t\tthis.width = size.width;\r\n\t\tthis.height = size.height;\r\n\t\tthis._fixW = 1;\r\n\t\tthis._fixH = 1;\r\n\t},\r\n\r\n\tgetLeft: function() {\r\n\t\treturn this.x;\r\n\t},\r\n\r\n\tsetLeft: function(left) {\r\n\t\tif (!this._fixW)\r\n\t\t\tthis.width -= left - this.x;\r\n\t\tthis.x = left;\r\n\t\tthis._fixX = 0;\r\n\t},\r\n\r\n\tgetTop: function() {\r\n\t\treturn this.y;\r\n\t},\r\n\r\n\tsetTop: function(top) {\r\n\t\tif (!this._fixH)\r\n\t\t\tthis.height -= top - this.y;\r\n\t\tthis.y = top;\r\n\t\tthis._fixY = 0;\r\n\t},\r\n\r\n\tgetRight: function() {\r\n\t\treturn this.x + this.width;\r\n\t},\r\n\r\n\tsetRight: function(right) {\r\n\t\tif (this._fixX !== undefined && this._fixX !== 1)\r\n\t\t\tthis._fixW = 0;\r\n\t\tif (this._fixW)\r\n\t\t\tthis.x = right - this.width;\r\n\t\telse\r\n\t\t\tthis.width = right - this.x;\r\n\t\tthis._fixX = 1;\r\n\t},\r\n\r\n\tgetBottom: function() {\r\n\t\treturn this.y + this.height;\r\n\t},\r\n\r\n\tsetBottom: function(bottom) {\r\n\t\tif (this._fixY !== undefined && this._fixY !== 1)\r\n\t\t\tthis._fixH = 0;\r\n\t\tif (this._fixH)\r\n\t\t\tthis.y = bottom - this.height;\r\n\t\telse\r\n\t\t\tthis.height = bottom - this.y;\r\n\t\tthis._fixY = 1;\r\n\t},\r\n\r\n\tgetCenterX: function() {\r\n\t\treturn this.x + this.width * 0.5;\r\n\t},\r\n\r\n\tsetCenterX: function(x) {\r\n\t\tthis.x = x - this.width * 0.5;\r\n\t\tthis._fixX = 0.5;\r\n\t},\r\n\r\n\tgetCenterY: function() {\r\n\t\treturn this.y + this.height * 0.5;\r\n\t},\r\n\r\n\tsetCenterY: function(y) {\r\n\t\tthis.y = y - this.height * 0.5;\r\n\t\tthis._fixY = 0.5;\r\n\t},\r\n\r\n\tgetCenter: function(_dontLink) {\r\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\r\n\t\treturn new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');\r\n\t},\r\n\r\n\tsetCenter: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\tthis.setCenterX(point.x);\r\n\t\tthis.setCenterY(point.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetArea: function() {\r\n\t\treturn this.width * this.height;\r\n\t},\r\n\r\n\tisEmpty: function() {\r\n\t\treturn this.width === 0 || this.height === 0;\r\n\t},\r\n\r\n\tcontains: function(arg) {\r\n\t\treturn arg && arg.width !== undefined\r\n\t\t\t\t|| (Array.isArray(arg) ? arg : arguments).length == 4\r\n\t\t\t\t? this._containsRectangle(Rectangle.read(arguments))\r\n\t\t\t\t: this._containsPoint(Point.read(arguments));\r\n\t},\r\n\r\n\t_containsPoint: function(point) {\r\n\t\tvar x = point.x,\r\n\t\t\ty = point.y;\r\n\t\treturn x >= this.x && y >= this.y\r\n\t\t\t\t&& x <= this.x + this.width\r\n\t\t\t\t&& y <= this.y + this.height;\r\n\t},\r\n\r\n\t_containsRectangle: function(rect) {\r\n\t\tvar x = rect.x,\r\n\t\t\ty = rect.y;\r\n\t\treturn x >= this.x && y >= this.y\r\n\t\t\t\t&& x + rect.width <= this.x + this.width\r\n\t\t\t\t&& y + rect.height <= this.y + this.height;\r\n\t},\r\n\r\n\tintersects: function() {\r\n\t\tvar rect = Rectangle.read(arguments);\r\n\t\treturn rect.x + rect.width > this.x\r\n\t\t\t\t&& rect.y + rect.height > this.y\r\n\t\t\t\t&& rect.x < this.x + this.width\r\n\t\t\t\t&& rect.y < this.y + this.height;\r\n\t},\r\n\r\n\ttouches: function() {\r\n\t\tvar rect = Rectangle.read(arguments);\r\n\t\treturn rect.x + rect.width >= this.x\r\n\t\t\t\t&& rect.y + rect.height >= this.y\r\n\t\t\t\t&& rect.x <= this.x + this.width\r\n\t\t\t\t&& rect.y <= this.y + this.height;\r\n\t},\r\n\r\n\tintersect: function() {\r\n\t\tvar rect = Rectangle.read(arguments),\r\n\t\t\tx1 = Math.max(this.x, rect.x),\r\n\t\t\ty1 = Math.max(this.y, rect.y),\r\n\t\t\tx2 = Math.min(this.x + this.width, rect.x + rect.width),\r\n\t\t\ty2 = Math.min(this.y + this.height, rect.y + rect.height);\r\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\r\n\t},\r\n\r\n\tunite: function() {\r\n\t\tvar rect = Rectangle.read(arguments),\r\n\t\t\tx1 = Math.min(this.x, rect.x),\r\n\t\t\ty1 = Math.min(this.y, rect.y),\r\n\t\t\tx2 = Math.max(this.x + this.width, rect.x + rect.width),\r\n\t\t\ty2 = Math.max(this.y + this.height, rect.y + rect.height);\r\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\r\n\t},\r\n\r\n\tinclude: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\tvar x1 = Math.min(this.x, point.x),\r\n\t\t\ty1 = Math.min(this.y, point.y),\r\n\t\t\tx2 = Math.max(this.x + this.width, point.x),\r\n\t\t\ty2 = Math.max(this.y + this.height, point.y);\r\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\r\n\t},\r\n\r\n\texpand: function() {\r\n\t\tvar amount = Size.read(arguments),\r\n\t\t\thor = amount.width,\r\n\t\t\tver = amount.height;\r\n\t\treturn new Rectangle(this.x - hor / 2, this.y - ver / 2,\r\n\t\t\t\tthis.width + hor, this.height + ver);\r\n\t},\r\n\r\n\tscale: function(hor, ver) {\r\n\t\treturn this.expand(this.width * hor - this.width,\r\n\t\t\t\tthis.height * (ver === undefined ? hor : ver) - this.height);\r\n\t}\r\n}, Base.each([\r\n\t\t['Top', 'Left'], ['Top', 'Right'],\r\n\t\t['Bottom', 'Left'], ['Bottom', 'Right'],\r\n\t\t['Left', 'Center'], ['Top', 'Center'],\r\n\t\t['Right', 'Center'], ['Bottom', 'Center']\r\n\t],\r\n\tfunction(parts, index) {\r\n\t\tvar part = parts.join('');\r\n\t\tvar xFirst = /^[RL]/.test(part);\r\n\t\tif (index >= 4)\r\n\t\t\tparts[1] += xFirst ? 'Y' : 'X';\r\n\t\tvar x = parts[xFirst ? 0 : 1],\r\n\t\t\ty = parts[xFirst ? 1 : 0],\r\n\t\t\tgetX = 'get' + x,\r\n\t\t\tgetY = 'get' + y,\r\n\t\t\tsetX = 'set' + x,\r\n\t\t\tsetY = 'set' + y,\r\n\t\t\tget = 'get' + part,\r\n\t\t\tset = 'set' + part;\r\n\t\tthis[get] = function(_dontLink) {\r\n\t\t\tvar ctor = _dontLink ? Point : LinkedPoint;\r\n\t\t\treturn new ctor(this[getX](), this[getY](), this, set);\r\n\t\t};\r\n\t\tthis[set] = function() {\r\n\t\t\tvar point = Point.read(arguments);\r\n\t\t\tthis[setX](point.x);\r\n\t\t\tthis[setY](point.y);\r\n\t\t};\r\n\t}, {\r\n\t\tbeans: true\r\n\t}\r\n));\r\n\r\nvar LinkedRectangle = Rectangle.extend({\r\n\tinitialize: function Rectangle(x, y, width, height, owner, setter) {\r\n\t\tthis.set(x, y, width, height, true);\r\n\t\tthis._owner = owner;\r\n\t\tthis._setter = setter;\r\n\t},\r\n\r\n\tset: function(x, y, width, height, _dontNotify) {\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._width = width;\r\n\t\tthis._height = height;\r\n\t\tif (!_dontNotify)\r\n\t\t\tthis._owner[this._setter](this);\r\n\t\treturn this;\r\n\t}\r\n},\r\nnew function() {\r\n\tvar proto = Rectangle.prototype;\r\n\r\n\treturn Base.each(['x', 'y', 'width', 'height'], function(key) {\r\n\t\tvar part = Base.capitalize(key);\r\n\t\tvar internal = '_' + key;\r\n\t\tthis['get' + part] = function() {\r\n\t\t\treturn this[internal];\r\n\t\t};\r\n\r\n\t\tthis['set' + part] = function(value) {\r\n\t\t\tthis[internal] = value;\r\n\t\t\tif (!this._dontNotify)\r\n\t\t\t\tthis._owner[this._setter](this);\r\n\t\t};\r\n\t}, Base.each(['Point', 'Size', 'Center',\r\n\t\t\t'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',\r\n\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\r\n\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],\r\n\t\tfunction(key) {\r\n\t\t\tvar name = 'set' + key;\r\n\t\t\tthis[name] = function() {\r\n\t\t\t\tthis._dontNotify = true;\r\n\t\t\t\tproto[name].apply(this, arguments);\r\n\t\t\t\tthis._dontNotify = false;\r\n\t\t\t\tthis._owner[this._setter](this);\r\n\t\t\t};\r\n\t\t}, {\r\n\t\t\tisSelected: function() {\r\n\t\t\t\treturn this._owner._boundsSelected;\r\n\t\t\t},\r\n\r\n\t\t\tsetSelected: function(selected) {\r\n\t\t\t\tvar owner = this._owner;\r\n\t\t\t\tif (owner.setSelected) {\r\n\t\t\t\t\towner._boundsSelected = selected;\r\n\t\t\t\t\towner.setSelected(selected || owner._selectedSegmentState > 0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t);\r\n});\r\n\r\nvar Matrix = Base.extend({\r\n\t_class: 'Matrix',\r\n\r\n\tinitialize: function Matrix(arg) {\r\n\t\tvar count = arguments.length,\r\n\t\t\tok = true;\r\n\t\tif (count === 6) {\r\n\t\t\tthis.set.apply(this, arguments);\r\n\t\t} else if (count === 1) {\r\n\t\t\tif (arg instanceof Matrix) {\r\n\t\t\t\tthis.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);\r\n\t\t\t} else if (Array.isArray(arg)) {\r\n\t\t\t\tthis.set.apply(this, arg);\r\n\t\t\t} else {\r\n\t\t\t\tok = false;\r\n\t\t\t}\r\n\t\t} else if (count === 0) {\r\n\t\t\tthis.reset();\r\n\t\t} else {\r\n\t\t\tok = false;\r\n\t\t}\r\n\t\tif (!ok)\r\n\t\t\tthrow new Error('Unsupported matrix parameters');\r\n\t},\r\n\r\n\tset: function(a, c, b, d, tx, ty, _dontNotify) {\r\n\t\tthis._a = a;\r\n\t\tthis._c = c;\r\n\t\tthis._b = b;\r\n\t\tthis._d = d;\r\n\t\tthis._tx = tx;\r\n\t\tthis._ty = ty;\r\n\t\tif (!_dontNotify)\r\n\t\t\tthis._changed();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_serialize: function(options) {\r\n\t\treturn Base.serialize(this.getValues(), options);\r\n\t},\r\n\r\n\t_changed: function() {\r\n\t\tvar owner = this._owner;\r\n\t\tif (owner) {\r\n\t\t\tif (owner._applyMatrix) {\r\n\t\t\t\towner.transform(null, true);\r\n\t\t\t} else {\r\n\t\t\t\towner._changed(9);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tclone: function() {\r\n\t\treturn new Matrix(this._a, this._c, this._b, this._d,\r\n\t\t\t\tthis._tx, this._ty);\r\n\t},\r\n\r\n\tequals: function(mx) {\r\n\t\treturn mx === this || mx && this._a === mx._a && this._b === mx._b\r\n\t\t\t\t&& this._c === mx._c && this._d === mx._d\r\n\t\t\t\t&& this._tx === mx._tx && this._ty === mx._ty\r\n\t\t\t\t|| false;\r\n\t},\r\n\r\n\ttoString: function() {\r\n\t\tvar f = Formatter.instance;\r\n\t\treturn '[[' + [f.number(this._a), f.number(this._b),\r\n\t\t\t\t\tf.number(this._tx)].join(', ') + '], ['\r\n\t\t\t\t+ [f.number(this._c), f.number(this._d),\r\n\t\t\t\t\tf.number(this._ty)].join(', ') + ']]';\r\n\t},\r\n\r\n\treset: function(_dontNotify) {\r\n\t\tthis._a = this._d = 1;\r\n\t\tthis._c = this._b = this._tx = this._ty = 0;\r\n\t\tif (!_dontNotify)\r\n\t\t\tthis._changed();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tapply: function(recursively, _setApplyMatrix) {\r\n\t\tvar owner = this._owner;\r\n\t\tif (owner) {\r\n\t\t\towner.transform(null, true, Base.pick(recursively, true),\r\n\t\t\t\t\t_setApplyMatrix);\r\n\t\t\treturn this.isIdentity();\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\ttranslate: function() {\r\n\t\tvar point = Point.read(arguments),\r\n\t\t\tx = point.x,\r\n\t\t\ty = point.y;\r\n\t\tthis._tx += x * this._a + y * this._b;\r\n\t\tthis._ty += x * this._c + y * this._d;\r\n\t\tthis._changed();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tscale: function() {\r\n\t\tvar scale = Point.read(arguments),\r\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\r\n\t\tif (center)\r\n\t\t\tthis.translate(center);\r\n\t\tthis._a *= scale.x;\r\n\t\tthis._c *= scale.x;\r\n\t\tthis._b *= scale.y;\r\n\t\tthis._d *= scale.y;\r\n\t\tif (center)\r\n\t\t\tthis.translate(center.negate());\r\n\t\tthis._changed();\r\n\t\treturn this;\r\n\t},\r\n\r\n\trotate: function(angle ) {\r\n\t\tangle *= Math.PI / 180;\r\n\t\tvar center = Point.read(arguments, 1),\r\n\t\t\tx = center.x,\r\n\t\t\ty = center.y,\r\n\t\t\tcos = Math.cos(angle),\r\n\t\t\tsin = Math.sin(angle),\r\n\t\t\ttx = x - x * cos + y * sin,\r\n\t\t\tty = y - x * sin - y * cos,\r\n\t\t\ta = this._a,\r\n\t\t\tb = this._b,\r\n\t\t\tc = this._c,\r\n\t\t\td = this._d;\r\n\t\tthis._a = cos * a + sin * b;\r\n\t\tthis._b = -sin * a + cos * b;\r\n\t\tthis._c = cos * c + sin * d;\r\n\t\tthis._d = -sin * c + cos * d;\r\n\t\tthis._tx += tx * a + ty * b;\r\n\t\tthis._ty += tx * c + ty * d;\r\n\t\tthis._changed();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tshear: function() {\r\n\t\tvar shear = Point.read(arguments),\r\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\r\n\t\tif (center)\r\n\t\t\tthis.translate(center);\r\n\t\tvar a = this._a,\r\n\t\t\tc = this._c;\r\n\t\tthis._a += shear.y * this._b;\r\n\t\tthis._c += shear.y * this._d;\r\n\t\tthis._b += shear.x * a;\r\n\t\tthis._d += shear.x * c;\r\n\t\tif (center)\r\n\t\t\tthis.translate(center.negate());\r\n\t\tthis._changed();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tskew: function() {\r\n\t\tvar skew = Point.read(arguments),\r\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true }),\r\n\t\t\ttoRadians = Math.PI / 180,\r\n\t\t\tshear = new Point(Math.tan(skew.x * toRadians),\r\n\t\t\t\tMath.tan(skew.y * toRadians));\r\n\t\treturn this.shear(shear, center);\r\n\t},\r\n\r\n\tconcatenate: function(mx) {\r\n\t\tvar a1 = this._a,\r\n\t\t\tb1 = this._b,\r\n\t\t\tc1 = this._c,\r\n\t\t\td1 = this._d,\r\n\t\t\ta2 = mx._a,\r\n\t\t\tb2 = mx._b,\r\n\t\t\tc2 = mx._c,\r\n\t\t\td2 = mx._d,\r\n\t\t\ttx2 = mx._tx,\r\n\t\t\tty2 = mx._ty;\r\n\t\tthis._a = a2 * a1 + c2 * b1;\r\n\t\tthis._b = b2 * a1 + d2 * b1;\r\n\t\tthis._c = a2 * c1 + c2 * d1;\r\n\t\tthis._d = b2 * c1 + d2 * d1;\r\n\t\tthis._tx += tx2 * a1 + ty2 * b1;\r\n\t\tthis._ty += tx2 * c1 + ty2 * d1;\r\n\t\tthis._changed();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tpreConcatenate: function(mx) {\r\n\t\tvar a1 = this._a,\r\n\t\t\tb1 = this._b,\r\n\t\t\tc1 = this._c,\r\n\t\t\td1 = this._d,\r\n\t\t\ttx1 = this._tx,\r\n\t\t\tty1 = this._ty,\r\n\t\t\ta2 = mx._a,\r\n\t\t\tb2 = mx._b,\r\n\t\t\tc2 = mx._c,\r\n\t\t\td2 = mx._d,\r\n\t\t\ttx2 = mx._tx,\r\n\t\t\tty2 = mx._ty;\r\n\t\tthis._a = a2 * a1 + b2 * c1;\r\n\t\tthis._b = a2 * b1 + b2 * d1;\r\n\t\tthis._c = c2 * a1 + d2 * c1;\r\n\t\tthis._d = c2 * b1 + d2 * d1;\r\n\t\tthis._tx = a2 * tx1 + b2 * ty1 + tx2;\r\n\t\tthis._ty = c2 * tx1 + d2 * ty1 + ty2;\r\n\t\tthis._changed();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tchain: function(mx) {\r\n\t\tvar a1 = this._a,\r\n\t\t\tb1 = this._b,\r\n\t\t\tc1 = this._c,\r\n\t\t\td1 = this._d,\r\n\t\t\ttx1 = this._tx,\r\n\t\t\tty1 = this._ty,\r\n\t\t\ta2 = mx._a,\r\n\t\t\tb2 = mx._b,\r\n\t\t\tc2 = mx._c,\r\n\t\t\td2 = mx._d,\r\n\t\t\ttx2 = mx._tx,\r\n\t\t\tty2 = mx._ty;\r\n\t\treturn new Matrix(\r\n\t\t\t\ta2 * a1 + c2 * b1,\r\n\t\t\t\ta2 * c1 + c2 * d1,\r\n\t\t\t\tb2 * a1 + d2 * b1,\r\n\t\t\t\tb2 * c1 + d2 * d1,\r\n\t\t\t\ttx1 + tx2 * a1 + ty2 * b1,\r\n\t\t\t\tty1 + tx2 * c1 + ty2 * d1);\r\n\t},\r\n\r\n\tisIdentity: function() {\r\n\t\treturn this._a === 1 && this._c === 0 && this._b === 0 && this._d === 1\r\n\t\t\t\t&& this._tx === 0 && this._ty === 0;\r\n\t},\r\n\r\n\torNullIfIdentity: function() {\r\n\t\treturn this.isIdentity() ? null : this;\r\n\t},\r\n\r\n\tisInvertible: function() {\r\n\t\treturn !!this._getDeterminant();\r\n\t},\r\n\r\n\tisSingular: function() {\r\n\t\treturn !this._getDeterminant();\r\n\t},\r\n\r\n\ttransform: function( src, dst, count) {\r\n\t\treturn arguments.length < 3\r\n\t\t\t? this._transformPoint(Point.read(arguments))\r\n\t\t\t: this._transformCoordinates(src, dst, count);\r\n\t},\r\n\r\n\t_transformPoint: function(point, dest, _dontNotify) {\r\n\t\tvar x = point.x,\r\n\t\t\ty = point.y;\r\n\t\tif (!dest)\r\n\t\t\tdest = new Point();\r\n\t\treturn dest.set(\r\n\t\t\tx * this._a + y * this._b + this._tx,\r\n\t\t\tx * this._c + y * this._d + this._ty,\r\n\t\t\t_dontNotify\r\n\t\t);\r\n\t},\r\n\r\n\t_transformCoordinates: function(src, dst, count) {\r\n\t\tvar i = 0,\r\n\t\t\tj = 0,\r\n\t\t\tmax = 2 * count;\r\n\t\twhile (i < max) {\r\n\t\t\tvar x = src[i++],\r\n\t\t\t\ty = src[i++];\r\n\t\t\tdst[j++] = x * this._a + y * this._b + this._tx;\r\n\t\t\tdst[j++] = x * this._c + y * this._d + this._ty;\r\n\t\t}\r\n\t\treturn dst;\r\n\t},\r\n\r\n\t_transformCorners: function(rect) {\r\n\t\tvar x1 = rect.x,\r\n\t\t\ty1 = rect.y,\r\n\t\t\tx2 = x1 + rect.width,\r\n\t\t\ty2 = y1 + rect.height,\r\n\t\t\tcoords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];\r\n\t\treturn this._transformCoordinates(coords, coords, 4);\r\n\t},\r\n\r\n\t_transformBounds: function(bounds, dest, _dontNotify) {\r\n\t\tvar coords = this._transformCorners(bounds),\r\n\t\t\tmin = coords.slice(0, 2),\r\n\t\t\tmax = min.slice();\r\n\t\tfor (var i = 2; i < 8; i++) {\r\n\t\t\tvar val = coords[i],\r\n\t\t\t\tj = i & 1;\r\n\t\t\tif (val < min[j])\r\n\t\t\t\tmin[j] = val;\r\n\t\t\telse if (val > max[j])\r\n\t\t\t\tmax[j] = val;\r\n\t\t}\r\n\t\tif (!dest)\r\n\t\t\tdest = new Rectangle();\r\n\t\treturn dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1],\r\n\t\t\t\t_dontNotify);\r\n\t},\r\n\r\n\tinverseTransform: function() {\r\n\t\treturn this._inverseTransform(Point.read(arguments));\r\n\t},\r\n\r\n\t_getDeterminant: function() {\r\n\t\tvar det = this._a * this._d - this._b * this._c;\r\n\t\treturn isFinite(det) && !Numerical.isZero(det)\r\n\t\t\t\t&& isFinite(this._tx) && isFinite(this._ty)\r\n\t\t\t\t? det : null;\r\n\t},\r\n\r\n\t_inverseTransform: function(point, dest, _dontNotify) {\r\n\t\tvar det = this._getDeterminant();\r\n\t\tif (!det)\r\n\t\t\treturn null;\r\n\t\tvar x = point.x - this._tx,\r\n\t\t\ty = point.y - this._ty;\r\n\t\tif (!dest)\r\n\t\t\tdest = new Point();\r\n\t\treturn dest.set(\r\n\t\t\t(x * this._d - y * this._b) / det,\r\n\t\t\t(y * this._a - x * this._c) / det,\r\n\t\t\t_dontNotify\r\n\t\t);\r\n\t},\r\n\r\n\tdecompose: function() {\r\n\t\tvar a = this._a, b = this._b, c = this._c, d = this._d;\r\n\t\tif (Numerical.isZero(a * d - b * c))\r\n\t\t\treturn null;\r\n\r\n\t\tvar scaleX = Math.sqrt(a * a + b * b);\r\n\t\ta /= scaleX;\r\n\t\tb /= scaleX;\r\n\r\n\t\tvar shear = a * c + b * d;\r\n\t\tc -= a * shear;\r\n\t\td -= b * shear;\r\n\r\n\t\tvar scaleY = Math.sqrt(c * c + d * d);\r\n\t\tc /= scaleY;\r\n\t\td /= scaleY;\r\n\t\tshear /= scaleY;\r\n\r\n\t\tif (a * d < b * c) {\r\n\t\t\ta = -a;\r\n\t\t\tb = -b;\r\n\t\t\tshear = -shear;\r\n\t\t\tscaleX = -scaleX;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tscaling: new Point(scaleX, scaleY),\r\n\t\t\trotation: -Math.atan2(b, a) * 180 / Math.PI,\r\n\t\t\tshearing: shear\r\n\t\t};\r\n\t},\r\n\r\n\tgetValues: function() {\r\n\t\treturn [ this._a, this._c, this._b, this._d, this._tx, this._ty ];\r\n\t},\r\n\r\n\tgetTranslation: function() {\r\n\t\treturn new Point(this._tx, this._ty);\r\n\t},\r\n\r\n\tgetScaling: function() {\r\n\t\treturn (this.decompose() || {}).scaling;\r\n\t},\r\n\r\n\tgetRotation: function() {\r\n\t\treturn (this.decompose() || {}).rotation;\r\n\t},\r\n\r\n\tinverted: function() {\r\n\t\tvar det = this._getDeterminant();\r\n\t\treturn det && new Matrix(\r\n\t\t\t\tthis._d / det,\r\n\t\t\t\t-this._c / det,\r\n\t\t\t\t-this._b / det,\r\n\t\t\t\tthis._a / det,\r\n\t\t\t\t(this._b * this._ty - this._d * this._tx) / det,\r\n\t\t\t\t(this._c * this._tx - this._a * this._ty) / det);\r\n\t},\r\n\r\n\tshiftless: function() {\r\n\t\treturn new Matrix(this._a, this._c, this._b, this._d, 0, 0);\r\n\t},\r\n\r\n\tapplyToContext: function(ctx) {\r\n\t\tctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);\r\n\t}\r\n}, Base.each(['a', 'c', 'b', 'd', 'tx', 'ty'], function(name) {\r\n\tvar part = Base.capitalize(name),\r\n\t\tprop = '_' + name;\r\n\tthis['get' + part] = function() {\r\n\t\treturn this[prop];\r\n\t};\r\n\tthis['set' + part] = function(value) {\r\n\t\tthis[prop] = value;\r\n\t\tthis._changed();\r\n\t};\r\n}, {}));\r\n\r\nvar Line = Base.extend({\r\n\t_class: 'Line',\r\n\r\n\tinitialize: function Line(arg0, arg1, arg2, arg3, arg4) {\r\n\t\tvar asVector = false;\r\n\t\tif (arguments.length >= 4) {\r\n\t\t\tthis._px = arg0;\r\n\t\t\tthis._py = arg1;\r\n\t\t\tthis._vx = arg2;\r\n\t\t\tthis._vy = arg3;\r\n\t\t\tasVector = arg4;\r\n\t\t} else {\r\n\t\t\tthis._px = arg0.x;\r\n\t\t\tthis._py = arg0.y;\r\n\t\t\tthis._vx = arg1.x;\r\n\t\t\tthis._vy = arg1.y;\r\n\t\t\tasVector = arg2;\r\n\t\t}\r\n\t\tif (!asVector) {\r\n\t\t\tthis._vx -= this._px;\r\n\t\t\tthis._vy -= this._py;\r\n\t\t}\r\n\t},\r\n\r\n\tgetPoint: function() {\r\n\t\treturn new Point(this._px, this._py);\r\n\t},\r\n\r\n\tgetVector: function() {\r\n\t\treturn new Point(this._vx, this._vy);\r\n\t},\r\n\r\n\tgetLength: function() {\r\n\t\treturn this.getVector().getLength();\r\n\t},\r\n\r\n\tintersect: function(line, isInfinite) {\r\n\t\treturn Line.intersect(\r\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\r\n\t\t\t\tline._px, line._py, line._vx, line._vy,\r\n\t\t\t\ttrue, isInfinite);\r\n\t},\r\n\r\n\tgetSide: function(point, isInfinite) {\r\n\t\treturn Line.getSide(\r\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\r\n\t\t\t\tpoint.x, point.y, true, isInfinite);\r\n\t},\r\n\r\n\tgetDistance: function(point) {\r\n\t\treturn Math.abs(Line.getSignedDistance(\r\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\r\n\t\t\t\tpoint.x, point.y, true));\r\n\t},\r\n\r\n\tisCollinear: function(line) {\r\n\t\treturn Point.isCollinear(this._vx, this._vy, line._vx, line._vy);\r\n\t},\r\n\r\n\tisOrthogonal: function(line) {\r\n\t\treturn Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);\r\n\t},\r\n\r\n\tstatics: {\r\n\t\tintersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,\r\n\t\t\t\tisInfinite) {\r\n\t\t\tif (!asVector) {\r\n\t\t\t\tv1x -= p1x;\r\n\t\t\t\tv1y -= p1y;\r\n\t\t\t\tv2x -= p2x;\r\n\t\t\t\tv2y -= p2y;\r\n\t\t\t}\r\n\t\t\tvar cross = v1x * v2y - v1y * v2x;\r\n\t\t\tif (!Numerical.isZero(cross)) {\r\n\t\t\t\tvar dx = p1x - p2x,\r\n\t\t\t\t\tdy = p1y - p2y,\r\n\t\t\t\t\tu1 = (v2x * dy - v2y * dx) / cross,\r\n\t\t\t\t\tu2 = (v1x * dy - v1y * dx) / cross,\r\n\t\t\t\t\tepsilon = 1e-12,\r\n\t\t\t\t\tuMin = -epsilon,\r\n\t\t\t\t\tuMax = 1 + epsilon;\r\n\t\t\t\tif (isInfinite\r\n\t\t\t\t\t\t|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {\r\n\t\t\t\t\tif (!isInfinite) {\r\n\t\t\t\t\t\tu1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn new Point(\r\n\t\t\t\t\t\t\tp1x + u1 * v1x,\r\n\t\t\t\t\t\t\tp1y + u1 * v1y);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {\r\n\t\t\tif (!asVector) {\r\n\t\t\t\tvx -= px;\r\n\t\t\t\tvy -= py;\r\n\t\t\t}\r\n\t\t\tvar v2x = x - px,\r\n\t\t\t\tv2y = y - py,\r\n\t\t\t\tccw = v2x * vy - v2y * vx;\r\n\t\t\tif (ccw === 0 && !isInfinite) {\r\n\t\t\t\tccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);\r\n\t\t\t\tif (ccw >= 0 && ccw <= 1)\r\n\t\t\t\t\tccw = 0;\r\n\t\t\t}\r\n\t\t\treturn ccw < 0 ? -1 : ccw > 0 ? 1 : 0;\r\n\t\t},\r\n\r\n\t\tgetSignedDistance: function(px, py, vx, vy, x, y, asVector) {\r\n\t\t\tif (!asVector) {\r\n\t\t\t\tvx -= px;\r\n\t\t\t\tvy -= py;\r\n\t\t\t}\r\n\t\t\treturn vx === 0 ? vy > 0 ? x - px : px - x\r\n\t\t\t\t : vy === 0 ? vx < 0 ? y - py : py - y\r\n\t\t\t\t : ((x-px) * vy - (y-py) * vx) / Math.sqrt(vx * vx + vy * vy);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar Project = PaperScopeItem.extend({\r\n\t_class: 'Project',\r\n\t_list: 'projects',\r\n\t_reference: 'project',\r\n\r\n\tinitialize: function Project(element) {\r\n\t\tPaperScopeItem.call(this, true);\r\n\t\tthis.layers = [];\r\n\t\tthis._activeLayer = null;\r\n\t\tthis.symbols = [];\r\n\t\tthis._currentStyle = new Style(null, null, this);\r\n\t\tthis._view = View.create(this,\r\n\t\t\t\telement || CanvasProvider.getCanvas(1, 1));\r\n\t\tthis._selectedItems = {};\r\n\t\tthis._selectedItemCount = 0;\r\n\t\tthis._updateVersion = 0;\r\n\t},\r\n\r\n\t_serialize: function(options, dictionary) {\r\n\t\treturn Base.serialize(this.layers, options, true, dictionary);\r\n\t},\r\n\r\n\tclear: function() {\r\n\t\tfor (var i = this.layers.length - 1; i >= 0; i--)\r\n\t\t\tthis.layers[i].remove();\r\n\t\tthis.symbols = [];\r\n\t},\r\n\r\n\tisEmpty: function() {\r\n\t\treturn this.layers.length === 0;\r\n\t},\r\n\r\n\tremove: function remove() {\r\n\t\tif (!remove.base.call(this))\r\n\t\t\treturn false;\r\n\t\tif (this._view)\r\n\t\t\tthis._view.remove();\r\n\t\treturn true;\r\n\t},\r\n\r\n\tgetView: function() {\r\n\t\treturn this._view;\r\n\t},\r\n\r\n\tgetCurrentStyle: function() {\r\n\t\treturn this._currentStyle;\r\n\t},\r\n\r\n\tsetCurrentStyle: function(style) {\r\n\t\tthis._currentStyle.initialize(style);\r\n\t},\r\n\r\n\tgetIndex: function() {\r\n\t\treturn this._index;\r\n\t},\r\n\r\n\tgetOptions: function() {\r\n\t\treturn this._scope.settings;\r\n\t},\r\n\r\n\tgetActiveLayer: function() {\r\n\t\treturn this._activeLayer || new Layer({ project: this });\r\n\t},\r\n\r\n\tgetSelectedItems: function() {\r\n\t\tvar items = [];\r\n\t\tfor (var id in this._selectedItems) {\r\n\t\t\tvar item = this._selectedItems[id];\r\n\t\t\tif (item.isInserted())\r\n\t\t\t\titems.push(item);\r\n\t\t}\r\n\t\treturn items;\r\n\t},\r\n\r\n\tinsertChild: function(index, item, _preserve) {\r\n\t\tif (item instanceof Layer) {\r\n\t\t\titem._remove(false, true);\r\n\t\t\tBase.splice(this.layers, [item], index, 0);\r\n\t\t\titem._setProject(this, true);\r\n\t\t\tif (this._changes)\r\n\t\t\t\titem._changed(5);\r\n\t\t\tif (!this._activeLayer)\r\n\t\t\t\tthis._activeLayer = item;\r\n\t\t} else if (item instanceof Item) {\r\n\t\t\t(this._activeLayer\r\n\t\t\t\t|| this.insertChild(index, new Layer(Item.NO_INSERT)))\r\n\t\t\t\t\t.insertChild(index, item, _preserve);\r\n\t\t} else {\r\n\t\t\titem = null;\r\n\t\t}\r\n\t\treturn item;\r\n\t},\r\n\r\n\taddChild: function(item, _preserve) {\r\n\t\treturn this.insertChild(undefined, item, _preserve);\r\n\t},\r\n\r\n\t_updateSelection: function(item) {\r\n\t\tvar id = item._id,\r\n\t\t\tselectedItems = this._selectedItems;\r\n\t\tif (item._selected) {\r\n\t\t\tif (selectedItems[id] !== item) {\r\n\t\t\t\tthis._selectedItemCount++;\r\n\t\t\t\tselectedItems[id] = item;\r\n\t\t\t}\r\n\t\t} else if (selectedItems[id] === item) {\r\n\t\t\tthis._selectedItemCount--;\r\n\t\t\tdelete selectedItems[id];\r\n\t\t}\r\n\t},\r\n\r\n\tselectAll: function() {\r\n\t\tvar layers = this.layers;\r\n\t\tfor (var i = 0, l = layers.length; i < l; i++)\r\n\t\t\tlayers[i].setFullySelected(true);\r\n\t},\r\n\r\n\tdeselectAll: function() {\r\n\t\tvar selectedItems = this._selectedItems;\r\n\t\tfor (var i in selectedItems)\r\n\t\t\tselectedItems[i].setFullySelected(false);\r\n\t},\r\n\r\n\thitTest: function() {\r\n\t\tvar point = Point.read(arguments),\r\n\t\t\toptions = HitResult.getOptions(Base.read(arguments));\r\n\t\tfor (var i = this.layers.length - 1; i >= 0; i--) {\r\n\t\t\tvar res = this.layers[i]._hitTest(point, options);\r\n\t\t\tif (res) return res;\r\n\t\t}\r\n\t\treturn null;\r\n\t},\r\n\r\n\tgetItems: function(match) {\r\n\t\treturn Item._getItems(this.layers, match);\r\n\t},\r\n\r\n\tgetItem: function(match) {\r\n\t\treturn Item._getItems(this.layers, match, null, null, true)[0] || null;\r\n\t},\r\n\r\n\timportJSON: function(json) {\r\n\t\tthis.activate();\r\n\t\tvar layer = this._activeLayer;\r\n\t\treturn Base.importJSON(json, layer && layer.isEmpty() && layer);\r\n\t},\r\n\r\n\tdraw: function(ctx, matrix, pixelRatio) {\r\n\t\tthis._updateVersion++;\r\n\t\tctx.save();\r\n\t\tmatrix.applyToContext(ctx);\r\n\t\tvar param = new Base({\r\n\t\t\toffset: new Point(0, 0),\r\n\t\t\tpixelRatio: pixelRatio,\r\n\t\t\tviewMatrix: matrix.isIdentity() ? null : matrix,\r\n\t\t\tmatrices: [new Matrix()],\r\n\t\t\tupdateMatrix: true\r\n\t\t});\r\n\t\tfor (var i = 0, layers = this.layers, l = layers.length; i < l; i++)\r\n\t\t\tlayers[i].draw(ctx, param);\r\n\t\tctx.restore();\r\n\r\n\t\tif (this._selectedItemCount > 0) {\r\n\t\t\tctx.save();\r\n\t\t\tctx.strokeWidth = 1;\r\n\t\t\tvar items = this._selectedItems,\r\n\t\t\t\tsize = this._scope.settings.handleSize,\r\n\t\t\t\tversion = this._updateVersion;\r\n\t\t\tfor (var id in items)\r\n\t\t\t\titems[id]._drawSelection(ctx, matrix, size, items, version);\r\n\t\t\tctx.restore();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar Symbol = Base.extend({\r\n\t_class: 'Symbol',\r\n\r\n\tinitialize: function Symbol(item, dontCenter) {\r\n\t\tthis._id = UID.get();\r\n\t\tthis.project = paper.project;\r\n\t\tthis.project.symbols.push(this);\r\n\t\tif (item)\r\n\t\t\tthis.setDefinition(item, dontCenter);\r\n\t},\r\n\r\n\t_serialize: function(options, dictionary) {\r\n\t\treturn dictionary.add(this, function() {\r\n\t\t\treturn Base.serialize([this._class, this._definition],\r\n\t\t\t\t\toptions, false, dictionary);\r\n\t\t});\r\n\t},\r\n\r\n\t_changed: function(flags) {\r\n\t\tif (flags & 8) {\r\n\t\t\tItem._clearBoundsCache(this);\r\n\t\t}\r\n\t\tif (flags & 1) {\r\n\t\t\tthis.project._needsUpdate = true;\r\n\t\t}\r\n\t},\r\n\r\n\tgetDefinition: function() {\r\n\t\treturn this._definition;\r\n\t},\r\n\r\n\tsetDefinition: function(item, _dontCenter) {\r\n\t\tif (item._parentSymbol)\r\n\t\t\titem = item.clone();\r\n\t\tif (this._definition)\r\n\t\t\tthis._definition._parentSymbol = null;\r\n\t\tthis._definition = item;\r\n\t\titem.remove();\r\n\t\titem.setSelected(false);\r\n\t\tif (!_dontCenter)\r\n\t\t\titem.setPosition(new Point());\r\n\t\titem._parentSymbol = this;\r\n\t\tthis._changed(9);\r\n\t},\r\n\r\n\tplace: function(position) {\r\n\t\treturn new PlacedSymbol(this, position);\r\n\t},\r\n\r\n\tclone: function() {\r\n\t\treturn new Symbol(this._definition.clone(false));\r\n\t},\r\n\r\n\tequals: function(symbol) {\r\n\t\treturn symbol === this\r\n\t\t\t\t|| symbol && this.definition.equals(symbol.definition)\r\n\t\t\t\t|| false;\r\n\t}\r\n});\r\n\r\nvar Item = Base.extend(Emitter, {\r\n\tstatics: {\r\n\t\textend: function extend(src) {\r\n\t\t\tif (src._serializeFields)\r\n\t\t\t\tsrc._serializeFields = new Base(\r\n\t\t\t\t\t\tthis.prototype._serializeFields, src._serializeFields);\r\n\t\t\treturn extend.base.apply(this, arguments);\r\n\t\t},\r\n\r\n\t\tNO_INSERT: { insert: false }\r\n\t},\r\n\r\n\t_class: 'Item',\r\n\t_applyMatrix: true,\r\n\t_canApplyMatrix: true,\r\n\t_boundsSelected: false,\r\n\t_selectChildren: false,\r\n\t_serializeFields: {\r\n\t\tname: null,\r\n\t\tapplyMatrix: null,\r\n\t\tmatrix: new Matrix(),\r\n\t\tpivot: null,\r\n\t\tlocked: false,\r\n\t\tvisible: true,\r\n\t\tblendMode: 'normal',\r\n\t\topacity: 1,\r\n\t\tguide: false,\r\n\t\tselected: false,\r\n\t\tclipMask: false,\r\n\t\tdata: {}\r\n\t},\r\n\r\n\tinitialize: function Item() {\r\n\t},\r\n\r\n\t_initialize: function(props, point) {\r\n\t\tvar hasProps = props && Base.isPlainObject(props),\r\n\t\t\tinternal = hasProps && props.internal === true,\r\n\t\t\tmatrix = this._matrix = new Matrix(),\r\n\t\t\tproject = hasProps && props.project || paper.project;\r\n\t\tif (!internal)\r\n\t\t\tthis._id = UID.get();\r\n\t\tthis._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix;\r\n\t\tif (point)\r\n\t\t\tmatrix.translate(point);\r\n\t\tmatrix._owner = this;\r\n\t\tthis._style = new Style(project._currentStyle, this, project);\r\n\t\tif (!this._project) {\r\n\t\t\tif (internal || hasProps && props.insert === false) {\r\n\t\t\t\tthis._setProject(project);\r\n\t\t\t} else if (hasProps && props.parent) {\r\n\t\t\t\tthis.setParent(props.parent);\r\n\t\t\t} else {\r\n\t\t\t\t(project._activeLayer || new Layer()).addChild(this);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (hasProps && props !== Item.NO_INSERT)\r\n\t\t\tthis._set(props, { insert: true, project: true, parent: true },\r\n\t\t\t\t\ttrue);\r\n\t\treturn hasProps;\r\n\t},\r\n\r\n\t_events: Base.each(['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',\r\n\t\t\t'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'],\r\n\t\tfunction(name) {\r\n\t\t\tthis[name] = {\r\n\t\t\t\tinstall: function(type) {\r\n\t\t\t\t\tthis.getView()._installEvent(type);\r\n\t\t\t\t},\r\n\r\n\t\t\t\tuninstall: function(type) {\r\n\t\t\t\t\tthis.getView()._uninstallEvent(type);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}, {\r\n\t\t\tonFrame: {\r\n\t\t\t\tinstall: function() {\r\n\t\t\t\t\tthis.getView()._animateItem(this, true);\r\n\t\t\t\t},\r\n\r\n\t\t\t\tuninstall: function() {\r\n\t\t\t\t\tthis.getView()._animateItem(this, false);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tonLoad: {}\r\n\t\t}\r\n\t),\r\n\r\n\t_serialize: function(options, dictionary) {\r\n\t\tvar props = {},\r\n\t\t\tthat = this;\r\n\r\n\t\tfunction serialize(fields) {\r\n\t\t\tfor (var key in fields) {\r\n\t\t\t\tvar value = that[key];\r\n\t\t\t\tif (!Base.equals(value, key === 'leading'\r\n\t\t\t\t\t\t? fields.fontSize * 1.2 : fields[key])) {\r\n\t\t\t\t\tprops[key] = Base.serialize(value, options,\r\n\t\t\t\t\t\t\tkey !== 'data', dictionary);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tserialize(this._serializeFields);\r\n\t\tif (!(this instanceof Group))\r\n\t\t\tserialize(this._style._defaults);\r\n\t\treturn [ this._class, props ];\r\n\t},\r\n\r\n\t_changed: function(flags) {\r\n\t\tvar symbol = this._parentSymbol,\r\n\t\t\tcacheParent = this._parent || symbol,\r\n\t\t\tproject = this._project;\r\n\t\tif (flags & 8) {\r\n\t\t\tthis._bounds = this._position = this._decomposed =\r\n\t\t\t\t\tthis._globalMatrix = this._currentPath = undefined;\r\n\t\t}\r\n\t\tif (cacheParent\r\n\t\t\t\t&& (flags & 40)) {\r\n\t\t\tItem._clearBoundsCache(cacheParent);\r\n\t\t}\r\n\t\tif (flags & 2) {\r\n\t\t\tItem._clearBoundsCache(this);\r\n\t\t}\r\n\t\tif (project) {\r\n\t\t\tif (flags & 1) {\r\n\t\t\t\tproject._needsUpdate = true;\r\n\t\t\t}\r\n\t\t\tif (project._changes) {\r\n\t\t\t\tvar entry = project._changesById[this._id];\r\n\t\t\t\tif (entry) {\r\n\t\t\t\t\tentry.flags |= flags;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tentry = { item: this, flags: flags };\r\n\t\t\t\t\tproject._changesById[this._id] = entry;\r\n\t\t\t\t\tproject._changes.push(entry);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (symbol)\r\n\t\t\tsymbol._changed(flags);\r\n\t},\r\n\r\n\tset: function(props) {\r\n\t\tif (props)\r\n\t\t\tthis._set(props);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetId: function() {\r\n\t\treturn this._id;\r\n\t},\r\n\r\n\tgetName: function() {\r\n\t\treturn this._name;\r\n\t},\r\n\r\n\tsetName: function(name, unique) {\r\n\r\n\t\tif (this._name)\r\n\t\t\tthis._removeNamed();\r\n\t\tif (name === (+name) + '')\r\n\t\t\tthrow new Error(\r\n\t\t\t\t\t'Names consisting only of numbers are not supported.');\r\n\t\tvar parent = this._parent;\r\n\t\tif (name && parent) {\r\n\t\t\tvar children = parent._children,\r\n\t\t\t\tnamedChildren = parent._namedChildren,\r\n\t\t\t\torig = name,\r\n\t\t\t\ti = 1;\r\n\t\t\twhile (unique && children[name])\r\n\t\t\t\tname = orig + ' ' + (i++);\r\n\t\t\t(namedChildren[name] = namedChildren[name] || []).push(this);\r\n\t\t\tchildren[name] = this;\r\n\t\t}\r\n\t\tthis._name = name || undefined;\r\n\t\tthis._changed(128);\r\n\t},\r\n\r\n\tgetStyle: function() {\r\n\t\treturn this._style;\r\n\t},\r\n\r\n\tsetStyle: function(style) {\r\n\t\tthis.getStyle().set(style);\r\n\t}\r\n}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],\r\n\tfunction(name) {\r\n\t\tvar part = Base.capitalize(name),\r\n\t\t\tname = '_' + name;\r\n\t\tthis['get' + part] = function() {\r\n\t\t\treturn this[name];\r\n\t\t};\r\n\t\tthis['set' + part] = function(value) {\r\n\t\t\tif (value != this[name]) {\r\n\t\t\t\tthis[name] = value;\r\n\t\t\t\tthis._changed(name === '_locked'\r\n\t\t\t\t\t\t? 128 : 129);\r\n\t\t\t}\r\n\t\t};\r\n\t},\r\n{}), {\r\n\tbeans: true,\r\n\r\n\t_locked: false,\r\n\r\n\t_visible: true,\r\n\r\n\t_blendMode: 'normal',\r\n\r\n\t_opacity: 1,\r\n\r\n\t_guide: false,\r\n\r\n\tisSelected: function() {\r\n\t\tif (this._selectChildren) {\r\n\t\t\tvar children = this._children;\r\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\r\n\t\t\t\tif (children[i].isSelected())\r\n\t\t\t\t\treturn true;\r\n\t\t}\r\n\t\treturn this._selected;\r\n\t},\r\n\r\n\tsetSelected: function(selected, noChildren) {\r\n\t\tif (!noChildren && this._selectChildren) {\r\n\t\t\tvar children = this._children;\r\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\r\n\t\t\t\tchildren[i].setSelected(selected);\r\n\t\t}\r\n\t\tif ((selected = !!selected) ^ this._selected) {\r\n\t\t\tthis._selected = selected;\r\n\t\t\tthis._project._updateSelection(this);\r\n\t\t\tthis._changed(129);\r\n\t\t}\r\n\t},\r\n\r\n\t_selected: false,\r\n\r\n\tisFullySelected: function() {\r\n\t\tvar children = this._children;\r\n\t\tif (children && this._selected) {\r\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\r\n\t\t\t\tif (!children[i].isFullySelected())\r\n\t\t\t\t\treturn false;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn this._selected;\r\n\t},\r\n\r\n\tsetFullySelected: function(selected) {\r\n\t\tvar children = this._children;\r\n\t\tif (children) {\r\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\r\n\t\t\t\tchildren[i].setFullySelected(selected);\r\n\t\t}\r\n\t\tthis.setSelected(selected, true);\r\n\t},\r\n\r\n\tisClipMask: function() {\r\n\t\treturn this._clipMask;\r\n\t},\r\n\r\n\tsetClipMask: function(clipMask) {\r\n\t\tif (this._clipMask != (clipMask = !!clipMask)) {\r\n\t\t\tthis._clipMask = clipMask;\r\n\t\t\tif (clipMask) {\r\n\t\t\t\tthis.setFillColor(null);\r\n\t\t\t\tthis.setStrokeColor(null);\r\n\t\t\t}\r\n\t\t\tthis._changed(129);\r\n\t\t\tif (this._parent)\r\n\t\t\t\tthis._parent._changed(1024);\r\n\t\t}\r\n\t},\r\n\r\n\t_clipMask: false,\r\n\r\n\tgetData: function() {\r\n\t\tif (!this._data)\r\n\t\t\tthis._data = {};\r\n\t\treturn this._data;\r\n\t},\r\n\r\n\tsetData: function(data) {\r\n\t\tthis._data = data;\r\n\t},\r\n\r\n\tgetPosition: function(_dontLink) {\r\n\t\tvar position = this._position,\r\n\t\t\tctor = _dontLink ? Point : LinkedPoint;\r\n\t\tif (!position) {\r\n\t\t\tvar pivot = this._pivot;\r\n\t\t\tposition = this._position = pivot\r\n\t\t\t\t\t? this._matrix._transformPoint(pivot)\r\n\t\t\t\t\t: this.getBounds().getCenter(true);\r\n\t\t}\r\n\t\treturn new ctor(position.x, position.y, this, 'setPosition');\r\n\t},\r\n\r\n\tsetPosition: function() {\r\n\t\tthis.translate(Point.read(arguments).subtract(this.getPosition(true)));\r\n\t},\r\n\r\n\tgetPivot: function(_dontLink) {\r\n\t\tvar pivot = this._pivot;\r\n\t\tif (pivot) {\r\n\t\t\tvar ctor = _dontLink ? Point : LinkedPoint;\r\n\t\t\tpivot = new ctor(pivot.x, pivot.y, this, 'setPivot');\r\n\t\t}\r\n\t\treturn pivot;\r\n\t},\r\n\r\n\tsetPivot: function() {\r\n\t\tthis._pivot = Point.read(arguments, 0, { clone: true, readNull: true });\r\n\t\tthis._position = undefined;\r\n\t},\r\n\r\n\t_pivot: null,\r\n}, Base.each(['bounds', 'strokeBounds', 'handleBounds', 'roughBounds',\r\n\t\t'internalBounds', 'internalRoughBounds'],\r\n\tfunction(key) {\r\n\t\tvar getter = 'get' + Base.capitalize(key),\r\n\t\t\tmatch = key.match(/^internal(.*)$/),\r\n\t\t\tinternalGetter = match ? 'get' + match[1] : null;\r\n\t\tthis[getter] = function(_matrix) {\r\n\t\t\tvar boundsGetter = this._boundsGetter,\r\n\t\t\t\tname = !internalGetter && (typeof boundsGetter === 'string'\r\n\t\t\t\t\t\t? boundsGetter : boundsGetter && boundsGetter[getter])\r\n\t\t\t\t\t\t|| getter,\r\n\t\t\t\tbounds = this._getCachedBounds(name, _matrix, this,\r\n\t\t\t\t\t\tinternalGetter);\r\n\t\t\treturn key === 'bounds'\r\n\t\t\t\t\t? new LinkedRectangle(bounds.x, bounds.y, bounds.width,\r\n\t\t\t\t\t\t\tbounds.height, this, 'setBounds')\r\n\t\t\t\t\t: bounds;\r\n\t\t};\r\n\t},\r\n{\r\n\tbeans: true,\r\n\r\n\t_getBounds: function(getter, matrix, cacheItem) {\r\n\t\tvar children = this._children;\r\n\t\tif (!children || children.length == 0)\r\n\t\t\treturn new Rectangle();\r\n\t\tItem._updateBoundsCache(this, cacheItem);\r\n\t\tvar x1 = Infinity,\r\n\t\t\tx2 = -x1,\r\n\t\t\ty1 = x1,\r\n\t\t\ty2 = x2;\r\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\r\n\t\t\tvar child = children[i];\r\n\t\t\tif (child._visible && !child.isEmpty()) {\r\n\t\t\t\tvar rect = child._getCachedBounds(getter,\r\n\t\t\t\t\t\tmatrix && matrix.chain(child._matrix), cacheItem);\r\n\t\t\t\tx1 = Math.min(rect.x, x1);\r\n\t\t\t\ty1 = Math.min(rect.y, y1);\r\n\t\t\t\tx2 = Math.max(rect.x + rect.width, x2);\r\n\t\t\t\ty2 = Math.max(rect.y + rect.height, y2);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn isFinite(x1)\r\n\t\t\t\t? new Rectangle(x1, y1, x2 - x1, y2 - y1)\r\n\t\t\t\t: new Rectangle();\r\n\t},\r\n\r\n\tsetBounds: function() {\r\n\t\tvar rect = Rectangle.read(arguments),\r\n\t\t\tbounds = this.getBounds(),\r\n\t\t\tmatrix = new Matrix(),\r\n\t\t\tcenter = rect.getCenter();\r\n\t\tmatrix.translate(center);\r\n\t\tif (rect.width != bounds.width || rect.height != bounds.height) {\r\n\t\t\tmatrix.scale(\r\n\t\t\t\t\tbounds.width != 0 ? rect.width / bounds.width : 1,\r\n\t\t\t\t\tbounds.height != 0 ? rect.height / bounds.height : 1);\r\n\t\t}\r\n\t\tcenter = bounds.getCenter();\r\n\t\tmatrix.translate(-center.x, -center.y);\r\n\t\tthis.transform(matrix);\r\n\t},\r\n\r\n\t_getCachedBounds: function(getter, matrix, cacheItem, internalGetter) {\r\n\t\tmatrix = matrix && matrix.orNullIfIdentity();\r\n\t\tvar _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(),\r\n\t\t\tcache = (!matrix || matrix.equals(_matrix)) && getter;\r\n\t\tItem._updateBoundsCache(this._parent || this._parentSymbol, cacheItem);\r\n\t\tif (cache && this._bounds && this._bounds[cache])\r\n\t\t\treturn this._bounds[cache].clone();\r\n\t\tvar bounds = this._getBounds(internalGetter || getter,\r\n\t\t\t\tmatrix || _matrix, cacheItem);\r\n\t\tif (cache) {\r\n\t\t\tif (!this._bounds)\r\n\t\t\t\tthis._bounds = {};\r\n\t\t\tvar cached = this._bounds[cache] = bounds.clone();\r\n\t\t\tcached._internal = !!internalGetter;\r\n\t\t}\r\n\t\treturn bounds;\r\n\t},\r\n\r\n\tstatics: {\r\n\t\t_updateBoundsCache: function(parent, item) {\r\n\t\t\tif (parent) {\r\n\t\t\t\tvar id = item._id,\r\n\t\t\t\t\tref = parent._boundsCache = parent._boundsCache || {\r\n\t\t\t\t\t\tids: {},\r\n\t\t\t\t\t\tlist: []\r\n\t\t\t\t\t};\r\n\t\t\t\tif (!ref.ids[id]) {\r\n\t\t\t\t\tref.list.push(item);\r\n\t\t\t\t\tref.ids[id] = item;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_clearBoundsCache: function(item) {\r\n\t\t\tvar cache = item._boundsCache;\r\n\t\t\tif (cache) {\r\n\t\t\t\titem._bounds = item._position = item._boundsCache = undefined;\r\n\t\t\t\tfor (var i = 0, list = cache.list, l = list.length; i < l; i++){\r\n\t\t\t\t\tvar other = list[i];\r\n\t\t\t\t\tif (other !== item) {\r\n\t\t\t\t\t\tother._bounds = other._position = undefined;\r\n\t\t\t\t\t\tif (other._boundsCache)\r\n\t\t\t\t\t\t\tItem._clearBoundsCache(other);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n}), {\r\n\tbeans: true,\r\n\r\n\t_decompose: function() {\r\n\t\treturn this._decomposed = this._matrix.decompose();\r\n\t},\r\n\r\n\tgetRotation: function() {\r\n\t\tvar decomposed = this._decomposed || this._decompose();\r\n\t\treturn decomposed && decomposed.rotation;\r\n\t},\r\n\r\n\tsetRotation: function(rotation) {\r\n\t\tvar current = this.getRotation();\r\n\t\tif (current != null && rotation != null) {\r\n\t\t\tvar decomposed = this._decomposed;\r\n\t\t\tthis.rotate(rotation - current);\r\n\t\t\tdecomposed.rotation = rotation;\r\n\t\t\tthis._decomposed = decomposed;\r\n\t\t}\r\n\t},\r\n\r\n\tgetScaling: function(_dontLink) {\r\n\t\tvar decomposed = this._decomposed || this._decompose(),\r\n\t\t\tscaling = decomposed && decomposed.scaling,\r\n\t\t\tctor = _dontLink ? Point : LinkedPoint;\r\n\t\treturn scaling && new ctor(scaling.x, scaling.y, this, 'setScaling');\r\n\t},\r\n\r\n\tsetScaling: function() {\r\n\t\tvar current = this.getScaling();\r\n\t\tif (current) {\r\n\t\t\tvar scaling = Point.read(arguments, 0, { clone: true }),\r\n\t\t\t\tdecomposed = this._decomposed;\r\n\t\t\tthis.scale(scaling.x / current.x, scaling.y / current.y);\r\n\t\t\tdecomposed.scaling = scaling;\r\n\t\t\tthis._decomposed = decomposed;\r\n\t\t}\r\n\t},\r\n\r\n\tgetMatrix: function() {\r\n\t\treturn this._matrix;\r\n\t},\r\n\r\n\tsetMatrix: function() {\r\n\t\tvar matrix = this._matrix;\r\n\t\tmatrix.initialize.apply(matrix, arguments);\r\n\t\tif (this._applyMatrix) {\r\n\t\t\tthis.transform(null, true);\r\n\t\t} else {\r\n\t\t\tthis._changed(9);\r\n\t\t}\r\n\t},\r\n\r\n\tgetGlobalMatrix: function(_dontClone) {\r\n\t\tvar matrix = this._globalMatrix,\r\n\t\t\tupdateVersion = this._project._updateVersion;\r\n\t\tif (matrix && matrix._updateVersion !== updateVersion)\r\n\t\t\tmatrix = null;\r\n\t\tif (!matrix) {\r\n\t\t\tmatrix = this._globalMatrix = this._matrix.clone();\r\n\t\t\tvar parent = this._parent;\r\n\t\t\tif (parent)\r\n\t\t\t\tmatrix.preConcatenate(parent.getGlobalMatrix(true));\r\n\t\t\tmatrix._updateVersion = updateVersion;\r\n\t\t}\r\n\t\treturn _dontClone ? matrix : matrix.clone();\r\n\t},\r\n\r\n\tgetApplyMatrix: function() {\r\n\t\treturn this._applyMatrix;\r\n\t},\r\n\r\n\tsetApplyMatrix: function(apply) {\r\n\t\tif (this._applyMatrix = this._canApplyMatrix && !!apply)\r\n\t\t\tthis.transform(null, true);\r\n\t},\r\n\r\n\tgetTransformContent: '#getApplyMatrix',\r\n\tsetTransformContent: '#setApplyMatrix',\r\n}, {\r\n\tgetProject: function() {\r\n\t\treturn this._project;\r\n\t},\r\n\r\n\t_setProject: function(project, installEvents) {\r\n\t\tif (this._project !== project) {\r\n\t\t\tif (this._project)\r\n\t\t\t\tthis._installEvents(false);\r\n\t\t\tthis._project = project;\r\n\t\t\tvar children = this._children;\r\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++)\r\n\t\t\t\tchildren[i]._setProject(project);\r\n\t\t\tinstallEvents = true;\r\n\t\t}\r\n\t\tif (installEvents)\r\n\t\t\tthis._installEvents(true);\r\n\t},\r\n\r\n\tgetView: function() {\r\n\t\treturn this._project.getView();\r\n\t},\r\n\r\n\t_installEvents: function _installEvents(install) {\r\n\t\t_installEvents.base.call(this, install);\r\n\t\tvar children = this._children;\r\n\t\tfor (var i = 0, l = children && children.length; i < l; i++)\r\n\t\t\tchildren[i]._installEvents(install);\r\n\t},\r\n\r\n\tgetLayer: function() {\r\n\t\tvar parent = this;\r\n\t\twhile (parent = parent._parent) {\r\n\t\t\tif (parent instanceof Layer)\r\n\t\t\t\treturn parent;\r\n\t\t}\r\n\t\treturn null;\r\n\t},\r\n\r\n\tgetParent: function() {\r\n\t\treturn this._parent;\r\n\t},\r\n\r\n\tsetParent: function(item) {\r\n\t\treturn item.addChild(this);\r\n\t},\r\n\r\n\tgetChildren: function() {\r\n\t\treturn this._children;\r\n\t},\r\n\r\n\tsetChildren: function(items) {\r\n\t\tthis.removeChildren();\r\n\t\tthis.addChildren(items);\r\n\t},\r\n\r\n\tgetFirstChild: function() {\r\n\t\treturn this._children && this._children[0] || null;\r\n\t},\r\n\r\n\tgetLastChild: function() {\r\n\t\treturn this._children && this._children[this._children.length - 1]\r\n\t\t\t\t|| null;\r\n\t},\r\n\r\n\tgetNextSibling: function() {\r\n\t\treturn this._parent && this._parent._children[this._index + 1] || null;\r\n\t},\r\n\r\n\tgetPreviousSibling: function() {\r\n\t\treturn this._parent && this._parent._children[this._index - 1] || null;\r\n\t},\r\n\r\n\tgetIndex: function() {\r\n\t\treturn this._index;\r\n\t},\r\n\r\n\tequals: function(item) {\r\n\t\treturn item === this || item && this._class === item._class\r\n\t\t\t\t&& this._style.equals(item._style)\r\n\t\t\t\t&& this._matrix.equals(item._matrix)\r\n\t\t\t\t&& this._locked === item._locked\r\n\t\t\t\t&& this._visible === item._visible\r\n\t\t\t\t&& this._blendMode === item._blendMode\r\n\t\t\t\t&& this._opacity === item._opacity\r\n\t\t\t\t&& this._clipMask === item._clipMask\r\n\t\t\t\t&& this._guide === item._guide\r\n\t\t\t\t&& this._equals(item)\r\n\t\t\t\t|| false;\r\n\t},\r\n\r\n\t_equals: function(item) {\r\n\t\treturn Base.equals(this._children, item._children);\r\n\t},\r\n\r\n\tclone: function(insert) {\r\n\t\treturn this._clone(new this.constructor(Item.NO_INSERT), insert);\r\n\t},\r\n\r\n\t_clone: function(copy, insert, includeMatrix) {\r\n\t\tvar keys = ['_locked', '_visible', '_blendMode', '_opacity',\r\n\t\t\t\t'_clipMask', '_guide'],\r\n\t\t\tchildren = this._children;\r\n\t\tcopy.setStyle(this._style);\r\n\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\r\n\t\t\tcopy.addChild(children[i].clone(false), true);\r\n\t\t}\r\n\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\tvar key = keys[i];\r\n\t\t\tif (this.hasOwnProperty(key))\r\n\t\t\t\tcopy[key] = this[key];\r\n\t\t}\r\n\t\tif (includeMatrix !== false)\r\n\t\t\tcopy._matrix.initialize(this._matrix);\r\n\t\tcopy.setApplyMatrix(this._applyMatrix);\r\n\t\tcopy.setPivot(this._pivot);\r\n\t\tcopy.setSelected(this._selected);\r\n\t\tcopy._data = this._data ? Base.clone(this._data) : null;\r\n\t\tif (insert || insert === undefined)\r\n\t\t\tcopy.insertAbove(this);\r\n\t\tif (this._name)\r\n\t\t\tcopy.setName(this._name, true);\r\n\t\treturn copy;\r\n\t},\r\n\r\n\tcopyTo: function(itemOrProject) {\r\n\t\treturn itemOrProject.addChild(this.clone(false));\r\n\t},\r\n\r\n\trasterize: function(resolution) {\r\n\t\tvar bounds = this.getStrokeBounds(),\r\n\t\t\tscale = (resolution || this.getView().getResolution()) / 72,\r\n\t\t\ttopLeft = bounds.getTopLeft().floor(),\r\n\t\t\tbottomRight = bounds.getBottomRight().ceil(),\r\n\t\t\tsize = new Size(bottomRight.subtract(topLeft)),\r\n\t\t\tcanvas = CanvasProvider.getCanvas(size.multiply(scale)),\r\n\t\t\tctx = canvas.getContext('2d'),\r\n\t\t\tmatrix = new Matrix().scale(scale).translate(topLeft.negate());\r\n\t\tctx.save();\r\n\t\tmatrix.applyToContext(ctx);\r\n\t\tthis.draw(ctx, new Base({ matrices: [matrix] }));\r\n\t\tctx.restore();\r\n\t\tvar raster = new Raster(Item.NO_INSERT);\r\n\t\traster.setCanvas(canvas);\r\n\t\traster.transform(new Matrix().translate(topLeft.add(size.divide(2)))\r\n\t\t\t\t.scale(1 / scale));\r\n\t\traster.insertAbove(this);\r\n\t\treturn raster;\r\n\t},\r\n\r\n\tcontains: function() {\r\n\t\treturn !!this._contains(\r\n\t\t\t\tthis._matrix._inverseTransform(Point.read(arguments)));\r\n\t},\r\n\r\n\t_contains: function(point) {\r\n\t\tif (this._children) {\r\n\t\t\tfor (var i = this._children.length - 1; i >= 0; i--) {\r\n\t\t\t\tif (this._children[i].contains(point))\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn point.isInside(this.getInternalBounds());\r\n\t},\r\n\r\n\tisInside: function() {\r\n\t\treturn Rectangle.read(arguments).contains(this.getBounds());\r\n\t},\r\n\r\n\t_asPathItem: function() {\r\n\t\treturn new Path.Rectangle({\r\n\t\t\trectangle: this.getInternalBounds(),\r\n\t\t\tmatrix: this._matrix,\r\n\t\t\tinsert: false,\r\n\t\t});\r\n\t},\r\n\r\n\tintersects: function(item, _matrix) {\r\n\t\tif (!(item instanceof Item))\r\n\t\t\treturn false;\r\n\t\treturn this._asPathItem().getIntersections(item._asPathItem(), null,\r\n\t\t\t\t_matrix || item._matrix, true).length > 0;\r\n\t},\r\n\r\n\thitTest: function() {\r\n\t\treturn this._hitTest(\r\n\t\t\t\tPoint.read(arguments),\r\n\t\t\t\tHitResult.getOptions(Base.read(arguments)));\r\n\t},\r\n\r\n\t_hitTest: function(point, options) {\r\n\t\tif (this._locked || !this._visible || this._guide && !options.guides\r\n\t\t\t\t|| this.isEmpty())\r\n\t\t\treturn null;\r\n\r\n\t\tvar matrix = this._matrix,\r\n\t\t\tparentTotalMatrix = options._totalMatrix,\r\n\t\t\tview = this.getView(),\r\n\t\t\ttotalMatrix = options._totalMatrix = parentTotalMatrix\r\n\t\t\t\t\t? parentTotalMatrix.chain(matrix)\r\n\t\t\t\t\t: this.getGlobalMatrix().preConcatenate(view._matrix),\r\n\t\t\ttolerancePadding = options._tolerancePadding = new Size(\r\n\t\t\t\t\t\tPath._getPenPadding(1, totalMatrix.inverted())\r\n\t\t\t\t\t).multiply(\r\n\t\t\t\t\t\tMath.max(options.tolerance, 1e-6)\r\n\t\t\t\t\t);\r\n\t\tpoint = matrix._inverseTransform(point);\r\n\r\n\t\tif (!this._children && !this.getInternalRoughBounds()\r\n\t\t\t\t.expand(tolerancePadding.multiply(2))._containsPoint(point))\r\n\t\t\treturn null;\r\n\t\tvar checkSelf = !(options.guides && !this._guide\r\n\t\t\t\t|| options.selected && !this._selected\r\n\t\t\t\t|| options.type && options.type !== Base.hyphenate(this._class)\r\n\t\t\t\t|| options.class && !(this instanceof options.class)),\r\n\t\t\tthat = this,\r\n\t\t\tres;\r\n\r\n\t\tfunction checkBounds(type, part) {\r\n\t\t\tvar pt = bounds['get' + part]();\r\n\t\t\tif (point.subtract(pt).divide(tolerancePadding).length <= 1)\r\n\t\t\t\treturn new HitResult(type, that,\r\n\t\t\t\t\t\t{ name: Base.hyphenate(part), point: pt });\r\n\t\t}\r\n\r\n\t\tif (checkSelf && (options.center || options.bounds) && this._parent) {\r\n\t\t\tvar bounds = this.getInternalBounds();\r\n\t\t\tif (options.center)\r\n\t\t\t\tres = checkBounds('center', 'Center');\r\n\t\t\tif (!res && options.bounds) {\r\n\t\t\t\tvar points = [\r\n\t\t\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\r\n\t\t\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'\r\n\t\t\t\t];\r\n\t\t\t\tfor (var i = 0; i < 8 && !res; i++)\r\n\t\t\t\t\tres = checkBounds('bounds', points[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar children = !res && this._children;\r\n\t\tif (children) {\r\n\t\t\tvar opts = this._getChildHitTestOptions(options);\r\n\t\t\tfor (var i = children.length - 1; i >= 0 && !res; i--)\r\n\t\t\t\tres = children[i]._hitTest(point, opts);\r\n\t\t}\r\n\t\tif (!res && checkSelf)\r\n\t\t\tres = this._hitTestSelf(point, options);\r\n\t\tif (res && res.point)\r\n\t\t\tres.point = matrix.transform(res.point);\r\n\t\toptions._totalMatrix = parentTotalMatrix;\r\n\t\treturn res;\r\n\t},\r\n\r\n\t_getChildHitTestOptions: function(options) {\r\n\t\treturn options;\r\n\t},\r\n\r\n\t_hitTestSelf: function(point, options) {\r\n\t\tif (options.fill && this.hasFill() && this._contains(point))\r\n\t\t\treturn new HitResult('fill', this);\r\n\t},\r\n\r\n\tmatches: function(name, compare) {\r\n\t\tfunction matchObject(obj1, obj2) {\r\n\t\t\tfor (var i in obj1) {\r\n\t\t\t\tif (obj1.hasOwnProperty(i)) {\r\n\t\t\t\t\tvar val1 = obj1[i],\r\n\t\t\t\t\t\tval2 = obj2[i];\r\n\t\t\t\t\tif (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {\r\n\t\t\t\t\t\tif (!matchObject(val1, val2))\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t} else if (!Base.equals(val1, val2)) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tvar type = typeof name;\r\n\t\tif (type === 'object') {\r\n\t\t\tfor (var key in name) {\r\n\t\t\t\tif (name.hasOwnProperty(key) && !this.matches(key, name[key]))\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} else if (type === 'function') {\r\n\t\t\treturn name(this);\r\n\t\t} else {\r\n\t\t\tvar value = /^(empty|editable)$/.test(name)\r\n\t\t\t\t\t? this['is' + Base.capitalize(name)]()\r\n\t\t\t\t\t: name === 'type'\r\n\t\t\t\t\t\t? Base.hyphenate(this._class)\r\n\t\t\t\t\t\t: this[name];\r\n\t\t\tif (/^(constructor|class)$/.test(name)) {\r\n\t\t\t\tif (!(this instanceof compare))\r\n\t\t\t\t\treturn false;\r\n\t\t\t} else if (compare instanceof RegExp) {\r\n\t\t\t\tif (!compare.test(value))\r\n\t\t\t\t\treturn false;\r\n\t\t\t} else if (typeof compare === 'function') {\r\n\t\t\t\tif (!compare(value))\r\n\t\t\t\t\treturn false;\r\n\t\t\t} else if (Base.isPlainObject(compare)) {\r\n\t\t\t\tif (!matchObject(compare, value))\r\n\t\t\t\t\treturn false;\r\n\t\t\t} else if (!Base.equals(value, compare)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t},\r\n\r\n\tgetItems: function(match) {\r\n\t\treturn Item._getItems(this._children, match, this._matrix);\r\n\t},\r\n\r\n\tgetItem: function(match) {\r\n\t\treturn Item._getItems(this._children, match, this._matrix, null, true)\r\n\t\t\t\t[0] || null;\r\n\t},\r\n\r\n\tstatics: {\r\n\t\t_getItems: function _getItems(children, match, matrix, param,\r\n\t\t\t\tfirstOnly) {\r\n\t\t\tif (!param && typeof match === 'object') {\r\n\t\t\t\tvar overlapping = match.overlapping,\r\n\t\t\t\t\tinside = match.inside,\r\n\t\t\t\t\tbounds = overlapping || inside,\r\n\t\t\t\t\trect = bounds && Rectangle.read([bounds]);\r\n\t\t\t\tparam = {\r\n\t\t\t\t\titems: [],\r\n\t\t\t\t\tinside: !!inside,\r\n\t\t\t\t\toverlapping: !!overlapping,\r\n\t\t\t\t\trect: rect,\r\n\t\t\t\t\tpath: overlapping && new Path.Rectangle({\r\n\t\t\t\t\t\trectangle: rect,\r\n\t\t\t\t\t\tinsert: false\r\n\t\t\t\t\t})\r\n\t\t\t\t};\r\n\t\t\t\tif (bounds)\r\n\t\t\t\t\tmatch = Base.set({}, match,\r\n\t\t\t\t\t\t\t{ inside: true, overlapping: true });\r\n\t\t\t}\r\n\t\t\tvar items = param && param.items,\r\n\t\t\t\trect = param && param.rect;\r\n\t\t\tmatrix = rect && (matrix || new Matrix());\r\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\r\n\t\t\t\tvar child = children[i],\r\n\t\t\t\t\tchildMatrix = matrix && matrix.chain(child._matrix),\r\n\t\t\t\t\tadd = true;\r\n\t\t\t\tif (rect) {\r\n\t\t\t\t\tvar bounds = child.getBounds(childMatrix);\r\n\t\t\t\t\tif (!rect.intersects(bounds))\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tif (!(param.inside && rect.contains(bounds))\r\n\t\t\t\t\t\t\t&& !(param.overlapping && (bounds.contains(rect)\r\n\t\t\t\t\t\t\t\t|| param.path.intersects(child, childMatrix))))\r\n\t\t\t\t\t\tadd = false;\r\n\t\t\t\t}\r\n\t\t\t\tif (add && child.matches(match)) {\r\n\t\t\t\t\titems.push(child);\r\n\t\t\t\t\tif (firstOnly)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t_getItems(child._children, match,\r\n\t\t\t\t\t\tchildMatrix, param,\r\n\t\t\t\t\t\tfirstOnly);\r\n\t\t\t\tif (firstOnly && items.length > 0)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\treturn items;\r\n\t\t}\r\n\t}\r\n}, {\r\n\r\n\timportJSON: function(json) {\r\n\t\tvar res = Base.importJSON(json, this);\r\n\t\treturn res !== this\r\n\t\t\t\t? this.addChild(res)\r\n\t\t\t\t: res;\r\n\t},\r\n\r\n\taddChild: function(item, _preserve) {\r\n\t\treturn this.insertChild(undefined, item, _preserve);\r\n\t},\r\n\r\n\tinsertChild: function(index, item, _preserve) {\r\n\t\tvar res = item ? this.insertChildren(index, [item], _preserve) : null;\r\n\t\treturn res && res[0];\r\n\t},\r\n\r\n\taddChildren: function(items, _preserve) {\r\n\t\treturn this.insertChildren(this._children.length, items, _preserve);\r\n\t},\r\n\r\n\tinsertChildren: function(index, items, _preserve, _proto) {\r\n\t\tvar children = this._children;\r\n\t\tif (children && items && items.length > 0) {\r\n\t\t\titems = Array.prototype.slice.apply(items);\r\n\t\t\tfor (var i = items.length - 1; i >= 0; i--) {\r\n\t\t\t\tvar item = items[i];\r\n\t\t\t\tif (_proto && !(item instanceof _proto)) {\r\n\t\t\t\t\titems.splice(i, 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar shift = item._parent === this && item._index < index;\r\n\t\t\t\t\tif (item._remove(false, true) && shift)\r\n\t\t\t\t\t\tindex--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tBase.splice(children, items, index, 0);\r\n\t\t\tvar project = this._project,\r\n\t\t\t\tnotifySelf = project && project._changes;\r\n\t\t\tfor (var i = 0, l = items.length; i < l; i++) {\r\n\t\t\t\tvar item = items[i];\r\n\t\t\t\titem._parent = this;\r\n\t\t\t\titem._setProject(this._project, true);\r\n\t\t\t\tif (item._name)\r\n\t\t\t\t\titem.setName(item._name);\r\n\t\t\t\tif (notifySelf)\r\n\t\t\t\t\tthis._changed(5);\r\n\t\t\t}\r\n\t\t\tthis._changed(11);\r\n\t\t} else {\r\n\t\t\titems = null;\r\n\t\t}\r\n\t\treturn items;\r\n\t},\r\n\r\n\t_insertSibling: function(index, item, _preserve) {\r\n\t\treturn this._parent\r\n\t\t\t\t? this._parent.insertChild(index, item, _preserve)\r\n\t\t\t\t: null;\r\n\t},\r\n\r\n\tinsertAbove: function(item, _preserve) {\r\n\t\treturn item._insertSibling(item._index + 1, this, _preserve);\r\n\t},\r\n\r\n\tinsertBelow: function(item, _preserve) {\r\n\t\treturn item._insertSibling(item._index, this, _preserve);\r\n\t},\r\n\r\n\tsendToBack: function() {\r\n\t\treturn (this._parent || this instanceof Layer && this._project)\r\n\t\t\t\t.insertChild(0, this);\r\n\t},\r\n\r\n\tbringToFront: function() {\r\n\t\treturn (this._parent || this instanceof Layer && this._project)\r\n\t\t\t\t.addChild(this);\r\n\t},\r\n\r\n\tappendTop: '#addChild',\r\n\r\n\tappendBottom: function(item) {\r\n\t\treturn this.insertChild(0, item);\r\n\t},\r\n\r\n\tmoveAbove: '#insertAbove',\r\n\r\n\tmoveBelow: '#insertBelow',\r\n\r\n\treduce: function() {\r\n\t\tif (this._children && this._children.length === 1) {\r\n\t\t\tvar child = this._children[0].reduce();\r\n\t\t\tchild.insertAbove(this);\r\n\t\t\tchild.setStyle(this._style);\r\n\t\t\tthis.remove();\r\n\t\t\treturn child;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_removeNamed: function() {\r\n\t\tvar parent = this._parent;\r\n\t\tif (parent) {\r\n\t\t\tvar children = parent._children,\r\n\t\t\t\tnamedChildren = parent._namedChildren,\r\n\t\t\t\tname = this._name,\r\n\t\t\t\tnamedArray = namedChildren[name],\r\n\t\t\t\tindex = namedArray ? namedArray.indexOf(this) : -1;\r\n\t\t\tif (index !== -1) {\r\n\t\t\t\tif (children[name] == this)\r\n\t\t\t\t\tdelete children[name];\r\n\t\t\t\tnamedArray.splice(index, 1);\r\n\t\t\t\tif (namedArray.length) {\r\n\t\t\t\t\tchildren[name] = namedArray[namedArray.length - 1];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdelete namedChildren[name];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_remove: function(notifySelf, notifyParent) {\r\n\t\tvar parent = this._parent;\r\n\t\tif (parent) {\r\n\t\t\tif (this._name)\r\n\t\t\t\tthis._removeNamed();\r\n\t\t\tif (this._index != null)\r\n\t\t\t\tBase.splice(parent._children, null, this._index, 1);\r\n\t\t\tthis._installEvents(false);\r\n\t\t\tif (notifySelf) {\r\n\t\t\t\tvar project = this._project;\r\n\t\t\t\tif (project && project._changes)\r\n\t\t\t\t\tthis._changed(5);\r\n\t\t\t}\r\n\t\t\tif (notifyParent)\r\n\t\t\t\tparent._changed(11);\r\n\t\t\tthis._parent = null;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tremove: function() {\r\n\t\treturn this._remove(true, true);\r\n\t},\r\n\r\n\treplaceWith: function(item) {\r\n\t\tvar ok = item && item.insertBelow(this);\r\n\t\tif (ok)\r\n\t\t\tthis.remove();\r\n\t\treturn ok;\r\n\t},\r\n\r\n\tremoveChildren: function(from, to) {\r\n\t\tif (!this._children)\r\n\t\t\treturn null;\r\n\t\tfrom = from || 0;\r\n\t\tto = Base.pick(to, this._children.length);\r\n\t\tvar removed = Base.splice(this._children, null, from, to - from);\r\n\t\tfor (var i = removed.length - 1; i >= 0; i--) {\r\n\t\t\tremoved[i]._remove(true, false);\r\n\t\t}\r\n\t\tif (removed.length > 0)\r\n\t\t\tthis._changed(11);\r\n\t\treturn removed;\r\n\t},\r\n\r\n\tclear: '#removeChildren',\r\n\r\n\treverseChildren: function() {\r\n\t\tif (this._children) {\r\n\t\t\tthis._children.reverse();\r\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++)\r\n\t\t\t\tthis._children[i]._index = i;\r\n\t\t\tthis._changed(11);\r\n\t\t}\r\n\t},\r\n\r\n\tisEmpty: function() {\r\n\t\treturn !this._children || this._children.length === 0;\r\n\t},\r\n\r\n\tisEditable: function() {\r\n\t\tvar item = this;\r\n\t\twhile (item) {\r\n\t\t\tif (!item._visible || item._locked)\r\n\t\t\t\treturn false;\r\n\t\t\titem = item._parent;\r\n\t\t}\r\n\t\treturn true;\r\n\t},\r\n\r\n\thasFill: function() {\r\n\t\treturn this.getStyle().hasFill();\r\n\t},\r\n\r\n\thasStroke: function() {\r\n\t\treturn this.getStyle().hasStroke();\r\n\t},\r\n\r\n\thasShadow: function() {\r\n\t\treturn this.getStyle().hasShadow();\r\n\t},\r\n\r\n\t_getOrder: function(item) {\r\n\t\tfunction getList(item) {\r\n\t\t\tvar list = [];\r\n\t\t\tdo {\r\n\t\t\t\tlist.unshift(item);\r\n\t\t\t} while (item = item._parent);\r\n\t\t\treturn list;\r\n\t\t}\r\n\t\tvar list1 = getList(this),\r\n\t\t\tlist2 = getList(item);\r\n\t\tfor (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {\r\n\t\t\tif (list1[i] != list2[i]) {\r\n\t\t\t\treturn list1[i]._index < list2[i]._index ? 1 : -1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0;\r\n\t},\r\n\r\n\thasChildren: function() {\r\n\t\treturn this._children && this._children.length > 0;\r\n\t},\r\n\r\n\tisInserted: function() {\r\n\t\treturn this._parent ? this._parent.isInserted() : false;\r\n\t},\r\n\r\n\tisAbove: function(item) {\r\n\t\treturn this._getOrder(item) === -1;\r\n\t},\r\n\r\n\tisBelow: function(item) {\r\n\t\treturn this._getOrder(item) === 1;\r\n\t},\r\n\r\n\tisParent: function(item) {\r\n\t\treturn this._parent === item;\r\n\t},\r\n\r\n\tisChild: function(item) {\r\n\t\treturn item && item._parent === this;\r\n\t},\r\n\r\n\tisDescendant: function(item) {\r\n\t\tvar parent = this;\r\n\t\twhile (parent = parent._parent) {\r\n\t\t\tif (parent == item)\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tisAncestor: function(item) {\r\n\t\treturn item ? item.isDescendant(this) : false;\r\n\t},\r\n\r\n\tisSibling: function(item) {\r\n\t\treturn this._parent === item._parent;\r\n\t},\r\n\r\n\tisGroupedWith: function(item) {\r\n\t\tvar parent = this._parent;\r\n\t\twhile (parent) {\r\n\t\t\tif (parent._parent\r\n\t\t\t\t&& /^(Group|Layer|CompoundPath)$/.test(parent._class)\r\n\t\t\t\t&& item.isDescendant(parent))\r\n\t\t\t\t\treturn true;\r\n\t\t\tparent = parent._parent;\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\ttranslate: function() {\r\n\t\tvar mx = new Matrix();\r\n\t\treturn this.transform(mx.translate.apply(mx, arguments));\r\n\t},\r\n\r\n\trotate: function(angle ) {\r\n\t\treturn this.transform(new Matrix().rotate(angle,\r\n\t\t\t\tPoint.read(arguments, 1, { readNull: true })\r\n\t\t\t\t\t|| this.getPosition(true)));\r\n\t}\r\n}, Base.each(['scale', 'shear', 'skew'], function(name) {\r\n\tthis[name] = function() {\r\n\t\tvar point = Point.read(arguments),\r\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\r\n\t\treturn this.transform(new Matrix()[name](point,\r\n\t\t\t\tcenter || this.getPosition(true)));\r\n\t};\r\n}, {\r\n\r\n}), {\r\n\ttransform: function(matrix, _applyMatrix, _applyRecursively,\r\n\t\t\t_setApplyMatrix) {\r\n\t\tif (matrix && matrix.isIdentity())\r\n\t\t\tmatrix = null;\r\n\t\tvar _matrix = this._matrix,\r\n\t\t\tapplyMatrix = (_applyMatrix || this._applyMatrix)\r\n\t\t\t\t\t&& ((!_matrix.isIdentity() || matrix)\r\n\t\t\t\t\t\t|| _applyMatrix && _applyRecursively && this._children);\r\n\t\tif (!matrix && !applyMatrix)\r\n\t\t\treturn this;\r\n\t\tif (matrix)\r\n\t\t\t_matrix.preConcatenate(matrix);\r\n\t\tif (applyMatrix = applyMatrix && this._transformContent(_matrix,\r\n\t\t\t\t\t_applyRecursively, _setApplyMatrix)) {\r\n\t\t\tvar pivot = this._pivot,\r\n\t\t\t\tstyle = this._style,\r\n\t\t\t\tfillColor = style.getFillColor(true),\r\n\t\t\t\tstrokeColor = style.getStrokeColor(true);\r\n\t\t\tif (pivot)\r\n\t\t\t\t_matrix._transformPoint(pivot, pivot, true);\r\n\t\t\tif (fillColor)\r\n\t\t\t\tfillColor.transform(_matrix);\r\n\t\t\tif (strokeColor)\r\n\t\t\t\tstrokeColor.transform(_matrix);\r\n\t\t\t_matrix.reset(true);\r\n\t\t\tif (_setApplyMatrix && this._canApplyMatrix)\r\n\t\t\t\tthis._applyMatrix = true;\r\n\t\t}\r\n\t\tvar bounds = this._bounds,\r\n\t\t\tposition = this._position;\r\n\t\tthis._changed(9);\r\n\t\tvar decomp = bounds && matrix && matrix.decompose();\r\n\t\tif (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {\r\n\t\t\tfor (var key in bounds) {\r\n\t\t\t\tvar rect = bounds[key];\r\n\t\t\t\tif (applyMatrix || !rect._internal)\r\n\t\t\t\t\tmatrix._transformBounds(rect, rect);\r\n\t\t\t}\r\n\t\t\tvar getter = this._boundsGetter,\r\n\t\t\t\trect = bounds[getter && getter.getBounds || getter || 'getBounds'];\r\n\t\t\tif (rect)\r\n\t\t\t\tthis._position = rect.getCenter(true);\r\n\t\t\tthis._bounds = bounds;\r\n\t\t} else if (matrix && position) {\r\n\t\t\tthis._position = matrix._transformPoint(position, position);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_transformContent: function(matrix, applyRecursively, setApplyMatrix) {\r\n\t\tvar children = this._children;\r\n\t\tif (children) {\r\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\r\n\t\t\t\tchildren[i].transform(matrix, true, applyRecursively,\r\n\t\t\t\t\t\tsetApplyMatrix);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t},\r\n\r\n\tglobalToLocal: function() {\r\n\t\treturn this.getGlobalMatrix(true)._inverseTransform(\r\n\t\t\t\tPoint.read(arguments));\r\n\t},\r\n\r\n\tlocalToGlobal: function() {\r\n\t\treturn this.getGlobalMatrix(true)._transformPoint(\r\n\t\t\t\tPoint.read(arguments));\r\n\t},\r\n\r\n\tparentToLocal: function() {\r\n\t\treturn this._matrix._inverseTransform(Point.read(arguments));\r\n\t},\r\n\r\n\tlocalToParent: function() {\r\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\r\n\t},\r\n\r\n\tfitBounds: function(rectangle, fill) {\r\n\t\trectangle = Rectangle.read(arguments);\r\n\t\tvar bounds = this.getBounds(),\r\n\t\t\titemRatio = bounds.height / bounds.width,\r\n\t\t\trectRatio = rectangle.height / rectangle.width,\r\n\t\t\tscale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)\r\n\t\t\t\t\t? rectangle.width / bounds.width\r\n\t\t\t\t\t: rectangle.height / bounds.height,\r\n\t\t\tnewBounds = new Rectangle(new Point(),\r\n\t\t\t\t\tnew Size(bounds.width * scale, bounds.height * scale));\r\n\t\tnewBounds.setCenter(rectangle.getCenter());\r\n\t\tthis.setBounds(newBounds);\r\n\t},\r\n\r\n\t_setStyles: function(ctx) {\r\n\t\tvar style = this._style,\r\n\t\t\tfillColor = style.getFillColor(),\r\n\t\t\tstrokeColor = style.getStrokeColor(),\r\n\t\t\tshadowColor = style.getShadowColor();\r\n\t\tif (fillColor)\r\n\t\t\tctx.fillStyle = fillColor.toCanvasStyle(ctx);\r\n\t\tif (strokeColor) {\r\n\t\t\tvar strokeWidth = style.getStrokeWidth();\r\n\t\t\tif (strokeWidth > 0) {\r\n\t\t\t\tctx.strokeStyle = strokeColor.toCanvasStyle(ctx);\r\n\t\t\t\tctx.lineWidth = strokeWidth;\r\n\t\t\t\tvar strokeJoin = style.getStrokeJoin(),\r\n\t\t\t\t\tstrokeCap = style.getStrokeCap(),\r\n\t\t\t\t\tmiterLimit = style.getMiterLimit();\r\n\t\t\t\tif (strokeJoin)\r\n\t\t\t\t\tctx.lineJoin = strokeJoin;\r\n\t\t\t\tif (strokeCap)\r\n\t\t\t\t\tctx.lineCap = strokeCap;\r\n\t\t\t\tif (miterLimit)\r\n\t\t\t\t\tctx.miterLimit = miterLimit;\r\n\t\t\t\tif (paper.support.nativeDash) {\r\n\t\t\t\t\tvar dashArray = style.getDashArray(),\r\n\t\t\t\t\t\tdashOffset = style.getDashOffset();\r\n\t\t\t\t\tif (dashArray && dashArray.length) {\r\n\t\t\t\t\t\tif ('setLineDash' in ctx) {\r\n\t\t\t\t\t\t\tctx.setLineDash(dashArray);\r\n\t\t\t\t\t\t\tctx.lineDashOffset = dashOffset;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tctx.mozDash = dashArray;\r\n\t\t\t\t\t\t\tctx.mozDashOffset = dashOffset;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (shadowColor) {\r\n\t\t\tvar shadowBlur = style.getShadowBlur();\r\n\t\t\tif (shadowBlur > 0) {\r\n\t\t\t\tctx.shadowColor = shadowColor.toCanvasStyle(ctx);\r\n\t\t\t\tctx.shadowBlur = shadowBlur;\r\n\t\t\t\tvar offset = this.getShadowOffset();\r\n\t\t\t\tctx.shadowOffsetX = offset.x;\r\n\t\t\t\tctx.shadowOffsetY = offset.y;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tdraw: function(ctx, param, parentStrokeMatrix) {\r\n\t\tvar updateVersion = this._updateVersion = this._project._updateVersion;\r\n\t\tif (!this._visible || this._opacity === 0)\r\n\t\t\treturn;\r\n\t\tvar matrices = param.matrices,\r\n\t\t\tviewMatrix = param.viewMatrix,\r\n\t\t\tmatrix = this._matrix,\r\n\t\t\tglobalMatrix = matrices[matrices.length - 1].chain(matrix);\r\n\t\tif (!globalMatrix.isInvertible())\r\n\t\t\treturn;\r\n\r\n\t\tfunction getViewMatrix(matrix) {\r\n\t\t\treturn viewMatrix ? viewMatrix.chain(matrix) : matrix;\r\n\t\t}\r\n\r\n\t\tmatrices.push(globalMatrix);\r\n\t\tif (param.updateMatrix) {\r\n\t\t\tglobalMatrix._updateVersion = updateVersion;\r\n\t\t\tthis._globalMatrix = globalMatrix;\r\n\t\t}\r\n\r\n\t\tvar blendMode = this._blendMode,\r\n\t\t\topacity = this._opacity,\r\n\t\t\tnormalBlend = blendMode === 'normal',\r\n\t\t\tnativeBlend = BlendMode.nativeModes[blendMode],\r\n\t\t\tdirect = normalBlend && opacity === 1\r\n\t\t\t\t\t|| param.dontStart\r\n\t\t\t\t\t|| param.clip\r\n\t\t\t\t\t|| (nativeBlend || normalBlend && opacity < 1)\r\n\t\t\t\t\t\t&& this._canComposite(),\r\n\t\t\tpixelRatio = param.pixelRatio || 1,\r\n\t\t\tmainCtx, itemOffset, prevOffset;\r\n\t\tif (!direct) {\r\n\t\t\tvar bounds = this.getStrokeBounds(getViewMatrix(globalMatrix));\r\n\t\t\tif (!bounds.width || !bounds.height)\r\n\t\t\t\treturn;\r\n\t\t\tprevOffset = param.offset;\r\n\t\t\titemOffset = param.offset = bounds.getTopLeft().floor();\r\n\t\t\tmainCtx = ctx;\r\n\t\t\tctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)\r\n\t\t\t\t\t.multiply(pixelRatio));\r\n\t\t\tif (pixelRatio !== 1)\r\n\t\t\t\tctx.scale(pixelRatio, pixelRatio);\r\n\t\t}\r\n\t\tctx.save();\r\n\t\tvar strokeMatrix = parentStrokeMatrix\r\n\t\t\t\t? parentStrokeMatrix.chain(matrix)\r\n\t\t\t\t: !this.getStrokeScaling(true) && getViewMatrix(globalMatrix),\r\n\t\t\tclip = !direct && param.clipItem,\r\n\t\t\ttransform = !strokeMatrix || clip;\r\n\t\tif (direct) {\r\n\t\t\tctx.globalAlpha = opacity;\r\n\t\t\tif (nativeBlend)\r\n\t\t\t\tctx.globalCompositeOperation = blendMode;\r\n\t\t} else if (transform) {\r\n\t\t\tctx.translate(-itemOffset.x, -itemOffset.y);\r\n\t\t}\r\n\t\tif (transform)\r\n\t\t\t(direct ? matrix : getViewMatrix(globalMatrix)).applyToContext(ctx);\r\n\t\tif (clip)\r\n\t\t\tparam.clipItem.draw(ctx, param.extend({ clip: true }));\r\n\t\tif (strokeMatrix) {\r\n\t\t\tctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\r\n\t\t\tvar offset = param.offset;\r\n\t\t\tif (offset)\r\n\t\t\t\tctx.translate(-offset.x, -offset.y);\r\n\t\t}\r\n\t\tthis._draw(ctx, param, strokeMatrix);\r\n\t\tctx.restore();\r\n\t\tmatrices.pop();\r\n\t\tif (param.clip && !param.dontFinish)\r\n\t\t\tctx.clip();\r\n\t\tif (!direct) {\r\n\t\t\tBlendMode.process(blendMode, ctx, mainCtx, opacity,\r\n\t\t\t\t\titemOffset.subtract(prevOffset).multiply(pixelRatio));\r\n\t\t\tCanvasProvider.release(ctx);\r\n\t\t\tparam.offset = prevOffset;\r\n\t\t}\r\n\t},\r\n\r\n\t_isUpdated: function(updateVersion) {\r\n\t\tvar parent = this._parent;\r\n\t\tif (parent instanceof CompoundPath)\r\n\t\t\treturn parent._isUpdated(updateVersion);\r\n\t\tvar updated = this._updateVersion === updateVersion;\r\n\t\tif (!updated && parent && parent._visible\r\n\t\t\t\t&& parent._isUpdated(updateVersion)) {\r\n\t\t\tthis._updateVersion = updateVersion;\r\n\t\t\tupdated = true;\r\n\t\t}\r\n\t\treturn updated;\r\n\t},\r\n\r\n\t_drawSelection: function(ctx, matrix, size, selectedItems, updateVersion) {\r\n\t\tif ((this._drawSelected || this._boundsSelected)\r\n\t\t\t\t&& this._isUpdated(updateVersion)) {\r\n\t\t\tvar color = this.getSelectedColor(true)\r\n\t\t\t\t\t|| this.getLayer().getSelectedColor(true),\r\n\t\t\t\tmx = matrix.chain(this.getGlobalMatrix(true));\r\n\t\t\tctx.strokeStyle = ctx.fillStyle = color\r\n\t\t\t\t\t? color.toCanvasStyle(ctx) : '#009dec';\r\n\t\t\tif (this._drawSelected)\r\n\t\t\t\tthis._drawSelected(ctx, mx, selectedItems);\r\n\t\t\tif (this._boundsSelected) {\r\n\t\t\t\tvar half = size / 2,\r\n\t\t\t\t\tcoords = mx._transformCorners(this.getInternalBounds());\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tfor (var i = 0; i < 8; i++)\r\n\t\t\t\t\tctx[i === 0 ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);\r\n\t\t\t\tctx.closePath();\r\n\t\t\t\tctx.stroke();\r\n\t\t\t\tfor (var i = 0; i < 8; i++)\r\n\t\t\t\t\tctx.fillRect(coords[i] - half, coords[++i] - half,\r\n\t\t\t\t\t\t\tsize, size);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_canComposite: function() {\r\n\t\treturn false;\r\n\t}\r\n}, Base.each(['down', 'drag', 'up', 'move'], function(name) {\r\n\tthis['removeOn' + Base.capitalize(name)] = function() {\r\n\t\tvar hash = {};\r\n\t\thash[name] = true;\r\n\t\treturn this.removeOn(hash);\r\n\t};\r\n}, {\r\n\r\n\tremoveOn: function(obj) {\r\n\t\tfor (var name in obj) {\r\n\t\t\tif (obj[name]) {\r\n\t\t\t\tvar key = 'mouse' + name,\r\n\t\t\t\t\tproject = this._project,\r\n\t\t\t\t\tsets = project._removeSets = project._removeSets || {};\r\n\t\t\t\tsets[key] = sets[key] || {};\r\n\t\t\t\tsets[key][this._id] = this;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n}));\r\n\r\nvar Group = Item.extend({\r\n\t_class: 'Group',\r\n\t_selectChildren: true,\r\n\t_serializeFields: {\r\n\t\tchildren: []\r\n\t},\r\n\r\n\tinitialize: function Group(arg) {\r\n\t\tthis._children = [];\r\n\t\tthis._namedChildren = {};\r\n\t\tif (!this._initialize(arg))\r\n\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\r\n\t},\r\n\r\n\t_changed: function _changed(flags) {\r\n\t\t_changed.base.call(this, flags);\r\n\t\tif (flags & 1026) {\r\n\t\t\tthis._clipItem = undefined;\r\n\t\t}\r\n\t},\r\n\r\n\t_getClipItem: function() {\r\n\t\tvar clipItem = this._clipItem;\r\n\t\tif (clipItem === undefined) {\r\n\t\t\tclipItem = null;\r\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++) {\r\n\t\t\t\tvar child = this._children[i];\r\n\t\t\t\tif (child._clipMask) {\r\n\t\t\t\t\tclipItem = child;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis._clipItem = clipItem;\r\n\t\t}\r\n\t\treturn clipItem;\r\n\t},\r\n\r\n\tisClipped: function() {\r\n\t\treturn !!this._getClipItem();\r\n\t},\r\n\r\n\tsetClipped: function(clipped) {\r\n\t\tvar child = this.getFirstChild();\r\n\t\tif (child)\r\n\t\t\tchild.setClipMask(clipped);\r\n\t},\r\n\r\n\t_draw: function(ctx, param) {\r\n\t\tvar clip = param.clip,\r\n\t\t\tclipItem = !clip && this._getClipItem(),\r\n\t\t\tdraw = true;\r\n\t\tparam = param.extend({ clipItem: clipItem, clip: false });\r\n\t\tif (clip) {\r\n\t\t\tif (this._currentPath) {\r\n\t\t\t\tctx.currentPath = this._currentPath;\r\n\t\t\t\tdraw = false;\r\n\t\t\t} else {\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tparam.dontStart = param.dontFinish = true;\r\n\t\t\t}\r\n\t\t} else if (clipItem) {\r\n\t\t\tclipItem.draw(ctx, param.extend({ clip: true }));\r\n\t\t}\r\n\t\tif (draw) {\r\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++) {\r\n\t\t\t\tvar item = this._children[i];\r\n\t\t\t\tif (item !== clipItem)\r\n\t\t\t\t\titem.draw(ctx, param);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (clip) {\r\n\t\t\tthis._currentPath = ctx.currentPath;\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar Layer = Group.extend({\r\n\t_class: 'Layer',\r\n\r\n\tinitialize: function Layer(arg) {\r\n\t\tvar props = Base.isPlainObject(arg)\r\n\t\t\t\t? new Base(arg)\r\n\t\t\t\t: { children: Array.isArray(arg) ? arg : arguments },\r\n\t\t\tinsert = props.insert;\r\n\t\tprops.insert = false;\r\n\t\tGroup.call(this, props);\r\n\t\tif (insert || insert === undefined) {\r\n\t\t\tthis._project.addChild(this);\r\n\t\t\tthis.activate();\r\n\t\t}\r\n\t},\r\n\r\n\t_remove: function _remove(notifySelf, notifyParent) {\r\n\t\tif (this._parent)\r\n\t\t\treturn _remove.base.call(this, notifySelf, notifyParent);\r\n\t\tif (this._index != null) {\r\n\t\t\tvar project = this._project;\r\n\t\t\tif (project._activeLayer === this)\r\n\t\t\t\tproject._activeLayer = this.getNextSibling()\r\n\t\t\t\t\t\t|| this.getPreviousSibling();\r\n\t\t\tBase.splice(project.layers, null, this._index, 1);\r\n\t\t\tthis._installEvents(false);\r\n\t\t\tif (notifySelf && project._changes)\r\n\t\t\t\tthis._changed(5);\r\n\t\t\tif (notifyParent) {\r\n\t\t\t\tproject._needsUpdate = true;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tgetNextSibling: function getNextSibling() {\r\n\t\treturn this._parent ? getNextSibling.base.call(this)\r\n\t\t\t\t: this._project.layers[this._index + 1] || null;\r\n\t},\r\n\r\n\tgetPreviousSibling: function getPreviousSibling() {\r\n\t\treturn this._parent ? getPreviousSibling.base.call(this)\r\n\t\t\t\t: this._project.layers[this._index - 1] || null;\r\n\t},\r\n\r\n\tisInserted: function isInserted() {\r\n\t\treturn this._parent ? isInserted.base.call(this) : this._index != null;\r\n\t},\r\n\r\n\tactivate: function() {\r\n\t\tthis._project._activeLayer = this;\r\n\t},\r\n\r\n\t_insertSibling: function _insertSibling(index, item, _preserve) {\r\n\t\treturn !this._parent\r\n\t\t\t\t? this._project.insertChild(index, item, _preserve)\r\n\t\t\t\t: _insertSibling.base.call(this, index, item, _preserve);\r\n\t}\r\n});\r\n\r\nvar Shape = Item.extend({\r\n\t_class: 'Shape',\r\n\t_applyMatrix: false,\r\n\t_canApplyMatrix: false,\r\n\t_boundsSelected: true,\r\n\t_serializeFields: {\r\n\t\ttype: null,\r\n\t\tsize: null,\r\n\t\tradius: null\r\n\t},\r\n\r\n\tinitialize: function Shape(props) {\r\n\t\tthis._initialize(props);\r\n\t},\r\n\r\n\t_equals: function(item) {\r\n\t\treturn this._type === item._type\r\n\t\t\t&& this._size.equals(item._size)\r\n\t\t\t&& Base.equals(this._radius, item._radius);\r\n\t},\r\n\r\n\tclone: function(insert) {\r\n\t\tvar copy = new Shape(Item.NO_INSERT);\r\n\t\tcopy.setType(this._type);\r\n\t\tcopy.setSize(this._size);\r\n\t\tcopy.setRadius(this._radius);\r\n\t\treturn this._clone(copy, insert);\r\n\t},\r\n\r\n\tgetType: function() {\r\n\t\treturn this._type;\r\n\t},\r\n\r\n\tsetType: function(type) {\r\n\t\tthis._type = type;\r\n\t},\r\n\r\n\tgetShape: '#getType',\r\n\tsetShape: '#setType',\r\n\r\n\tgetSize: function() {\r\n\t\tvar size = this._size;\r\n\t\treturn new LinkedSize(size.width, size.height, this, 'setSize');\r\n\t},\r\n\r\n\tsetSize: function() {\r\n\t\tvar size = Size.read(arguments);\r\n\t\tif (!this._size) {\r\n\t\t\tthis._size = size.clone();\r\n\t\t} else if (!this._size.equals(size)) {\r\n\t\t\tvar type = this._type,\r\n\t\t\t\twidth = size.width,\r\n\t\t\t\theight = size.height;\r\n\t\t\tif (type === 'rectangle') {\r\n\t\t\t\tvar radius = Size.min(this._radius, size.divide(2));\r\n\t\t\t\tthis._radius.set(radius.width, radius.height);\r\n\t\t\t} else if (type === 'circle') {\r\n\t\t\t\twidth = height = (width + height) / 2;\r\n\t\t\t\tthis._radius = width / 2;\r\n\t\t\t} else if (type === 'ellipse') {\r\n\t\t\t\tthis._radius.set(width / 2, height / 2);\r\n\t\t\t}\r\n\t\t\tthis._size.set(width, height);\r\n\t\t\tthis._changed(9);\r\n\t\t}\r\n\t},\r\n\r\n\tgetRadius: function() {\r\n\t\tvar rad = this._radius;\r\n\t\treturn this._type === 'circle'\r\n\t\t\t\t? rad\r\n\t\t\t\t: new LinkedSize(rad.width, rad.height, this, 'setRadius');\r\n\t},\r\n\r\n\tsetRadius: function(radius) {\r\n\t\tvar type = this._type;\r\n\t\tif (type === 'circle') {\r\n\t\t\tif (radius === this._radius)\r\n\t\t\t\treturn;\r\n\t\t\tvar size = radius * 2;\r\n\t\t\tthis._radius = radius;\r\n\t\t\tthis._size.set(size, size);\r\n\t\t} else {\r\n\t\t\tradius = Size.read(arguments);\r\n\t\t\tif (!this._radius) {\r\n\t\t\t\tthis._radius = radius.clone();\r\n\t\t\t} else {\r\n\t\t\t\tif (this._radius.equals(radius))\r\n\t\t\t\t\treturn;\r\n\t\t\t\tthis._radius.set(radius.width, radius.height);\r\n\t\t\t\tif (type === 'rectangle') {\r\n\t\t\t\t\tvar size = Size.max(this._size, radius.multiply(2));\r\n\t\t\t\t\tthis._size.set(size.width, size.height);\r\n\t\t\t\t} else if (type === 'ellipse') {\r\n\t\t\t\t\tthis._size.set(radius.width * 2, radius.height * 2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._changed(9);\r\n\t},\r\n\r\n\tisEmpty: function() {\r\n\t\treturn false;\r\n\t},\r\n\r\n\ttoPath: function(insert) {\r\n\t\tvar path = this._clone(new Path[Base.capitalize(this._type)]({\r\n\t\t\tcenter: new Point(),\r\n\t\t\tsize: this._size,\r\n\t\t\tradius: this._radius,\r\n\t\t\tinsert: false\r\n\t\t}), insert);\r\n\t\tif (paper.settings.applyMatrix)\r\n\t\t\tpath.setApplyMatrix(true);\r\n\t\treturn path;\r\n\t},\r\n\r\n\t_draw: function(ctx, param, strokeMatrix) {\r\n\t\tvar style = this._style,\r\n\t\t\thasFill = style.hasFill(),\r\n\t\t\thasStroke = style.hasStroke(),\r\n\t\t\tdontPaint = param.dontFinish || param.clip,\r\n\t\t\tuntransformed = !strokeMatrix;\r\n\t\tif (hasFill || hasStroke || dontPaint) {\r\n\t\t\tvar type = this._type,\r\n\t\t\t\tradius = this._radius,\r\n\t\t\t\tisCircle = type === 'circle';\r\n\t\t\tif (!param.dontStart)\r\n\t\t\t\tctx.beginPath();\r\n\t\t\tif (untransformed && isCircle) {\r\n\t\t\t\tctx.arc(0, 0, radius, 0, Math.PI * 2, true);\r\n\t\t\t} else {\r\n\t\t\t\tvar rx = isCircle ? radius : radius.width,\r\n\t\t\t\t\try = isCircle ? radius : radius.height,\r\n\t\t\t\t\tsize = this._size,\r\n\t\t\t\t\twidth = size.width,\r\n\t\t\t\t\theight = size.height;\r\n\t\t\t\tif (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {\r\n\t\t\t\t\tctx.rect(-width / 2, -height / 2, width, height);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar x = width / 2,\r\n\t\t\t\t\t\ty = height / 2,\r\n\t\t\t\t\t\tkappa = 1 - 0.5522847498307936,\r\n\t\t\t\t\t\tcx = rx * kappa,\r\n\t\t\t\t\t\tcy = ry * kappa,\r\n\t\t\t\t\t\tc = [\r\n\t\t\t\t\t\t\t-x, -y + ry,\r\n\t\t\t\t\t\t\t-x, -y + cy,\r\n\t\t\t\t\t\t\t-x + cx, -y,\r\n\t\t\t\t\t\t\t-x + rx, -y,\r\n\t\t\t\t\t\t\tx - rx, -y,\r\n\t\t\t\t\t\t\tx - cx, -y,\r\n\t\t\t\t\t\t\tx, -y + cy,\r\n\t\t\t\t\t\t\tx, -y + ry,\r\n\t\t\t\t\t\t\tx, y - ry,\r\n\t\t\t\t\t\t\tx, y - cy,\r\n\t\t\t\t\t\t\tx - cx, y,\r\n\t\t\t\t\t\t\tx - rx, y,\r\n\t\t\t\t\t\t\t-x + rx, y,\r\n\t\t\t\t\t\t\t-x + cx, y,\r\n\t\t\t\t\t\t\t-x, y - cy,\r\n\t\t\t\t\t\t\t-x, y - ry\r\n\t\t\t\t\t\t];\r\n\t\t\t\t\tif (strokeMatrix)\r\n\t\t\t\t\t\tstrokeMatrix.transform(c, c, 32);\r\n\t\t\t\t\tctx.moveTo(c[0], c[1]);\r\n\t\t\t\t\tctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);\r\n\t\t\t\t\tif (x !== rx)\r\n\t\t\t\t\t\tctx.lineTo(c[8], c[9]);\r\n\t\t\t\t\tctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);\r\n\t\t\t\t\tif (y !== ry)\r\n\t\t\t\t\t\tctx.lineTo(c[16], c[17]);\r\n\t\t\t\t\tctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);\r\n\t\t\t\t\tif (x !== rx)\r\n\t\t\t\t\t\tctx.lineTo(c[24], c[25]);\r\n\t\t\t\t\tctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tctx.closePath();\r\n\t\t}\r\n\t\tif (!dontPaint && (hasFill || hasStroke)) {\r\n\t\t\tthis._setStyles(ctx);\r\n\t\t\tif (hasFill) {\r\n\t\t\t\tctx.fill(style.getWindingRule());\r\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\r\n\t\t\t}\r\n\t\t\tif (hasStroke)\r\n\t\t\t\tctx.stroke();\r\n\t\t}\r\n\t},\r\n\r\n\t_canComposite: function() {\r\n\t\treturn !(this.hasFill() && this.hasStroke());\r\n\t},\r\n\r\n\t_getBounds: function(getter, matrix) {\r\n\t\tvar rect = new Rectangle(this._size).setCenter(0, 0);\r\n\t\tif (getter !== 'getBounds' && this.hasStroke())\r\n\t\t\trect = rect.expand(this.getStrokeWidth());\r\n\t\treturn matrix ? matrix._transformBounds(rect) : rect;\r\n\t}\r\n},\r\nnew function() {\r\n\tfunction getCornerCenter(that, point, expand) {\r\n\t\tvar radius = that._radius;\r\n\t\tif (!radius.isZero()) {\r\n\t\t\tvar halfSize = that._size.divide(2);\r\n\t\t\tfor (var i = 0; i < 4; i++) {\r\n\t\t\t\tvar dir = new Point(i & 1 ? 1 : -1, i > 1 ? 1 : -1),\r\n\t\t\t\t\tcorner = dir.multiply(halfSize),\r\n\t\t\t\t\tcenter = corner.subtract(dir.multiply(radius)),\r\n\t\t\t\t\trect = new Rectangle(corner, center);\r\n\t\t\t\tif ((expand ? rect.expand(expand) : rect).contains(point))\r\n\t\t\t\t\treturn center;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getEllipseRadius(point, radius) {\r\n\t\tvar angle = point.getAngleInRadians(),\r\n\t\t\twidth = radius.width * 2,\r\n\t\t\theight = radius.height * 2,\r\n\t\t\tx = width * Math.sin(angle),\r\n\t\t\ty = height * Math.cos(angle);\r\n\t\treturn width * height / (2 * Math.sqrt(x * x + y * y));\r\n\t}\r\n\r\n\treturn {\r\n\t\t_contains: function _contains(point) {\r\n\t\t\tif (this._type === 'rectangle') {\r\n\t\t\t\tvar center = getCornerCenter(this, point);\r\n\t\t\t\treturn center\r\n\t\t\t\t\t\t? point.subtract(center).divide(this._radius)\r\n\t\t\t\t\t\t\t.getLength() <= 1\r\n\t\t\t\t\t\t: _contains.base.call(this, point);\r\n\t\t\t} else {\r\n\t\t\t\treturn point.divide(this.size).getLength() <= 0.5;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_hitTestSelf: function _hitTestSelf(point, options) {\r\n\t\t\tvar hit = false;\r\n\t\t\tif (this.hasStroke()) {\r\n\t\t\t\tvar type = this._type,\r\n\t\t\t\t\tradius = this._radius,\r\n\t\t\t\t\tstrokeWidth = this.getStrokeWidth() + 2 * options.tolerance;\r\n\t\t\t\tif (type === 'rectangle') {\r\n\t\t\t\t\tvar center = getCornerCenter(this, point, strokeWidth);\r\n\t\t\t\t\tif (center) {\r\n\t\t\t\t\t\tvar pt = point.subtract(center);\r\n\t\t\t\t\t\thit = 2 * Math.abs(pt.getLength()\r\n\t\t\t\t\t\t\t\t- getEllipseRadius(pt, radius)) <= strokeWidth;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar rect = new Rectangle(this._size).setCenter(0, 0),\r\n\t\t\t\t\t\t\touter = rect.expand(strokeWidth),\r\n\t\t\t\t\t\t\tinner = rect.expand(-strokeWidth);\r\n\t\t\t\t\t\thit = outer._containsPoint(point)\r\n\t\t\t\t\t\t\t\t&& !inner._containsPoint(point);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (type === 'ellipse')\r\n\t\t\t\t\t\tradius = getEllipseRadius(point, radius);\r\n\t\t\t\t\thit = 2 * Math.abs(point.getLength() - radius)\r\n\t\t\t\t\t\t\t<= strokeWidth;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn hit\r\n\t\t\t\t\t? new HitResult('stroke', this)\r\n\t\t\t\t\t: _hitTestSelf.base.apply(this, arguments);\r\n\t\t}\r\n\t};\r\n}, {\r\n\r\nstatics: new function() {\r\n\tfunction createShape(type, point, size, radius, args) {\r\n\t\tvar item = new Shape(Base.getNamed(args));\r\n\t\titem._type = type;\r\n\t\titem._size = size;\r\n\t\titem._radius = radius;\r\n\t\treturn item.translate(point);\r\n\t}\r\n\r\n\treturn {\r\n\t\tCircle: function() {\r\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\r\n\t\t\t\tradius = Base.readNamed(arguments, 'radius');\r\n\t\t\treturn createShape('circle', center, new Size(radius * 2), radius,\r\n\t\t\t\t\targuments);\r\n\t\t},\r\n\r\n\t\tRectangle: function() {\r\n\t\t\tvar rect = Rectangle.readNamed(arguments, 'rectangle'),\r\n\t\t\t\tradius = Size.min(Size.readNamed(arguments, 'radius'),\r\n\t\t\t\t\t\trect.getSize(true).divide(2));\r\n\t\t\treturn createShape('rectangle', rect.getCenter(true),\r\n\t\t\t\t\trect.getSize(true), radius, arguments);\r\n\t\t},\r\n\r\n\t\tEllipse: function() {\r\n\t\t\tvar ellipse = Shape._readEllipse(arguments),\r\n\t\t\t\tradius = ellipse.radius;\r\n\t\t\treturn createShape('ellipse', ellipse.center, radius.multiply(2),\r\n\t\t\t\t\tradius, arguments);\r\n\t\t},\r\n\r\n\t\t_readEllipse: function(args) {\r\n\t\t\tvar center,\r\n\t\t\t\tradius;\r\n\t\t\tif (Base.hasNamed(args, 'radius')) {\r\n\t\t\t\tcenter = Point.readNamed(args, 'center');\r\n\t\t\t\tradius = Size.readNamed(args, 'radius');\r\n\t\t\t} else {\r\n\t\t\t\tvar rect = Rectangle.readNamed(args, 'rectangle');\r\n\t\t\t\tcenter = rect.getCenter(true);\r\n\t\t\t\tradius = rect.getSize(true).divide(2);\r\n\t\t\t}\r\n\t\t\treturn { center: center, radius: radius };\r\n\t\t}\r\n\t};\r\n}});\r\n\r\nvar Raster = Item.extend({\r\n\t_class: 'Raster',\r\n\t_applyMatrix: false,\r\n\t_canApplyMatrix: false,\r\n\t_boundsGetter: 'getBounds',\r\n\t_boundsSelected: true,\r\n\t_serializeFields: {\r\n\t\tcrossOrigin: null,\r\n\t\tsource: null\r\n\t},\r\n\r\n\tinitialize: function Raster(object, position) {\r\n\t\tif (!this._initialize(object,\r\n\t\t\t\tposition !== undefined && Point.read(arguments, 1))) {\r\n\t\t\tif (typeof object === 'string') {\r\n\t\t\t\tthis.setSource(object);\r\n\t\t\t} else {\r\n\t\t\t\tthis.setImage(object);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!this._size) {\r\n\t\t\tthis._size = new Size();\r\n\t\t\tthis._loaded = false;\r\n\t\t}\r\n\t},\r\n\r\n\t_equals: function(item) {\r\n\t\treturn this.getSource() === item.getSource();\r\n\t},\r\n\r\n\tclone: function(insert) {\r\n\t\tvar copy = new Raster(Item.NO_INSERT),\r\n\t\t\timage = this._image,\r\n\t\t\tcanvas = this._canvas;\r\n\t\tif (image) {\r\n\t\t\tcopy.setImage(image);\r\n\t\t} else if (canvas) {\r\n\t\t\tvar copyCanvas = CanvasProvider.getCanvas(this._size);\r\n\t\t\tcopyCanvas.getContext('2d').drawImage(canvas, 0, 0);\r\n\t\t\tcopy.setImage(copyCanvas);\r\n\t\t}\r\n\t\tcopy._crossOrigin = this._crossOrigin;\r\n\t\treturn this._clone(copy, insert);\r\n\t},\r\n\r\n\tgetSize: function() {\r\n\t\tvar size = this._size;\r\n\t\treturn new LinkedSize(size ? size.width : 0, size ? size.height : 0,\r\n\t\t\t\tthis, 'setSize');\r\n\t},\r\n\r\n\tsetSize: function() {\r\n\t\tvar size = Size.read(arguments);\r\n\t\tif (!size.equals(this._size)) {\r\n\t\t\tif (size.width > 0 && size.height > 0) {\r\n\t\t\t\tvar element = this.getElement();\r\n\t\t\t\tthis.setImage(CanvasProvider.getCanvas(size));\r\n\t\t\t\tif (element)\r\n\t\t\t\t\tthis.getContext(true).drawImage(element, 0, 0,\r\n\t\t\t\t\t\t\tsize.width, size.height);\r\n\t\t\t} else {\r\n\t\t\t\tif (this._canvas)\r\n\t\t\t\t\tCanvasProvider.release(this._canvas);\r\n\t\t\t\tthis._size = size.clone();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tgetWidth: function() {\r\n\t\treturn this._size ? this._size.width : 0;\r\n\t},\r\n\r\n\tsetWidth: function(width) {\r\n\t\tthis.setSize(width, this.getHeight());\r\n\t},\r\n\r\n\tgetHeight: function() {\r\n\t\treturn this._size ? this._size.height : 0;\r\n\t},\r\n\r\n\tsetHeight: function(height) {\r\n\t\tthis.setSize(this.getWidth(), height);\r\n\t},\r\n\r\n\tisEmpty: function() {\r\n\t\tvar size = this._size;\r\n\t\treturn !size || size.width === 0 && size.height === 0;\r\n\t},\r\n\r\n\tgetResolution: function() {\r\n\t\tvar matrix = this._matrix,\r\n\t\t\torig = new Point(0, 0).transform(matrix),\r\n\t\t\tu = new Point(1, 0).transform(matrix).subtract(orig),\r\n\t\t\tv = new Point(0, 1).transform(matrix).subtract(orig);\r\n\t\treturn new Size(\r\n\t\t\t72 / u.getLength(),\r\n\t\t\t72 / v.getLength()\r\n\t\t);\r\n\t},\r\n\r\n\tgetPpi: '#getResolution',\r\n\r\n\tgetImage: function() {\r\n\t\treturn this._image;\r\n\t},\r\n\r\n\tsetImage: function(image) {\r\n\t\tif (this._canvas)\r\n\t\t\tCanvasProvider.release(this._canvas);\r\n\t\tif (image && image.getContext) {\r\n\t\t\tthis._image = null;\r\n\t\t\tthis._canvas = image;\r\n\t\t\tthis._loaded = true;\r\n\t\t} else {\r\n\t\t\tthis._image = image;\r\n\t\t\tthis._canvas = null;\r\n\t\t\tthis._loaded = image && image.complete;\r\n\t\t}\r\n\t\tthis._size = new Size(\r\n\t\t\t\timage ? image.naturalWidth || image.width : 0,\r\n\t\t\t\timage ? image.naturalHeight || image.height : 0);\r\n\t\tthis._context = null;\r\n\t\tthis._changed(521);\r\n\t},\r\n\r\n\tgetCanvas: function() {\r\n\t\tif (!this._canvas) {\r\n\t\t\tvar ctx = CanvasProvider.getContext(this._size);\r\n\t\t\ttry {\r\n\t\t\t\tif (this._image)\r\n\t\t\t\t\tctx.drawImage(this._image, 0, 0);\r\n\t\t\t\tthis._canvas = ctx.canvas;\r\n\t\t\t} catch (e) {\r\n\t\t\t\tCanvasProvider.release(ctx);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this._canvas;\r\n\t},\r\n\r\n\tsetCanvas: '#setImage',\r\n\r\n\tgetContext: function(modify) {\r\n\t\tif (!this._context)\r\n\t\t\tthis._context = this.getCanvas().getContext('2d');\r\n\t\tif (modify) {\r\n\t\t\tthis._image = null;\r\n\t\t\tthis._changed(513);\r\n\t\t}\r\n\t\treturn this._context;\r\n\t},\r\n\r\n\tsetContext: function(context) {\r\n\t\tthis._context = context;\r\n\t},\r\n\r\n\tgetSource: function() {\r\n\t\treturn this._image && this._image.src || this.toDataURL();\r\n\t},\r\n\r\n\tsetSource: function(src) {\r\n\t\tvar that = this,\r\n\t\t\tcrossOrigin = this._crossOrigin,\r\n\t\t\timage;\r\n\r\n\t\tfunction loaded() {\r\n\t\t\tvar view = that.getView();\r\n\t\t\tif (view) {\r\n\t\t\t\tpaper = view._scope;\r\n\t\t\t\tthat.setImage(image);\r\n\t\t\t\tthat.emit('load');\r\n\t\t\t\tview.update();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\timage = document.getElementById(src) || new Image();\r\n\t\tif (crossOrigin)\r\n\t\t\timage.crossOrigin = crossOrigin;\r\n\t\tif (image.naturalWidth && image.naturalHeight) {\r\n\t\t\tsetTimeout(loaded, 0);\r\n\t\t} else {\r\n\t\t\tDomEvent.add(image, { load: loaded });\r\n\t\t\tif (!image.src)\r\n\t\t\t\timage.src = src;\r\n\t\t}\r\n\t\tthis.setImage(image);\r\n\t},\r\n\r\n\tgetCrossOrigin: function() {\r\n\t\treturn this._image && this._image.crossOrigin || this._crossOrigin || '';\r\n\t},\r\n\r\n\tsetCrossOrigin: function(crossOrigin) {\r\n\t\tthis._crossOrigin = crossOrigin;\r\n\t\tif (this._image)\r\n\t\t\tthis._image.crossOrigin = crossOrigin;\r\n\t},\r\n\r\n\tgetElement: function() {\r\n\t\treturn this._canvas || this._loaded && this._image;\r\n\t}\r\n}, {\r\n\tbeans: false,\r\n\r\n\tgetSubCanvas: function() {\r\n\t\tvar rect = Rectangle.read(arguments),\r\n\t\t\tctx = CanvasProvider.getContext(rect.getSize());\r\n\t\tctx.drawImage(this.getCanvas(), rect.x, rect.y,\r\n\t\t\t\trect.width, rect.height, 0, 0, rect.width, rect.height);\r\n\t\treturn ctx.canvas;\r\n\t},\r\n\r\n\tgetSubRaster: function() {\r\n\t\tvar rect = Rectangle.read(arguments),\r\n\t\t\traster = new Raster(Item.NO_INSERT);\r\n\t\traster.setImage(this.getSubCanvas(rect));\r\n\t\traster.translate(rect.getCenter().subtract(this.getSize().divide(2)));\r\n\t\traster._matrix.preConcatenate(this._matrix);\r\n\t\traster.insertAbove(this);\r\n\t\treturn raster;\r\n\t},\r\n\r\n\ttoDataURL: function() {\r\n\t\tvar src = this._image && this._image.src;\r\n\t\tif (/^data:/.test(src))\r\n\t\t\treturn src;\r\n\t\tvar canvas = this.getCanvas();\r\n\t\treturn canvas ? canvas.toDataURL.apply(canvas, arguments) : null;\r\n\t},\r\n\r\n\tdrawImage: function(image ) {\r\n\t\tvar point = Point.read(arguments, 1);\r\n\t\tthis.getContext(true).drawImage(image, point.x, point.y);\r\n\t},\r\n\r\n\tgetAverageColor: function(object) {\r\n\t\tvar bounds, path;\r\n\t\tif (!object) {\r\n\t\t\tbounds = this.getBounds();\r\n\t\t} else if (object instanceof PathItem) {\r\n\t\t\tpath = object;\r\n\t\t\tbounds = object.getBounds();\r\n\t\t} else if (object.width) {\r\n\t\t\tbounds = new Rectangle(object);\r\n\t\t} else if (object.x) {\r\n\t\t\tbounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);\r\n\t\t}\r\n\t\tvar sampleSize = 32,\r\n\t\t\twidth = Math.min(bounds.width, sampleSize),\r\n\t\t\theight = Math.min(bounds.height, sampleSize);\r\n\t\tvar ctx = Raster._sampleContext;\r\n\t\tif (!ctx) {\r\n\t\t\tctx = Raster._sampleContext = CanvasProvider.getContext(\r\n\t\t\t\t\tnew Size(sampleSize));\r\n\t\t} else {\r\n\t\t\tctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);\r\n\t\t}\r\n\t\tctx.save();\r\n\t\tvar matrix = new Matrix()\r\n\t\t\t\t.scale(width / bounds.width, height / bounds.height)\r\n\t\t\t\t.translate(-bounds.x, -bounds.y);\r\n\t\tmatrix.applyToContext(ctx);\r\n\t\tif (path)\r\n\t\t\tpath.draw(ctx, new Base({ clip: true, matrices: [matrix] }));\r\n\t\tthis._matrix.applyToContext(ctx);\r\n\t\tvar element = this.getElement(),\r\n\t\t\tsize = this._size;\r\n\t\tif (element)\r\n\t\t\tctx.drawImage(element, -size.width / 2, -size.height / 2);\r\n\t\tctx.restore();\r\n\t\tvar pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),\r\n\t\t\t\tMath.ceil(height)).data,\r\n\t\t\tchannels = [0, 0, 0],\r\n\t\t\ttotal = 0;\r\n\t\tfor (var i = 0, l = pixels.length; i < l; i += 4) {\r\n\t\t\tvar alpha = pixels[i + 3];\r\n\t\t\ttotal += alpha;\r\n\t\t\talpha /= 255;\r\n\t\t\tchannels[0] += pixels[i] * alpha;\r\n\t\t\tchannels[1] += pixels[i + 1] * alpha;\r\n\t\t\tchannels[2] += pixels[i + 2] * alpha;\r\n\t\t}\r\n\t\tfor (var i = 0; i < 3; i++)\r\n\t\t\tchannels[i] /= total;\r\n\t\treturn total ? Color.read(channels) : null;\r\n\t},\r\n\r\n\tgetPixel: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\tvar data = this.getContext().getImageData(point.x, point.y, 1, 1).data;\r\n\t\treturn new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],\r\n\t\t\t\tdata[3] / 255);\r\n\t},\r\n\r\n\tsetPixel: function() {\r\n\t\tvar point = Point.read(arguments),\r\n\t\t\tcolor = Color.read(arguments),\r\n\t\t\tcomponents = color._convert('rgb'),\r\n\t\t\talpha = color._alpha,\r\n\t\t\tctx = this.getContext(true),\r\n\t\t\timageData = ctx.createImageData(1, 1),\r\n\t\t\tdata = imageData.data;\r\n\t\tdata[0] = components[0] * 255;\r\n\t\tdata[1] = components[1] * 255;\r\n\t\tdata[2] = components[2] * 255;\r\n\t\tdata[3] = alpha != null ? alpha * 255 : 255;\r\n\t\tctx.putImageData(imageData, point.x, point.y);\r\n\t},\r\n\r\n\tcreateImageData: function() {\r\n\t\tvar size = Size.read(arguments);\r\n\t\treturn this.getContext().createImageData(size.width, size.height);\r\n\t},\r\n\r\n\tgetImageData: function() {\r\n\t\tvar rect = Rectangle.read(arguments);\r\n\t\tif (rect.isEmpty())\r\n\t\t\trect = new Rectangle(this._size);\r\n\t\treturn this.getContext().getImageData(rect.x, rect.y,\r\n\t\t\t\trect.width, rect.height);\r\n\t},\r\n\r\n\tsetImageData: function(data ) {\r\n\t\tvar point = Point.read(arguments, 1);\r\n\t\tthis.getContext(true).putImageData(data, point.x, point.y);\r\n\t},\r\n\r\n\t_getBounds: function(getter, matrix) {\r\n\t\tvar rect = new Rectangle(this._size).setCenter(0, 0);\r\n\t\treturn matrix ? matrix._transformBounds(rect) : rect;\r\n\t},\r\n\r\n\t_hitTestSelf: function(point) {\r\n\t\tif (this._contains(point)) {\r\n\t\t\tvar that = this;\r\n\t\t\treturn new HitResult('pixel', that, {\r\n\t\t\t\toffset: point.add(that._size.divide(2)).round(),\r\n\t\t\t\tcolor: {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn that.getPixel(this.offset);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\t_draw: function(ctx) {\r\n\t\tvar element = this.getElement();\r\n\t\tif (element) {\r\n\t\t\tctx.globalAlpha = this._opacity;\r\n\t\t\tctx.drawImage(element,\r\n\t\t\t\t\t-this._size.width / 2, -this._size.height / 2);\r\n\t\t}\r\n\t},\r\n\r\n\t_canComposite: function() {\r\n\t\treturn true;\r\n\t}\r\n});\r\n\r\nvar PlacedSymbol = Item.extend({\r\n\t_class: 'PlacedSymbol',\r\n\t_applyMatrix: false,\r\n\t_canApplyMatrix: false,\r\n\t_boundsGetter: { getBounds: 'getStrokeBounds' },\r\n\t_boundsSelected: true,\r\n\t_serializeFields: {\r\n\t\tsymbol: null\r\n\t},\r\n\r\n\tinitialize: function PlacedSymbol(arg0, arg1) {\r\n\t\tif (!this._initialize(arg0,\r\n\t\t\t\targ1 !== undefined && Point.read(arguments, 1)))\r\n\t\t\tthis.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0));\r\n\t},\r\n\r\n\t_equals: function(item) {\r\n\t\treturn this._symbol === item._symbol;\r\n\t},\r\n\r\n\tgetSymbol: function() {\r\n\t\treturn this._symbol;\r\n\t},\r\n\r\n\tsetSymbol: function(symbol) {\r\n\t\tthis._symbol = symbol;\r\n\t\tthis._changed(9);\r\n\t},\r\n\r\n\tclone: function(insert) {\r\n\t\tvar copy = new PlacedSymbol(Item.NO_INSERT);\r\n\t\tcopy.setSymbol(this._symbol);\r\n\t\treturn this._clone(copy, insert);\r\n\t},\r\n\r\n\tisEmpty: function() {\r\n\t\treturn this._symbol._definition.isEmpty();\r\n\t},\r\n\r\n\t_getBounds: function(getter, matrix, cacheItem) {\r\n\t\tvar definition = this.symbol._definition;\r\n\t\treturn definition._getCachedBounds(getter,\r\n\t\t\t\tmatrix && matrix.chain(definition._matrix), cacheItem);\r\n\t},\r\n\r\n\t_hitTestSelf: function(point, options) {\r\n\t\tvar res = this._symbol._definition._hitTest(point, options);\r\n\t\tif (res)\r\n\t\t\tres.item = this;\r\n\t\treturn res;\r\n\t},\r\n\r\n\t_draw: function(ctx, param) {\r\n\t\tthis.symbol._definition.draw(ctx, param);\r\n\t}\r\n\r\n});\r\n\r\nvar HitResult = Base.extend({\r\n\t_class: 'HitResult',\r\n\r\n\tinitialize: function HitResult(type, item, values) {\r\n\t\tthis.type = type;\r\n\t\tthis.item = item;\r\n\t\tif (values) {\r\n\t\t\tvalues.enumerable = true;\r\n\t\t\tthis.inject(values);\r\n\t\t}\r\n\t},\r\n\r\n\tstatics: {\r\n\t\tgetOptions: function(options) {\r\n\t\t\treturn new Base({\r\n\t\t\t\ttype: null,\r\n\t\t\t\ttolerance: paper.settings.hitTolerance,\r\n\t\t\t\tfill: !options,\r\n\t\t\t\tstroke: !options,\r\n\t\t\t\tsegments: !options,\r\n\t\t\t\thandles: false,\r\n\t\t\t\tends: false,\r\n\t\t\t\tcenter: false,\r\n\t\t\t\tbounds: false,\r\n\t\t\t\tguides: false,\r\n\t\t\t\tselected: false\r\n\t\t\t}, options);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar Segment = Base.extend({\r\n\t_class: 'Segment',\r\n\tbeans: true,\r\n\r\n\tinitialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {\r\n\t\tvar count = arguments.length,\r\n\t\t\tpoint, handleIn, handleOut;\r\n\t\tif (count === 0) {\r\n\t\t} else if (count === 1) {\r\n\t\t\tif ('point' in arg0) {\r\n\t\t\t\tpoint = arg0.point;\r\n\t\t\t\thandleIn = arg0.handleIn;\r\n\t\t\t\thandleOut = arg0.handleOut;\r\n\t\t\t} else {\r\n\t\t\t\tpoint = arg0;\r\n\t\t\t}\r\n\t\t} else if (count === 2 && typeof arg0 === 'number') {\r\n\t\t\tpoint = arguments;\r\n\t\t} else if (count <= 3) {\r\n\t\t\tpoint = arg0;\r\n\t\t\thandleIn = arg1;\r\n\t\t\thandleOut = arg2;\r\n\t\t} else {\r\n\t\t\tpoint = arg0 !== undefined ? [ arg0, arg1 ] : null;\r\n\t\t\thandleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;\r\n\t\t\thandleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;\r\n\t\t}\r\n\t\tnew SegmentPoint(point, this, '_point');\r\n\t\tnew SegmentPoint(handleIn, this, '_handleIn');\r\n\t\tnew SegmentPoint(handleOut, this, '_handleOut');\r\n\t},\r\n\r\n\t_serialize: function(options) {\r\n\t\treturn Base.serialize(this.hasHandles()\r\n\t\t\t\t? [this._point, this._handleIn, this._handleOut]\r\n\t\t\t\t: this._point,\r\n\t\t\t\toptions, true);\r\n\t},\r\n\r\n\t_changed: function(point) {\r\n\t\tvar path = this._path;\r\n\t\tif (!path)\r\n\t\t\treturn;\r\n\t\tvar curves = path._curves,\r\n\t\t\tindex = this._index,\r\n\t\t\tcurve;\r\n\t\tif (curves) {\r\n\t\t\tif ((!point || point === this._point || point === this._handleIn)\r\n\t\t\t\t\t&& (curve = index > 0 ? curves[index - 1] : path._closed\r\n\t\t\t\t\t\t? curves[curves.length - 1] : null))\r\n\t\t\t\tcurve._changed();\r\n\t\t\tif ((!point || point === this._point || point === this._handleOut)\r\n\t\t\t\t\t&& (curve = curves[index]))\r\n\t\t\t\tcurve._changed();\r\n\t\t}\r\n\t\tpath._changed(25);\r\n\t},\r\n\r\n\tgetPoint: function() {\r\n\t\treturn this._point;\r\n\t},\r\n\r\n\tsetPoint: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\tthis._point.set(point.x, point.y);\r\n\t},\r\n\r\n\tgetHandleIn: function() {\r\n\t\treturn this._handleIn;\r\n\t},\r\n\r\n\tsetHandleIn: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\tthis._handleIn.set(point.x, point.y);\r\n\t},\r\n\r\n\tgetHandleOut: function() {\r\n\t\treturn this._handleOut;\r\n\t},\r\n\r\n\tsetHandleOut: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\tthis._handleOut.set(point.x, point.y);\r\n\t},\r\n\r\n\thasHandles: function() {\r\n\t\treturn !this._handleIn.isZero() || !this._handleOut.isZero();\r\n\t},\r\n\r\n\tclearHandles: function() {\r\n\t\tthis._handleIn.set(0, 0);\r\n\t\tthis._handleOut.set(0, 0);\r\n\t},\r\n\r\n\t_selectionState: 0,\r\n\r\n\tisSelected: function(_point) {\r\n\t\tvar state = this._selectionState;\r\n\t\treturn !_point ? !!(state & 7)\r\n\t\t\t: _point === this._point ? !!(state & 4)\r\n\t\t\t: _point === this._handleIn ? !!(state & 1)\r\n\t\t\t: _point === this._handleOut ? !!(state & 2)\r\n\t\t\t: false;\r\n\t},\r\n\r\n\tsetSelected: function(selected, _point) {\r\n\t\tvar path = this._path,\r\n\t\t\tselected = !!selected,\r\n\t\t\tstate = this._selectionState,\r\n\t\t\toldState = state,\r\n\t\t\tflag = !_point ? 7\r\n\t\t\t\t\t: _point === this._point ? 4\r\n\t\t\t\t\t: _point === this._handleIn ? 1\r\n\t\t\t\t\t: _point === this._handleOut ? 2\r\n\t\t\t\t\t: 0;\r\n\t\tif (selected) {\r\n\t\t\tstate |= flag;\r\n\t\t} else {\r\n\t\t\tstate &= ~flag;\r\n\t\t}\r\n\t\tthis._selectionState = state;\r\n\t\tif (path && state !== oldState) {\r\n\t\t\tpath._updateSelection(this, oldState, state);\r\n\t\t\tpath._changed(129);\r\n\t\t}\r\n\t},\r\n\r\n\tgetIndex: function() {\r\n\t\treturn this._index !== undefined ? this._index : null;\r\n\t},\r\n\r\n\tgetPath: function() {\r\n\t\treturn this._path || null;\r\n\t},\r\n\r\n\tgetCurve: function() {\r\n\t\tvar path = this._path,\r\n\t\t\tindex = this._index;\r\n\t\tif (path) {\r\n\t\t\tif (index > 0 && !path._closed\r\n\t\t\t\t\t&& index === path._segments.length - 1)\r\n\t\t\t\tindex--;\r\n\t\t\treturn path.getCurves()[index] || null;\r\n\t\t}\r\n\t\treturn null;\r\n\t},\r\n\r\n\tgetLocation: function() {\r\n\t\tvar curve = this.getCurve();\r\n\t\treturn curve\r\n\t\t\t\t? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)\r\n\t\t\t\t: null;\r\n\t},\r\n\r\n\tgetNext: function() {\r\n\t\tvar segments = this._path && this._path._segments;\r\n\t\treturn segments && (segments[this._index + 1]\r\n\t\t\t\t|| this._path._closed && segments[0]) || null;\r\n\t},\r\n\r\n\tgetPrevious: function() {\r\n\t\tvar segments = this._path && this._path._segments;\r\n\t\treturn segments && (segments[this._index - 1]\r\n\t\t\t\t|| this._path._closed && segments[segments.length - 1]) || null;\r\n\t},\r\n\r\n\tisFirst: function() {\r\n\t\treturn this._index === 0;\r\n\t},\r\n\r\n\tisLast: function() {\r\n\t\tvar path = this._path;\r\n\t\treturn path && this._index === path._segments.length - 1 || false;\r\n\t},\r\n\r\n\treverse: function() {\r\n\t\tvar handleIn = this._handleIn,\r\n\t\t\thandleOut = this._handleOut,\r\n\t\t\tinX = handleIn._x,\r\n\t\t\tinY = handleIn._y;\r\n\t\thandleIn.set(handleOut._x, handleOut._y);\r\n\t\thandleOut.set(inX, inY);\r\n\t},\r\n\r\n\treversed: function() {\r\n\t\treturn new Segment(this._point, this._handleOut, this._handleIn);\r\n\t},\r\n\r\n\tremove: function() {\r\n\t\treturn this._path ? !!this._path.removeSegment(this._index) : false;\r\n\t},\r\n\r\n\tclone: function() {\r\n\t\treturn new Segment(this._point, this._handleIn, this._handleOut);\r\n\t},\r\n\r\n\tequals: function(segment) {\r\n\t\treturn segment === this || segment && this._class === segment._class\r\n\t\t\t\t&& this._point.equals(segment._point)\r\n\t\t\t\t&& this._handleIn.equals(segment._handleIn)\r\n\t\t\t\t&& this._handleOut.equals(segment._handleOut)\r\n\t\t\t\t|| false;\r\n\t},\r\n\r\n\ttoString: function() {\r\n\t\tvar parts = [ 'point: ' + this._point ];\r\n\t\tif (!this._handleIn.isZero())\r\n\t\t\tparts.push('handleIn: ' + this._handleIn);\r\n\t\tif (!this._handleOut.isZero())\r\n\t\t\tparts.push('handleOut: ' + this._handleOut);\r\n\t\treturn '{ ' + parts.join(', ') + ' }';\r\n\t},\r\n\r\n\ttransform: function(matrix) {\r\n\t\tthis._transformCoordinates(matrix, new Array(6), true);\r\n\t\tthis._changed();\r\n\t},\r\n\r\n\t_transformCoordinates: function(matrix, coords, change) {\r\n\t\tvar point = this._point,\r\n\t\t\thandleIn = !change || !this._handleIn.isZero()\r\n\t\t\t\t\t? this._handleIn : null,\r\n\t\t\thandleOut = !change || !this._handleOut.isZero()\r\n\t\t\t\t\t? this._handleOut : null,\r\n\t\t\tx = point._x,\r\n\t\t\ty = point._y,\r\n\t\t\ti = 2;\r\n\t\tcoords[0] = x;\r\n\t\tcoords[1] = y;\r\n\t\tif (handleIn) {\r\n\t\t\tcoords[i++] = handleIn._x + x;\r\n\t\t\tcoords[i++] = handleIn._y + y;\r\n\t\t}\r\n\t\tif (handleOut) {\r\n\t\t\tcoords[i++] = handleOut._x + x;\r\n\t\t\tcoords[i++] = handleOut._y + y;\r\n\t\t}\r\n\t\tif (matrix) {\r\n\t\t\tmatrix._transformCoordinates(coords, coords, i / 2);\r\n\t\t\tx = coords[0];\r\n\t\t\ty = coords[1];\r\n\t\t\tif (change) {\r\n\t\t\t\tpoint._x = x;\r\n\t\t\t\tpoint._y = y;\r\n\t\t\t\ti  = 2;\r\n\t\t\t\tif (handleIn) {\r\n\t\t\t\t\thandleIn._x = coords[i++] - x;\r\n\t\t\t\t\thandleIn._y = coords[i++] - y;\r\n\t\t\t\t}\r\n\t\t\t\tif (handleOut) {\r\n\t\t\t\t\thandleOut._x = coords[i++] - x;\r\n\t\t\t\t\thandleOut._y = coords[i++] - y;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (!handleIn) {\r\n\t\t\t\t\tcoords[i++] = x;\r\n\t\t\t\t\tcoords[i++] = y;\r\n\t\t\t\t}\r\n\t\t\t\tif (!handleOut) {\r\n\t\t\t\t\tcoords[i++] = x;\r\n\t\t\t\t\tcoords[i++] = y;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn coords;\r\n\t}\r\n});\r\n\r\nvar SegmentPoint = Point.extend({\r\n\tinitialize: function SegmentPoint(point, owner, key) {\r\n\t\tvar x, y, selected;\r\n\t\tif (!point) {\r\n\t\t\tx = y = 0;\r\n\t\t} else if ((x = point[0]) !== undefined) {\r\n\t\t\ty = point[1];\r\n\t\t} else {\r\n\t\t\tvar pt = point;\r\n\t\t\tif ((x = pt.x) === undefined) {\r\n\t\t\t\tpt = Point.read(arguments);\r\n\t\t\t\tx = pt.x;\r\n\t\t\t}\r\n\t\t\ty = pt.y;\r\n\t\t\tselected = pt.selected;\r\n\t\t}\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._owner = owner;\r\n\t\towner[key] = this;\r\n\t\tif (selected)\r\n\t\t\tthis.setSelected(true);\r\n\t},\r\n\r\n\tset: function(x, y) {\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._owner._changed(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_serialize: function(options) {\r\n\t\tvar f = options.formatter,\r\n\t\t\tx = f.number(this._x),\r\n\t\t\ty = f.number(this._y);\r\n\t\treturn this.isSelected()\r\n\t\t\t\t? { x: x, y: y, selected: true }\r\n\t\t\t\t: [x, y];\r\n\t},\r\n\r\n\tgetX: function() {\r\n\t\treturn this._x;\r\n\t},\r\n\r\n\tsetX: function(x) {\r\n\t\tthis._x = x;\r\n\t\tthis._owner._changed(this);\r\n\t},\r\n\r\n\tgetY: function() {\r\n\t\treturn this._y;\r\n\t},\r\n\r\n\tsetY: function(y) {\r\n\t\tthis._y = y;\r\n\t\tthis._owner._changed(this);\r\n\t},\r\n\r\n\tisZero: function() {\r\n\t\treturn Numerical.isZero(this._x) && Numerical.isZero(this._y);\r\n\t},\r\n\r\n\tsetSelected: function(selected) {\r\n\t\tthis._owner.setSelected(selected, this);\r\n\t},\r\n\r\n\tisSelected: function() {\r\n\t\treturn this._owner.isSelected(this);\r\n\t}\r\n});\r\n\r\nvar Curve = Base.extend({\r\n\t_class: 'Curve',\r\n\r\n\tinitialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\r\n\t\tvar count = arguments.length,\r\n\t\t\tseg1, seg2,\r\n\t\t\tpoint1, point2,\r\n\t\t\thandle1, handle2;\r\n\t\tif (count === 3) {\r\n\t\t\tthis._path = arg0;\r\n\t\t\tseg1 = arg1;\r\n\t\t\tseg2 = arg2;\r\n\t\t} else if (count === 0) {\r\n\t\t\tseg1 = new Segment();\r\n\t\t\tseg2 = new Segment();\r\n\t\t} else if (count === 1) {\r\n\t\t\tif ('segment1' in arg0) {\r\n\t\t\t\tseg1 = new Segment(arg0.segment1);\r\n\t\t\t\tseg2 = new Segment(arg0.segment2);\r\n\t\t\t} else if ('point1' in arg0) {\r\n\t\t\t\tpoint1 = arg0.point1;\r\n\t\t\t\thandle1 = arg0.handle1;\r\n\t\t\t\thandle2 = arg0.handle2;\r\n\t\t\t\tpoint2 = arg0.point2;\r\n\t\t\t} else if (Array.isArray(arg0)) {\r\n\t\t\t\tpoint1 = [arg0[0], arg0[1]];\r\n\t\t\t\tpoint2 = [arg0[6], arg0[7]];\r\n\t\t\t\thandle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];\r\n\t\t\t\thandle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];\r\n\t\t\t}\r\n\t\t} else if (count === 2) {\r\n\t\t\tseg1 = new Segment(arg0);\r\n\t\t\tseg2 = new Segment(arg1);\r\n\t\t} else if (count === 4) {\r\n\t\t\tpoint1 = arg0;\r\n\t\t\thandle1 = arg1;\r\n\t\t\thandle2 = arg2;\r\n\t\t\tpoint2 = arg3;\r\n\t\t} else if (count === 8) {\r\n\t\t\tpoint1 = [arg0, arg1];\r\n\t\t\tpoint2 = [arg6, arg7];\r\n\t\t\thandle1 = [arg2 - arg0, arg3 - arg1];\r\n\t\t\thandle2 = [arg4 - arg6, arg5 - arg7];\r\n\t\t}\r\n\t\tthis._segment1 = seg1 || new Segment(point1, null, handle1);\r\n\t\tthis._segment2 = seg2 || new Segment(point2, handle2, null);\r\n\t},\r\n\r\n\t_serialize: function(options) {\r\n\t\treturn Base.serialize(this.hasHandles()\r\n\t\t\t\t? [this.getPoint1(), this.getHandle1(), this.getHandle2(),\r\n\t\t\t\t\tthis.getPoint2()]\r\n\t\t\t\t: [this.getPoint1(), this.getPoint2()],\r\n\t\t\t\toptions, true);\r\n\t},\r\n\r\n\t_changed: function() {\r\n\t\tthis._length = this._bounds = undefined;\r\n\t},\r\n\r\n\tclone: function() {\r\n\t\treturn new Curve(this._segment1, this._segment2);\r\n\t},\r\n\r\n\ttoString: function() {\r\n\t\tvar parts = [ 'point1: ' + this._segment1._point ];\r\n\t\tif (!this._segment1._handleOut.isZero())\r\n\t\t\tparts.push('handle1: ' + this._segment1._handleOut);\r\n\t\tif (!this._segment2._handleIn.isZero())\r\n\t\t\tparts.push('handle2: ' + this._segment2._handleIn);\r\n\t\tparts.push('point2: ' + this._segment2._point);\r\n\t\treturn '{ ' + parts.join(', ') + ' }';\r\n\t},\r\n\r\n\tremove: function() {\r\n\t\tvar removed = false;\r\n\t\tif (this._path) {\r\n\t\t\tvar segment2 = this._segment2,\r\n\t\t\t\thandleOut = segment2._handleOut;\r\n\t\t\tremoved = segment2.remove();\r\n\t\t\tif (removed)\r\n\t\t\t\tthis._segment1._handleOut.set(handleOut.x, handleOut.y);\r\n\t\t}\r\n\t\treturn removed;\r\n\t},\r\n\r\n\tgetPoint1: function() {\r\n\t\treturn this._segment1._point;\r\n\t},\r\n\r\n\tsetPoint1: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\tthis._segment1._point.set(point.x, point.y);\r\n\t},\r\n\r\n\tgetPoint2: function() {\r\n\t\treturn this._segment2._point;\r\n\t},\r\n\r\n\tsetPoint2: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\tthis._segment2._point.set(point.x, point.y);\r\n\t},\r\n\r\n\tgetHandle1: function() {\r\n\t\treturn this._segment1._handleOut;\r\n\t},\r\n\r\n\tsetHandle1: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\tthis._segment1._handleOut.set(point.x, point.y);\r\n\t},\r\n\r\n\tgetHandle2: function() {\r\n\t\treturn this._segment2._handleIn;\r\n\t},\r\n\r\n\tsetHandle2: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\tthis._segment2._handleIn.set(point.x, point.y);\r\n\t},\r\n\r\n\tgetSegment1: function() {\r\n\t\treturn this._segment1;\r\n\t},\r\n\r\n\tgetSegment2: function() {\r\n\t\treturn this._segment2;\r\n\t},\r\n\r\n\tgetPath: function() {\r\n\t\treturn this._path;\r\n\t},\r\n\r\n\tgetIndex: function() {\r\n\t\treturn this._segment1._index;\r\n\t},\r\n\r\n\tgetNext: function() {\r\n\t\tvar curves = this._path && this._path._curves;\r\n\t\treturn curves && (curves[this._segment1._index + 1]\r\n\t\t\t\t|| this._path._closed && curves[0]) || null;\r\n\t},\r\n\r\n\tgetPrevious: function() {\r\n\t\tvar curves = this._path && this._path._curves;\r\n\t\treturn curves && (curves[this._segment1._index - 1]\r\n\t\t\t\t|| this._path._closed && curves[curves.length - 1]) || null;\r\n\t},\r\n\r\n\tisFirst: function() {\r\n\t\treturn this._segment1._index === 0;\r\n\t},\r\n\r\n\tisLast: function() {\r\n\t\tvar path = this._path;\r\n\t\treturn path && this._segment1._index === path._curves.length - 1\r\n\t\t\t\t|| false;\r\n\t},\r\n\r\n\tisSelected: function() {\r\n\t\treturn this.getPoint1().isSelected()\r\n\t\t\t\t&& this.getHandle2().isSelected()\r\n\t\t\t\t&& this.getHandle2().isSelected()\r\n\t\t\t\t&& this.getPoint2().isSelected();\r\n\t},\r\n\r\n\tsetSelected: function(selected) {\r\n\t\tthis.getPoint1().setSelected(selected);\r\n\t\tthis.getHandle1().setSelected(selected);\r\n\t\tthis.getHandle2().setSelected(selected);\r\n\t\tthis.getPoint2().setSelected(selected);\r\n\t},\r\n\r\n\tgetValues: function(matrix) {\r\n\t\treturn Curve.getValues(this._segment1, this._segment2, matrix);\r\n\t},\r\n\r\n\tgetPoints: function() {\r\n\t\tvar coords = this.getValues(),\r\n\t\t\tpoints = [];\r\n\t\tfor (var i = 0; i < 8; i += 2)\r\n\t\t\tpoints.push(new Point(coords[i], coords[i + 1]));\r\n\t\treturn points;\r\n\t},\r\n\r\n\tgetLength: function() {\r\n\t\tif (this._length == null)\r\n\t\t\tthis._length = Curve.getLength(this.getValues(), 0, 1);\r\n\t\treturn this._length;\r\n\t},\r\n\r\n\tgetArea: function() {\r\n\t\treturn Curve.getArea(this.getValues());\r\n\t},\r\n\r\n\tgetLine: function() {\r\n\t\treturn new Line(this._segment1._point, this._segment2._point);\r\n\t},\r\n\r\n\tgetPart: function(from, to) {\r\n\t\treturn new Curve(Curve.getPart(this.getValues(), from, to));\r\n\t},\r\n\r\n\tgetPartLength: function(from, to) {\r\n\t\treturn Curve.getLength(this.getValues(), from, to);\r\n\t},\r\n\r\n\tgetIntersections: function(curve) {\r\n\t\treturn Curve._getIntersections(this.getValues(),\r\n\t\t\t\tcurve && curve !== this ? curve.getValues() : null,\r\n\t\t\t\tthis, curve, [], {});\r\n\t},\r\n\r\n\t_getParameter: function(offset, isParameter) {\r\n\t\treturn isParameter\r\n\t\t\t\t? offset\r\n\t\t\t\t: offset && offset.curve === this\r\n\t\t\t\t\t? offset.parameter\r\n\t\t\t\t\t: offset === undefined && isParameter === undefined\r\n\t\t\t\t\t\t? 0.5\r\n\t\t\t\t\t\t: this.getParameterAt(offset, 0);\r\n\t},\r\n\r\n\tdivide: function(offset, isParameter, _setHandles) {\r\n\t\tvar parameter = this._getParameter(offset, isParameter),\r\n\t\t\ttMin = 4e-7,\r\n\t\t\ttMax = 1 - tMin,\r\n\t\t\tres = null;\r\n\t\tif (parameter >= tMin && parameter <= tMax) {\r\n\t\t\tvar parts = Curve.subdivide(this.getValues(), parameter),\r\n\t\t\t\tleft = parts[0],\r\n\t\t\t\tright = parts[1],\r\n\t\t\t\tsetHandles = _setHandles || this.hasHandles(),\r\n\t\t\t\tsegment1 = this._segment1,\r\n\t\t\t\tsegment2 = this._segment2,\r\n\t\t\t\tpath = this._path;\r\n\t\t\tif (setHandles) {\r\n\t\t\t\tsegment1._handleOut.set(left[2] - left[0],\r\n\t\t\t\t\t\tleft[3] - left[1]);\r\n\t\t\t\tsegment2._handleIn.set(right[4] - right[6],\r\n\t\t\t\t\t\tright[5] - right[7]);\r\n\t\t\t}\r\n\t\t\tvar x = left[6], y = left[7],\r\n\t\t\t\tsegment = new Segment(new Point(x, y),\r\n\t\t\t\t\t\tsetHandles && new Point(left[4] - x, left[5] - y),\r\n\t\t\t\t\t\tsetHandles && new Point(right[2] - x, right[3] - y));\r\n\t\t\tif (path) {\r\n\t\t\t\tpath.insert(segment1._index + 1, segment);\r\n\t\t\t\tres = this.getNext();\r\n\t\t\t} else {\r\n\t\t\t\tthis._segment2 = segment;\r\n\t\t\t\tres = new Curve(segment, segment2);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn res;\r\n\t},\r\n\r\n\tsplit: function(offset, isParameter) {\r\n\t\treturn this._path\r\n\t\t\t? this._path.split(this._segment1._index,\r\n\t\t\t\t\tthis._getParameter(offset, isParameter))\r\n\t\t\t: null;\r\n\t},\r\n\r\n\treversed: function() {\r\n\t\treturn new Curve(this._segment2.reversed(), this._segment1.reversed());\r\n\t},\r\n\r\n\tclearHandles: function() {\r\n\t\tthis._segment1._handleOut.set(0, 0);\r\n\t\tthis._segment2._handleIn.set(0, 0);\r\n\t},\r\n\r\nstatics: {\r\n\tgetValues: function(segment1, segment2, matrix) {\r\n\t\tvar p1 = segment1._point,\r\n\t\t\th1 = segment1._handleOut,\r\n\t\t\th2 = segment2._handleIn,\r\n\t\t\tp2 = segment2._point,\r\n\t\t\tvalues = [\r\n\t\t\t\tp1._x, p1._y,\r\n\t\t\t\tp1._x + h1._x, p1._y + h1._y,\r\n\t\t\t\tp2._x + h2._x, p2._y + h2._y,\r\n\t\t\t\tp2._x, p2._y\r\n\t\t\t];\r\n\t\tif (matrix)\r\n\t\t\tmatrix._transformCoordinates(values, values, 4);\r\n\t\treturn values;\r\n\t},\r\n\r\n\tsubdivide: function(v, t) {\r\n\t\tvar p1x = v[0], p1y = v[1],\r\n\t\t\tc1x = v[2], c1y = v[3],\r\n\t\t\tc2x = v[4], c2y = v[5],\r\n\t\t\tp2x = v[6], p2y = v[7];\r\n\t\tif (t === undefined)\r\n\t\t\tt = 0.5;\r\n\t\tvar u = 1 - t,\r\n\t\t\tp3x = u * p1x + t * c1x, p3y = u * p1y + t * c1y,\r\n\t\t\tp4x = u * c1x + t * c2x, p4y = u * c1y + t * c2y,\r\n\t\t\tp5x = u * c2x + t * p2x, p5y = u * c2y + t * p2y,\r\n\t\t\tp6x = u * p3x + t * p4x, p6y = u * p3y + t * p4y,\r\n\t\t\tp7x = u * p4x + t * p5x, p7y = u * p4y + t * p5y,\r\n\t\t\tp8x = u * p6x + t * p7x, p8y = u * p6y + t * p7y;\r\n\t\treturn [\r\n\t\t\t[p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y],\r\n\t\t\t[p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y]\r\n\t\t];\r\n\t},\r\n\r\n\tsolveCubic: function (v, coord, val, roots, min, max) {\r\n\t\tvar p1 = v[coord],\r\n\t\t\tc1 = v[coord + 2],\r\n\t\t\tc2 = v[coord + 4],\r\n\t\t\tp2 = v[coord + 6],\r\n\t\t\tc = 3 * (c1 - p1),\r\n\t\t\tb = 3 * (c2 - c1) - c,\r\n\t\t\ta = p2 - p1 - c - b;\r\n\t\treturn Numerical.solveCubic(a, b, c, p1 - val, roots, min, max);\r\n\t},\r\n\r\n\tgetParameterOf: function(v, point) {\r\n\t\tvar p1 = new Point(v[0], v[1]),\r\n\t\t\tp2 = new Point(v[6], v[7]),\r\n\t\t\tepsilon = 1e-12,\r\n\t\t\tt = point.isClose(p1, epsilon) ? 0\r\n\t\t\t  : point.isClose(p2, epsilon) ? 1\r\n\t\t\t  : null;\r\n\t\tif (t !== null)\r\n\t\t\treturn t;\r\n\t\tvar coords = [point.x, point.y],\r\n\t\t\troots = [],\r\n\t\t\tgeomEpsilon = 2e-7;\r\n\t\tfor (var c = 0; c < 2; c++) {\r\n\t\t\tvar count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);\r\n\t\t\tfor (var i = 0; i < count; i++) {\r\n\t\t\t\tt = roots[i];\r\n\t\t\t\tif (point.isClose(Curve.getPoint(v, t), geomEpsilon))\r\n\t\t\t\t\treturn t;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn point.isClose(p1, geomEpsilon) ? 0\r\n\t\t\t : point.isClose(p2, geomEpsilon) ? 1\r\n\t\t\t : null;\r\n\t},\r\n\r\n\tgetNearestParameter: function(v, point) {\r\n\t\tif (Curve.isStraight(v)) {\r\n\t\t\tvar p1x = v[0], p1y = v[1],\r\n\t\t\t\tp2x = v[6], p2y = v[7],\r\n\t\t\t\tvx = p2x - p1x, vy = p2y - p1y,\r\n\t\t\t\tdet = vx * vx + vy * vy;\r\n\t\t\tif (det === 0)\r\n\t\t\t\treturn 0;\r\n\t\t\tvar u = ((point.x - p1x) * vx + (point.y - p1y) * vy) / det;\r\n\t\t\treturn u < 1e-12 ? 0\r\n\t\t\t\t : u > 0.999999999999 ? 1\r\n\t\t\t\t : Curve.getParameterOf(v,\r\n\t\t\t\t\tnew Point(p1x + u * vx, p1y + u * vy));\r\n\t\t}\r\n\r\n\t\tvar count = 100,\r\n\t\t\tminDist = Infinity,\r\n\t\t\tminT = 0;\r\n\r\n\t\tfunction refine(t) {\r\n\t\t\tif (t >= 0 && t <= 1) {\r\n\t\t\t\tvar dist = point.getDistance(Curve.getPoint(v, t), true);\r\n\t\t\t\tif (dist < minDist) {\r\n\t\t\t\t\tminDist = dist;\r\n\t\t\t\t\tminT = t;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i <= count; i++)\r\n\t\t\trefine(i / count);\r\n\r\n\t\tvar step = 1 / (count * 2);\r\n\t\twhile (step > 4e-7) {\r\n\t\t\tif (!refine(minT - step) && !refine(minT + step))\r\n\t\t\t\tstep /= 2;\r\n\t\t}\r\n\t\treturn minT;\r\n\t},\r\n\r\n\tgetPart: function(v, from, to) {\r\n\t\tvar flip = from > to;\r\n\t\tif (flip) {\r\n\t\t\tvar tmp = from;\r\n\t\t\tfrom = to;\r\n\t\t\tto = tmp;\r\n\t\t}\r\n\t\tif (from > 0)\r\n\t\t\tv = Curve.subdivide(v, from)[1];\r\n\t\tif (to < 1)\r\n\t\t\tv = Curve.subdivide(v, (to - from) / (1 - from))[0];\r\n\t\treturn flip\r\n\t\t\t\t? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]\r\n\t\t\t\t: v;\r\n\t},\r\n\r\n\thasHandles: function(v) {\r\n\t\tvar isZero = Numerical.isZero;\r\n\t\treturn !(isZero(v[0] - v[2]) && isZero(v[1] - v[3])\r\n\t\t\t\t&& isZero(v[4] - v[6]) && isZero(v[5] - v[7]));\r\n\t},\r\n\r\n\tisFlatEnough: function(v, tolerance) {\r\n\t\tvar p1x = v[0], p1y = v[1],\r\n\t\t\tc1x = v[2], c1y = v[3],\r\n\t\t\tc2x = v[4], c2y = v[5],\r\n\t\t\tp2x = v[6], p2y = v[7],\r\n\t\t\tux = 3 * c1x - 2 * p1x - p2x,\r\n\t\t\tuy = 3 * c1y - 2 * p1y - p2y,\r\n\t\t\tvx = 3 * c2x - 2 * p2x - p1x,\r\n\t\t\tvy = 3 * c2y - 2 * p2y - p1y;\r\n\t\treturn Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)\r\n\t\t\t\t< 10 * tolerance * tolerance;\r\n\t},\r\n\r\n\tgetArea: function(v) {\r\n\t\tvar p1x = v[0], p1y = v[1],\r\n\t\t\tp2x = v[6], p2y = v[7],\r\n\t\t\th1x = (v[2] + p1x) / 2,\r\n\t\t\th1y = (v[3] + p1y) / 2,\r\n\t\t\th2x = (v[4] + v[6]) / 2,\r\n\t\t\th2y = (v[5] + v[7]) / 2;\r\n\t\treturn 6 * ((p1x - h1x) * (h1y + p1y)\r\n\t\t\t\t  + (h1x - h2x) * (h2y + h1y)\r\n\t\t\t\t  + (h2x - p2x) * (p2y + h2y)) / 10;\r\n\t},\r\n\r\n\tgetBounds: function(v) {\r\n\t\tvar min = v.slice(0, 2),\r\n\t\t\tmax = min.slice(),\r\n\t\t\troots = [0, 0];\r\n\t\tfor (var i = 0; i < 2; i++)\r\n\t\t\tCurve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],\r\n\t\t\t\t\ti, 0, min, max, roots);\r\n\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\r\n\t},\r\n\r\n\t_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {\r\n\t\tfunction add(value, padding) {\r\n\t\t\tvar left = value - padding,\r\n\t\t\t\tright = value + padding;\r\n\t\t\tif (left < min[coord])\r\n\t\t\t\tmin[coord] = left;\r\n\t\t\tif (right > max[coord])\r\n\t\t\t\tmax[coord] = right;\r\n\t\t}\r\n\t\tvar a = 3 * (v1 - v2) - v0 + v3,\r\n\t\t\tb = 2 * (v0 + v2) - 4 * v1,\r\n\t\t\tc = v1 - v0,\r\n\t\t\tcount = Numerical.solveQuadratic(a, b, c, roots),\r\n\t\t\ttMin = 4e-7,\r\n\t\t\ttMax = 1 - tMin;\r\n\t\tadd(v3, 0);\r\n\t\tfor (var i = 0; i < count; i++) {\r\n\t\t\tvar t = roots[i],\r\n\t\t\t\tu = 1 - t;\r\n\t\t\tif (tMin < t && t < tMax)\r\n\t\t\t\tadd(u * u * u * v0\r\n\t\t\t\t\t+ 3 * u * u * t * v1\r\n\t\t\t\t\t+ 3 * u * t * t * v2\r\n\t\t\t\t\t+ t * t * t * v3,\r\n\t\t\t\t\tpadding);\r\n\t\t}\r\n\t}\r\n}}, Base.each(\r\n\t['getBounds', 'getStrokeBounds', 'getHandleBounds', 'getRoughBounds'],\r\n\tfunction(name) {\r\n\t\tthis[name] = function() {\r\n\t\t\tif (!this._bounds)\r\n\t\t\t\tthis._bounds = {};\r\n\t\t\tvar bounds = this._bounds[name];\r\n\t\t\tif (!bounds) {\r\n\t\t\t\tvar path = this._path;\r\n\t\t\t\tbounds = this._bounds[name] = Path[name](\r\n\t\t\t\t\t\t[this._segment1, this._segment2], false,\r\n\t\t\t\t\t\tpath && path.getStyle());\r\n\t\t\t}\r\n\t\t\treturn bounds.clone();\r\n\t\t};\r\n\t},\r\n{\r\n\r\n}), Base.each({\r\n\tisStraight: function(l, h1, h2) {\r\n\t\tif (h1.isZero() && h2.isZero()) {\r\n\t\t\treturn true;\r\n\t\t} else if (l.isZero()) {\r\n\t\t\treturn false;\r\n\t\t} else if (h1.isCollinear(l) && h2.isCollinear(l)) {\r\n\t\t\tvar div = l.dot(l),\r\n\t\t\t\tp1 = l.dot(h1) / div,\r\n\t\t\t\tp2 = l.dot(h2) / div;\r\n\t\t\treturn p1 >= 0 && p1 <= 1 && p2 <= 0 && p2 >= -1;\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tisLinear: function(l, h1, h2) {\r\n\t\tvar third = l.divide(3);\r\n\t\treturn h1.equals(third) && h2.negate().equals(third);\r\n\t}\r\n}, function(test, name) {\r\n\tthis[name] = function() {\r\n\t\tvar seg1 = this._segment1,\r\n\t\t\tseg2 = this._segment2;\r\n\t\treturn test(seg2._point.subtract(seg1._point),\r\n\t\t\t\tseg1._handleOut, seg2._handleIn);\r\n\t};\r\n\r\n\tthis.statics[name] = function(v) {\r\n\t\tvar p1x = v[0], p1y = v[1],\r\n\t\t\tp2x = v[6], p2y = v[7];\r\n\t\treturn test(new Point(p2x - p1x, p2y - p1y),\r\n\t\t\t\tnew Point(v[2] - p1x, v[3] - p1y),\r\n\t\t\t\tnew Point(v[4] - p2x, v[5] - p2y));\r\n\t};\r\n}, {\r\n\tstatics: {},\r\n\r\n\thasHandles: function() {\r\n\t\treturn !this._segment1._handleOut.isZero()\r\n\t\t\t\t|| !this._segment2._handleIn.isZero();\r\n\t},\r\n\r\n\tisCollinear: function(curve) {\r\n\t\treturn curve && this.isStraight() && curve.isStraight()\r\n\t\t\t\t&& this.getLine().isCollinear(curve.getLine());\r\n\t},\r\n\r\n\tisHorizontal: function() {\r\n\t\treturn this.isStraight() && Math.abs(this.getTangentAt(0.5, true).y)\r\n\t\t\t\t< 1e-7;\r\n\t},\r\n\r\n\tisVertical: function() {\r\n\t\treturn this.isStraight() && Math.abs(this.getTangentAt(0.5, true).x)\r\n\t\t\t\t< 1e-7;\r\n\t}\r\n}), {\r\n\tbeans: false,\r\n\r\n\tgetParameterAt: function(offset, start) {\r\n\t\treturn Curve.getParameterAt(this.getValues(), offset, start);\r\n\t},\r\n\r\n\tgetParameterOf: function() {\r\n\t\treturn Curve.getParameterOf(this.getValues(), Point.read(arguments));\r\n\t},\r\n\r\n\tgetLocationAt: function(offset, isParameter) {\r\n\t\tvar t = isParameter ? offset : this.getParameterAt(offset);\r\n\t\treturn t != null && t >= 0 && t <= 1\r\n\t\t\t\t? new CurveLocation(this, t)\r\n\t\t\t\t: null;\r\n\t},\r\n\r\n\tgetLocationOf: function() {\r\n\t\treturn this.getLocationAt(this.getParameterOf(Point.read(arguments)),\r\n\t\t\t\ttrue);\r\n\t},\r\n\r\n\tgetOffsetOf: function() {\r\n\t\tvar loc = this.getLocationOf.apply(this, arguments);\r\n\t\treturn loc ? loc.getOffset() : null;\r\n\t},\r\n\r\n\tgetNearestLocation: function() {\r\n\t\tvar point = Point.read(arguments),\r\n\t\t\tvalues = this.getValues(),\r\n\t\t\tt = Curve.getNearestParameter(values, point),\r\n\t\t\tpt = Curve.getPoint(values, t);\r\n\t\treturn new CurveLocation(this, t, pt, null, point.getDistance(pt));\r\n\t},\r\n\r\n\tgetNearestPoint: function() {\r\n\t\treturn this.getNearestLocation.apply(this, arguments).getPoint();\r\n\t}\r\n\r\n},\r\nnew function() {\r\n\tvar methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',\r\n\t\t'getWeightedNormal', 'getCurvature'];\r\n\treturn Base.each(methods,\r\n\tfunction(name) {\r\n\t\tthis[name + 'At'] = function(offset, isParameter) {\r\n\t\t\tvar values = this.getValues();\r\n\t\t\treturn Curve[name](values, isParameter ? offset\r\n\t\t\t\t\t: Curve.getParameterAt(values, offset, 0));\r\n\t\t};\r\n\t}, {\r\n\t\tstatics: {\r\n\t\t\tevaluateMethods: methods\r\n\t\t}\r\n\t})\r\n},\r\nnew function() {\r\n\r\n\tfunction getLengthIntegrand(v) {\r\n\t\tvar p1x = v[0], p1y = v[1],\r\n\t\t\tc1x = v[2], c1y = v[3],\r\n\t\t\tc2x = v[4], c2y = v[5],\r\n\t\t\tp2x = v[6], p2y = v[7],\r\n\r\n\t\t\tax = 9 * (c1x - c2x) + 3 * (p2x - p1x),\r\n\t\t\tbx = 6 * (p1x + c2x) - 12 * c1x,\r\n\t\t\tcx = 3 * (c1x - p1x),\r\n\r\n\t\t\tay = 9 * (c1y - c2y) + 3 * (p2y - p1y),\r\n\t\t\tby = 6 * (p1y + c2y) - 12 * c1y,\r\n\t\t\tcy = 3 * (c1y - p1y);\r\n\r\n\t\treturn function(t) {\r\n\t\t\tvar dx = (ax * t + bx) * t + cx,\r\n\t\t\t\tdy = (ay * t + by) * t + cy;\r\n\t\t\treturn Math.sqrt(dx * dx + dy * dy);\r\n\t\t};\r\n\t}\r\n\r\n\tfunction getIterations(a, b) {\r\n\t\treturn Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));\r\n\t}\r\n\r\n\tfunction evaluate(v, t, type, normalized) {\r\n\t\tif (t == null || t < 0 || t > 1)\r\n\t\t\treturn null;\r\n\t\tvar p1x = v[0], p1y = v[1],\r\n\t\t\tc1x = v[2], c1y = v[3],\r\n\t\t\tc2x = v[4], c2y = v[5],\r\n\t\t\tp2x = v[6], p2y = v[7],\r\n\t\t\ttMin = 4e-7,\r\n\t\t\ttMax = 1 - tMin,\r\n\t\t\tx, y;\r\n\r\n\t\tif (type === 0 && (t < tMin || t > tMax)) {\r\n\t\t\tvar isZero = t < tMin;\r\n\t\t\tx = isZero ? p1x : p2x;\r\n\t\t\ty = isZero ? p1y : p2y;\r\n\t\t} else {\r\n\t\t\tvar cx = 3 * (c1x - p1x),\r\n\t\t\t\tbx = 3 * (c2x - c1x) - cx,\r\n\t\t\t\tax = p2x - p1x - cx - bx,\r\n\r\n\t\t\t\tcy = 3 * (c1y - p1y),\r\n\t\t\t\tby = 3 * (c2y - c1y) - cy,\r\n\t\t\t\tay = p2y - p1y - cy - by;\r\n\t\t\tif (type === 0) {\r\n\t\t\t\tx = ((ax * t + bx) * t + cx) * t + p1x;\r\n\t\t\t\ty = ((ay * t + by) * t + cy) * t + p1y;\r\n\t\t\t} else {\r\n\t\t\t\tif (t < tMin) {\r\n\t\t\t\t\tx = cx;\r\n\t\t\t\t\ty = cy;\r\n\t\t\t\t} else if (t > tMax) {\r\n\t\t\t\t\tx = 3 * (p2x - c2x);\r\n\t\t\t\t\ty = 3 * (p2y - c2y);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tx = (3 * ax * t + 2 * bx) * t + cx;\r\n\t\t\t\t\ty = (3 * ay * t + 2 * by) * t + cy;\r\n\t\t\t\t}\r\n\t\t\t\tif (normalized) {\r\n\t\t\t\t\tif (x === 0 && y === 0 && (t < tMin || t > tMax)) {\r\n\t\t\t\t\t\tx = c2x - c1x;\r\n\t\t\t\t\t\ty = c2y - c1y;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar len = Math.sqrt(x * x + y * y);\r\n\t\t\t\t\tif (len) {\r\n\t\t\t\t\t\tx /= len;\r\n\t\t\t\t\t\ty /= len;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (type === 3) {\r\n\t\t\t\t\tvar x2 = 6 * ax * t + 2 * bx,\r\n\t\t\t\t\t\ty2 = 6 * ay * t + 2 * by,\r\n\t\t\t\t\t\td = Math.pow(x * x + y * y, 3 / 2);\r\n\t\t\t\t\tx = d !== 0 ? (x * y2 - y * x2) / d : 0;\r\n\t\t\t\t\ty = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn type === 2 ? new Point(y, -x) : new Point(x, y);\r\n\t}\r\n\r\n\treturn { statics: {\r\n\r\n\t\tgetLength: function(v, a, b) {\r\n\t\t\tif (a === undefined)\r\n\t\t\t\ta = 0;\r\n\t\t\tif (b === undefined)\r\n\t\t\t\tb = 1;\r\n\t\t\tif (a === 0 && b === 1 && Curve.isStraight(v)) {\r\n\t\t\t\tvar dx = v[6] - v[0],\r\n\t\t\t\t\tdy = v[7] - v[1];\r\n\t\t\t\treturn Math.sqrt(dx * dx + dy * dy);\r\n\t\t\t}\r\n\t\t\tvar ds = getLengthIntegrand(v);\r\n\t\t\treturn Numerical.integrate(ds, a, b, getIterations(a, b));\r\n\t\t},\r\n\r\n\t\tgetParameterAt: function(v, offset, start) {\r\n\t\t\tif (start === undefined)\r\n\t\t\t\tstart = offset < 0 ? 1 : 0\r\n\t\t\tif (offset === 0)\r\n\t\t\t\treturn start;\r\n\t\t\tvar abs = Math.abs,\r\n\t\t\t\tforward = offset > 0,\r\n\t\t\t\ta = forward ? start : 0,\r\n\t\t\t\tb = forward ? 1 : start,\r\n\t\t\t\tds = getLengthIntegrand(v),\r\n\t\t\t\trangeLength = Numerical.integrate(ds, a, b,\r\n\t\t\t\t\t\tgetIterations(a, b));\r\n\t\t\tif (abs(offset - rangeLength) < 1e-12) {\r\n\t\t\t\treturn forward ? b : a;\r\n\t\t\t} else if (abs(offset) > rangeLength) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tvar guess = offset / rangeLength,\r\n\t\t\t\tlength = 0;\r\n\t\t\tfunction f(t) {\r\n\t\t\t\tlength += Numerical.integrate(ds, start, t,\r\n\t\t\t\t\t\tgetIterations(start, t));\r\n\t\t\t\tstart = t;\r\n\t\t\t\treturn length - offset;\r\n\t\t\t}\r\n\t\t\treturn Numerical.findRoot(f, ds, start + guess, a, b, 32,\r\n\t\t\t\t\t1e-12);\r\n\t\t},\r\n\r\n\t\tgetPoint: function(v, t) {\r\n\t\t\treturn evaluate(v, t, 0, false);\r\n\t\t},\r\n\r\n\t\tgetTangent: function(v, t) {\r\n\t\t\treturn evaluate(v, t, 1, true);\r\n\t\t},\r\n\r\n\t\tgetWeightedTangent: function(v, t) {\r\n\t\t\treturn evaluate(v, t, 1, false);\r\n\t\t},\r\n\r\n\t\tgetNormal: function(v, t) {\r\n\t\t\treturn evaluate(v, t, 2, true);\r\n\t\t},\r\n\r\n\t\tgetWeightedNormal: function(v, t) {\r\n\t\t\treturn evaluate(v, t, 2, false);\r\n\t\t},\r\n\r\n\t\tgetCurvature: function(v, t) {\r\n\t\t\treturn evaluate(v, t, 3, false).x;\r\n\t\t}\r\n\t}};\r\n},\r\nnew function() {\r\n\r\n\tfunction addLocation(locations, param, v1, c1, t1, p1, v2, c2, t2, p2,\r\n\t\t\toverlap) {\r\n\t\tvar startConnected = param.startConnected,\r\n\t\t\tendConnected = param.endConnected,\r\n\t\t\ttMin = 4e-7,\r\n\t\t\ttMax = 1 - tMin;\r\n\t\tif (t1 == null)\r\n\t\t\tt1 = Curve.getParameterOf(v1, p1);\r\n\t\tif (t1 !== null && t1 >= (startConnected ? tMin : 0) &&\r\n\t\t\tt1 <= (endConnected ? tMax : 1)) {\r\n\t\t\tif (t2 == null)\r\n\t\t\t\tt2 = Curve.getParameterOf(v2, p2);\r\n\t\t\tif (t2 !== null && t2 >= (endConnected ? tMin : 0) &&\r\n\t\t\t\tt2 <= (startConnected ? tMax : 1)) {\r\n\t\t\t\tvar renormalize = param.renormalize;\r\n\t\t\t\tif (renormalize) {\r\n\t\t\t\t\tvar res = renormalize(t1, t2);\r\n\t\t\t\t\tt1 = res[0];\r\n\t\t\t\t\tt2 = res[1];\r\n\t\t\t\t}\r\n\t\t\t\tvar loc1 = new CurveLocation(c1, t1,\r\n\t\t\t\t\t\tp1 || Curve.getPoint(v1, t1), overlap),\r\n\t\t\t\t\tloc2 = new CurveLocation(c2, t2,\r\n\t\t\t\t\t\tp2 || Curve.getPoint(v2, t2), overlap),\r\n\t\t\t\t\tflip = loc1.getPath() === loc2.getPath()\r\n\t\t\t\t\t\t&& loc1.getIndex() > loc2.getIndex(),\r\n\t\t\t\t\tloc = flip ? loc2 : loc1,\r\n\t\t\t\t\tinclude = param.include;\r\n\t\t\t\tloc1._intersection = loc2;\r\n\t\t\t\tloc2._intersection = loc1;\r\n\t\t\t\tif (!include || include(loc)) {\r\n\t\t\t\t\tCurveLocation.insert(locations, loc, true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction addCurveIntersections(v1, v2, c1, c2, locations, param,\r\n\t\t\ttMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {\r\n\t\tif (++recursion >= 24)\r\n\t\t\treturn;\r\n\t\tvar q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],\r\n\t\t\tgetSignedDistance = Line.getSignedDistance,\r\n\t\t\td1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),\r\n\t\t\td2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),\r\n\t\t\tfactor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,\r\n\t\t\tdMin = factor * Math.min(0, d1, d2),\r\n\t\t\tdMax = factor * Math.max(0, d1, d2),\r\n\t\t\tdp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),\r\n\t\t\tdp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),\r\n\t\t\tdp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),\r\n\t\t\tdp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),\r\n\t\t\thull = getConvexHull(dp0, dp1, dp2, dp3),\r\n\t\t\ttop = hull[0],\r\n\t\t\tbottom = hull[1],\r\n\t\t\ttMinClip,\r\n\t\t\ttMaxClip;\r\n\t\tif ((tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null ||\r\n\t\t\t(tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),\r\n\t\t\t\tdMin, dMax)) == null)\r\n\t\t\treturn;\r\n\t\tv1 = Curve.getPart(v1, tMinClip, tMaxClip);\r\n\t\tvar tDiff = tMaxClip - tMinClip,\r\n\t\t\ttMinNew = tMin + (tMax - tMin) * tMinClip,\r\n\t\t\ttMaxNew = tMin + (tMax - tMin) * tMaxClip;\r\n\t\tif (oldTDiff > 0.5 && tDiff > 0.5) {\r\n\t\t\tif (tMaxNew - tMinNew > uMax - uMin) {\r\n\t\t\t\tvar parts = Curve.subdivide(v1, 0.5),\r\n\t\t\t\t\tt = tMinNew + (tMaxNew - tMinNew) / 2;\r\n\t\t\t\taddCurveIntersections(\r\n\t\t\t\t\tv2, parts[0], c2, c1, locations, param,\r\n\t\t\t\t\tuMin, uMax, tMinNew, t, tDiff, !reverse, recursion);\r\n\t\t\t\taddCurveIntersections(\r\n\t\t\t\t\tv2, parts[1], c2, c1, locations, param,\r\n\t\t\t\t\tuMin, uMax, t, tMaxNew, tDiff, !reverse, recursion);\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = Curve.subdivide(v2, 0.5),\r\n\t\t\t\t\tt = uMin + (uMax - uMin) / 2;\r\n\t\t\t\taddCurveIntersections(\r\n\t\t\t\t\tparts[0], v1, c2, c1, locations, param,\r\n\t\t\t\t\tuMin, t, tMinNew, tMaxNew, tDiff, !reverse, recursion);\r\n\t\t\t\taddCurveIntersections(\r\n\t\t\t\t\tparts[1], v1, c2, c1, locations, param,\r\n\t\t\t\t\tt, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);\r\n\t\t\t}\r\n\t\t} else if (Math.max(uMax - uMin, tMaxNew - tMinNew)\r\n\t\t\t\t< 1e-7) {\r\n\t\t\tvar t1 = tMinNew + (tMaxNew - tMinNew) / 2,\r\n\t\t\t\tt2 = uMin + (uMax - uMin) / 2;\r\n\t\t\tv1 = c1.getValues();\r\n\t\t\tv2 = c2.getValues();\r\n\t\t\taddLocation(locations, param,\r\n\t\t\t\treverse ? v2 : v1, reverse ? c2 : c1, reverse ? t2 : t1, null,\r\n\t\t\t\treverse ? v1 : v2, reverse ? c1 : c2, reverse ? t1 : t2, null);\r\n\t\t} else if (tDiff > 1e-12) {\r\n\t\t\taddCurveIntersections(v2, v1, c2, c1, locations, param,\r\n\t\t\t\t\tuMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getConvexHull(dq0, dq1, dq2, dq3) {\r\n\t\tvar p0 = [ 0, dq0 ],\r\n\t\t\tp1 = [ 1 / 3, dq1 ],\r\n\t\t\tp2 = [ 2 / 3, dq2 ],\r\n\t\t\tp3 = [ 1, dq3 ],\r\n\t\t\tdist1 = dq1 - (2 * dq0 + dq3) / 3,\r\n\t\t\tdist2 = dq2 - (dq0 + 2 * dq3) / 3,\r\n\t\t\thull;\r\n\t\tif (dist1 * dist2 < 0) {\r\n\t\t\thull = [[p0, p1, p3], [p0, p2, p3]];\r\n\t\t} else {\r\n\t\t\tvar distRatio = dist1 / dist2;\r\n\t\t\thull = [\r\n\t\t\t\tdistRatio >= 2 ? [p0, p1, p3]\r\n\t\t\t\t: distRatio <= .5 ? [p0, p2, p3]\r\n\t\t\t\t: [p0, p1, p2, p3],\r\n\t\t\t\t[p0, p3]\r\n\t\t\t];\r\n\t\t}\r\n\t\treturn (dist1 || dist2) < 0 ? hull.reverse() : hull;\r\n\t}\r\n\r\n\tfunction clipConvexHull(hullTop, hullBottom, dMin, dMax) {\r\n\t\tif (hullTop[0][1] < dMin) {\r\n\t\t\treturn clipConvexHullPart(hullTop, true, dMin);\r\n\t\t} else if (hullBottom[0][1] > dMax) {\r\n\t\t\treturn clipConvexHullPart(hullBottom, false, dMax);\r\n\t\t} else {\r\n\t\t\treturn hullTop[0][0];\r\n\t\t}\r\n\t}\r\n\r\n\tfunction clipConvexHullPart(part, top, threshold) {\r\n\t\tvar px = part[0][0],\r\n\t\t\tpy = part[0][1];\r\n\t\tfor (var i = 1, l = part.length; i < l; i++) {\r\n\t\t\tvar qx = part[i][0],\r\n\t\t\t\tqy = part[i][1];\r\n\t\t\tif (top ? qy >= threshold : qy <= threshold) {\r\n\t\t\t\treturn qy === threshold ? qx\r\n\t\t\t\t\t\t: px + (threshold - py) * (qx - px) / (qy - py);\r\n\t\t\t}\r\n\t\t\tpx = qx;\r\n\t\t\tpy = qy;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tfunction addCurveLineIntersections(v1, v2, c1, c2, locations, param) {\r\n\t\tvar flip = Curve.isStraight(v1),\r\n\t\t\tvc = flip ? v2 : v1,\r\n\t\t\tvl = flip ? v1 : v2,\r\n\t\t\tlx1 = vl[0], ly1 = vl[1],\r\n\t\t\tlx2 = vl[6], ly2 = vl[7],\r\n\t\t\tldx = lx2 - lx1,\r\n\t\t\tldy = ly2 - ly1,\r\n\t\t\tangle = Math.atan2(-ldy, ldx),\r\n\t\t\tsin = Math.sin(angle),\r\n\t\t\tcos = Math.cos(angle),\r\n\t\t\trvc = [];\r\n\t\tfor(var i = 0; i < 8; i += 2) {\r\n\t\t\tvar x = vc[i] - lx1,\r\n\t\t\t\ty = vc[i + 1] - ly1;\r\n\t\t\trvc.push(\r\n\t\t\t\tx * cos - y * sin,\r\n\t\t\t\tx * sin + y * cos);\r\n\t\t}\r\n\t\tvar roots = [],\r\n\t\t\tcount = Curve.solveCubic(rvc, 1, 0, roots, 0, 1);\r\n\t\tfor (var i = 0; i < count; i++) {\r\n\t\t\tvar tc = roots[i],\r\n\t\t\t\tpc = Curve.getPoint(vc, tc),\r\n\t\t\t\ttl = Curve.getParameterOf(vl, pc);\r\n\t\t\tif (tl !== null) {\r\n\t\t\t\tvar pl = Curve.getPoint(vl, tl),\r\n\t\t\t\t\tt1 = flip ? tl : tc,\r\n\t\t\t\t\tt2 = flip ? tc : tl;\r\n\t\t\t\tif (!param.endConnected || t2 > Numerical.CURVETIME_EPSILON) {\r\n\t\t\t\t\taddLocation(locations, param,\r\n\t\t\t\t\t\t\tv1, c1, t1, flip ? pl : pc,\r\n\t\t\t\t\t\t\tv2, c2, t2, flip ? pc : pl);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction addLineIntersection(v1, v2, c1, c2, locations, param) {\r\n\t\tvar pt = Line.intersect(\r\n\t\t\t\tv1[0], v1[1], v1[6], v1[7],\r\n\t\t\t\tv2[0], v2[1], v2[6], v2[7]);\r\n\t\tif (pt) {\r\n\t\t\taddLocation(locations, param, v1, c1, null, pt, v2, c2, null, pt);\r\n\t\t}\r\n\t}\r\n\r\n\treturn { statics: {\r\n\t\t_getIntersections: function(v1, v2, c1, c2, locations, param) {\r\n\t\t\tif (!v2) {\r\n\t\t\t\treturn Curve._getSelfIntersection(v1, c1, locations, param);\r\n\t\t\t}\r\n\t\t\tvar c1p1x = v1[0], c1p1y = v1[1],\r\n\t\t\t\tc1p2x = v1[6], c1p2y = v1[7],\r\n\t\t\t\tc2p1x = v2[0], c2p1y = v2[1],\r\n\t\t\t\tc2p2x = v2[6], c2p2y = v2[7],\r\n\t\t\t\tc1s1x = (3 * v1[2] + c1p1x) / 4,\r\n\t\t\t\tc1s1y = (3 * v1[3] + c1p1y) / 4,\r\n\t\t\t\tc1s2x = (3 * v1[4] + c1p2x) / 4,\r\n\t\t\t\tc1s2y = (3 * v1[5] + c1p2y) / 4,\r\n\t\t\t\tc2s1x = (3 * v2[2] + c2p1x) / 4,\r\n\t\t\t\tc2s1y = (3 * v2[3] + c2p1y) / 4,\r\n\t\t\t\tc2s2x = (3 * v2[4] + c2p2x) / 4,\r\n\t\t\t\tc2s2y = (3 * v2[5] + c2p2y) / 4,\r\n\t\t\t\tmin = Math.min,\r\n\t\t\t\tmax = Math.max;\r\n\t\t\tif (!(\tmax(c1p1x, c1s1x, c1s2x, c1p2x) >=\r\n\t\t\t\t\tmin(c2p1x, c2s1x, c2s2x, c2p2x) &&\r\n\t\t\t\t\tmin(c1p1x, c1s1x, c1s2x, c1p2x) <=\r\n\t\t\t\t\tmax(c2p1x, c2s1x, c2s2x, c2p2x) &&\r\n\t\t\t\t\tmax(c1p1y, c1s1y, c1s2y, c1p2y) >=\r\n\t\t\t\t\tmin(c2p1y, c2s1y, c2s2y, c2p2y) &&\r\n\t\t\t\t\tmin(c1p1y, c1s1y, c1s2y, c1p2y) <=\r\n\t\t\t\t\tmax(c2p1y, c2s1y, c2s2y, c2p2y)))\r\n\t\t\t\treturn locations;\r\n\t\t\tif (!param.startConnected && !param.endConnected) {\r\n\t\t\t\tvar overlaps = Curve.getOverlaps(v1, v2);\r\n\t\t\t\tif (overlaps) {\r\n\t\t\t\t\tfor (var i = 0; i < 2; i++) {\r\n\t\t\t\t\t\tvar overlap = overlaps[i];\r\n\t\t\t\t\t\taddLocation(locations, param,\r\n\t\t\t\t\t\t\tv1, c1, overlap[0], null,\r\n\t\t\t\t\t\t\tv2, c2, overlap[1], null, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn locations;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar straight1 = Curve.isStraight(v1),\r\n\t\t\t\tstraight2 = Curve.isStraight(v2),\r\n\t\t\t\tstraight = straight1 && straight2,\r\n\t\t\t\tepsilon = 1e-12,\r\n\t\t\t\tbefore = locations.length;\r\n\t\t\t(straight\r\n\t\t\t\t? addLineIntersection\r\n\t\t\t\t: straight1 || straight2\r\n\t\t\t\t\t? addCurveLineIntersections\r\n\t\t\t\t\t: addCurveIntersections)(\r\n\t\t\t\t\t\tv1, v2, c1, c2, locations, param,\r\n\t\t\t\t\t\t0, 1, 0, 1, 0, false, 0);\r\n\t\t\tif (straight && locations.length > before)\r\n\t\t\t\treturn locations;\r\n\t\t\tvar c1p1 = new Point(c1p1x, c1p1y),\r\n\t\t\t\tc1p2 = new Point(c1p2x, c1p2y),\r\n\t\t\t\tc2p1 = new Point(c2p1x, c2p1y),\r\n\t\t\t\tc2p2 = new Point(c2p2x, c2p2y);\r\n\t\t\tif (c1p1.isClose(c2p1, epsilon))\r\n\t\t\t\taddLocation(locations, param, v1, c1, 0, c1p1, v2, c2, 0, c2p1);\r\n\t\t\tif (!param.startConnected && c1p1.isClose(c2p2, epsilon))\r\n\t\t\t\taddLocation(locations, param, v1, c1, 0, c1p1, v2, c2, 1, c2p2);\r\n\t\t\tif (!param.endConnected && c1p2.isClose(c2p1, epsilon))\r\n\t\t\t\taddLocation(locations, param, v1, c1, 1, c1p2, v2, c2, 0, c2p1);\r\n\t\t\tif (c1p2.isClose(c2p2, epsilon))\r\n\t\t\t\taddLocation(locations, param, v1, c1, 1, c1p2, v2, c2, 1, c2p2);\r\n\t\t\treturn locations;\r\n\t\t},\r\n\r\n\t\t_getSelfIntersection: function(v1, c1, locations, param) {\r\n\t\t\tvar p1x = v1[0], p1y = v1[1],\r\n\t\t\t\th1x = v1[2], h1y = v1[3],\r\n\t\t\t\th2x = v1[4], h2y = v1[5],\r\n\t\t\t\tp2x = v1[6], p2y = v1[7];\r\n\t\t\tvar line = new Line(p1x, p1y, p2x, p2y, false),\r\n\t\t\t\tside1 = line.getSide(new Point(h1x, h1y), true),\r\n\t\t\t\tside2 = line.getSide(new Point(h2x, h2y), true);\r\n\t\t\tif (side1 === side2) {\r\n\t\t\t\tvar edgeSum = (p1x - h2x) * (h1y - p2y)\r\n\t\t\t\t\t\t\t+ (h1x - p2x) * (h2y - p1y);\r\n\t\t\t\tif (edgeSum * side1 > 0)\r\n\t\t\t\t\treturn locations;\r\n\t\t\t}\r\n\t\t\tvar ax = p2x - 3 * h2x + 3 * h1x - p1x,\r\n\t\t\t\tbx = h2x - 2 * h1x + p1x,\r\n\t\t\t\tcx = h1x - p1x,\r\n\t\t\t\tay = p2y - 3 * h2y + 3 * h1y - p1y,\r\n\t\t\t\tby = h2y - 2 * h1y + p1y,\r\n\t\t\t\tcy = h1y - p1y,\r\n\t\t\t\tac = ay * cx - ax * cy,\r\n\t\t\t\tab = ay * bx - ax * by,\r\n\t\t\t\tbc = by * cx - bx * cy;\r\n\t\t\tif (ac * ac - 4 * ab * bc < 0) {\r\n\t\t\t\tvar roots = [],\r\n\t\t\t\t\ttSplit,\r\n\t\t\t\t\tcount = Numerical.solveCubic(\r\n\t\t\t\t\t\t\tax * ax\t + ay * ay,\r\n\t\t\t\t\t\t\t3 * (ax * bx + ay * by),\r\n\t\t\t\t\t\t\t2 * (bx * bx + by * by) + ax * cx + ay * cy,\r\n\t\t\t\t\t\t\tbx * cx + by * cy,\r\n\t\t\t\t\t\t\troots, 0, 1);\r\n\t\t\t\tif (count > 0) {\r\n\t\t\t\t\tfor (var i = 0, maxCurvature = 0; i < count; i++) {\r\n\t\t\t\t\t\tvar curvature = Math.abs(\r\n\t\t\t\t\t\t\t\tc1.getCurvatureAt(roots[i], true));\r\n\t\t\t\t\t\tif (curvature > maxCurvature) {\r\n\t\t\t\t\t\t\tmaxCurvature = curvature;\r\n\t\t\t\t\t\t\ttSplit = roots[i];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar parts = Curve.subdivide(v1, tSplit);\r\n\t\t\t\t\tparam.endConnected = true;\r\n\t\t\t\t\tparam.renormalize = function(t1, t2) {\r\n\t\t\t\t\t\treturn [t1 * tSplit, t2 * (1 - tSplit) + tSplit];\r\n\t\t\t\t\t};\r\n\t\t\t\t\tCurve._getIntersections(parts[0], parts[1], c1, c1,\r\n\t\t\t\t\t\t\tlocations, param);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn locations;\r\n\t\t},\r\n\r\n\t\tgetOverlaps: function(v1, v2) {\r\n\t\t\tvar abs = Math.abs,\r\n\t\t\t\ttimeEpsilon = 4e-7,\r\n\t\t\t\tgeomEpsilon = 2e-7,\r\n\t\t\t\tstraight1 = Curve.isStraight(v1),\r\n\t\t\t\tstraight2 = Curve.isStraight(v2),\r\n\t\t\t\tstraight =\tstraight1 && straight2;\r\n\r\n\t\t\tfunction getLineLengthSquared(v) {\r\n\t\t\t\tvar x = v[6] - v[0],\r\n\t\t\t\t\ty = v[7] - v[1];\r\n\t\t\t\treturn x * x + y * y;\r\n\t\t\t}\r\n\r\n\t\t\tif (straight) {\r\n\t\t\t\tvar flip = getLineLengthSquared(v1) < getLineLengthSquared(v2),\r\n\t\t\t\t\tl1 = flip ? v2 : v1,\r\n\t\t\t\t\tl2 = flip ? v1 : v2,\r\n\t\t\t\t\tline = new Line(l1[0], l1[1], l1[6], l1[7]);\r\n\t\t\t\tif (line.getDistance(new Point(l2[0], l2[1])) > geomEpsilon ||\r\n\t\t\t\t\tline.getDistance(new Point(l2[6], l2[7])) > geomEpsilon)\r\n\t\t\t\t\treturn null;\r\n\t\t\t} else if (straight1 ^ straight2) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tvar v = [v1, v2],\r\n\t\t\t\tpairs = [];\r\n\t\t\tfor (var i = 0, t1 = 0;\r\n\t\t\t\t\ti < 2 && pairs.length < 2;\r\n\t\t\t\t\ti += t1 === 0 ? 0 : 1, t1 = t1 ^ 1) {\r\n\t\t\t\tvar t2 = Curve.getParameterOf(v[i ^ 1], new Point(\r\n\t\t\t\t\t\tv[i][t1 === 0 ? 0 : 6],\r\n\t\t\t\t\t\tv[i][t1 === 0 ? 1 : 7]));\r\n\t\t\t\tif (t2 != null) {\r\n\t\t\t\t\tvar pair = i === 0 ? [t1, t2] : [t2, t1];\r\n\t\t\t\t\tif (pairs.length === 0 ||\r\n\t\t\t\t\t\tabs(pair[0] - pairs[0][0]) > timeEpsilon &&\r\n\t\t\t\t\t\tabs(pair[1] - pairs[0][1]) > timeEpsilon)\r\n\t\t\t\t\t\tpairs.push(pair);\r\n\t\t\t\t}\r\n\t\t\t\tif (i === 1 && pairs.length === 0)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (pairs.length !== 2) {\r\n\t\t\t\tpairs = null;\r\n\t\t\t} else if (!straight) {\r\n\t\t\t\tvar o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),\r\n\t\t\t\t\to2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);\r\n\t\t\t\tif (abs(o2[2] - o1[2]) > geomEpsilon ||\r\n\t\t\t\t\tabs(o2[3] - o1[3]) > geomEpsilon ||\r\n\t\t\t\t\tabs(o2[4] - o1[4]) > geomEpsilon ||\r\n\t\t\t\t\tabs(o2[5] - o1[5]) > geomEpsilon)\r\n\t\t\t\t\tpairs = null;\r\n\t\t\t}\r\n\t\t\treturn pairs;\r\n\t\t}\r\n\t}};\r\n});\r\n\r\nvar CurveLocation = Base.extend({\r\n\t_class: 'CurveLocation',\r\n\tbeans: true,\r\n\r\n\tinitialize: function CurveLocation(curve, parameter, point,\r\n\t\t\t_overlap, _distance) {\r\n\t\tif (parameter > 0.9999996) {\r\n\t\t\tvar next = curve.getNext();\r\n\t\t\tif (next) {\r\n\t\t\t\tparameter = 0;\r\n\t\t\t\tcurve = next;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._id = UID.get(CurveLocation);\r\n\t\tthis._setCurve(curve);\r\n\t\tthis._parameter = parameter;\r\n\t\tthis._point = point || curve.getPointAt(parameter, true);\r\n\t\tthis._overlap = _overlap;\r\n\t\tthis._distance = _distance;\r\n\t\tthis._intersection = this._next = this._prev = null;\r\n\t},\r\n\r\n\t_setCurve: function(curve) {\r\n\t\tvar path = curve._path;\r\n\t\tthis._version = path ? path._version : 0;\r\n\t\tthis._curve = curve;\r\n\t\tthis._segment = null;\r\n\t\tthis._segment1 = curve._segment1;\r\n\t\tthis._segment2 = curve._segment2;\r\n\t},\r\n\r\n\t_setSegment: function(segment) {\r\n\t\tthis._setCurve(segment.getCurve());\r\n\t\tthis._segment = segment;\r\n\t\tthis._parameter = segment === this._segment1 ? 0 : 1;\r\n\t\tthis._point = segment._point.clone();\r\n\t},\r\n\r\n\tgetSegment: function() {\r\n\t\tvar curve = this.getCurve(),\r\n\t\t\tsegment = this._segment;\r\n\t\tif (!segment) {\r\n\t\t\tvar parameter = this.getParameter();\r\n\t\t\tif (parameter === 0) {\r\n\t\t\t\tsegment = curve._segment1;\r\n\t\t\t} else if (parameter === 1) {\r\n\t\t\t\tsegment = curve._segment2;\r\n\t\t\t} else if (parameter != null) {\r\n\t\t\t\tsegment = curve.getPartLength(0, parameter)\r\n\t\t\t\t\t< curve.getPartLength(parameter, 1)\r\n\t\t\t\t\t\t? curve._segment1\r\n\t\t\t\t\t\t: curve._segment2;\r\n\t\t\t}\r\n\t\t\tthis._segment = segment;\r\n\t\t}\r\n\t\treturn segment;\r\n\t},\r\n\r\n\tgetCurve: function() {\r\n\t\tvar curve = this._curve,\r\n\t\t\tpath = curve && curve._path,\r\n\t\t\tthat = this;\r\n\t\tif (path && path._version !== this._version) {\r\n\t\t\tcurve = this._parameter = this._curve = this._offset = null;\r\n\t\t}\r\n\r\n\t\tfunction trySegment(segment) {\r\n\t\t\tvar curve = segment && segment.getCurve();\r\n\t\t\tif (curve && (that._parameter = curve.getParameterOf(that._point))\r\n\t\t\t\t\t!= null) {\r\n\t\t\t\tthat._setCurve(curve);\r\n\t\t\t\tthat._segment = segment;\r\n\t\t\t\treturn curve;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn curve\r\n\t\t\t|| trySegment(this._segment)\r\n\t\t\t|| trySegment(this._segment1)\r\n\t\t\t|| trySegment(this._segment2.getPrevious());\r\n\t},\r\n\r\n\tgetPath: function() {\r\n\t\tvar curve = this.getCurve();\r\n\t\treturn curve && curve._path;\r\n\t},\r\n\r\n\tgetIndex: function() {\r\n\t\tvar curve = this.getCurve();\r\n\t\treturn curve && curve.getIndex();\r\n\t},\r\n\r\n\tgetParameter: function() {\r\n\t\tvar curve = this.getCurve(),\r\n\t\t\tparameter = this._parameter;\r\n\t\treturn curve && parameter == null\r\n\t\t\t? this._parameter = curve.getParameterOf(this._point)\r\n\t\t\t: parameter;\r\n\t},\r\n\r\n\tgetPoint: function() {\r\n\t\treturn this._point;\r\n\t},\r\n\r\n\tgetOffset: function() {\r\n\t\tvar offset = this._offset;\r\n\t\tif (offset == null) {\r\n\t\t\toffset = 0;\r\n\t\t\tvar path = this.getPath(),\r\n\t\t\t\tindex = this.getIndex();\r\n\t\t\tif (path && index != null) {\r\n\t\t\t\tvar curves = path.getCurves();\r\n\t\t\t\tfor (var i = 0; i < index; i++)\r\n\t\t\t\t\toffset += curves[i].getLength();\r\n\t\t\t}\r\n\t\t\tthis._offset = offset += this.getCurveOffset();\r\n\t\t}\r\n\t\treturn offset;\r\n\t},\r\n\r\n\tgetCurveOffset: function() {\r\n\t\tvar curve = this.getCurve(),\r\n\t\t\tparameter = this.getParameter();\r\n\t\treturn parameter != null && curve && curve.getPartLength(0, parameter);\r\n\t},\r\n\r\n\tgetIntersection: function() {\r\n\t\treturn this._intersection;\r\n\t},\r\n\r\n\tgetDistance: function() {\r\n\t\treturn this._distance;\r\n\t},\r\n\r\n\tdivide: function() {\r\n\t\tvar curve = this.getCurve(),\r\n\t\t\tres = null;\r\n\t\tif (curve) {\r\n\t\t\tres = curve.divide(this.getParameter(), true);\r\n\t\t\tif (res)\r\n\t\t\t\tthis._setSegment(res._segment1);\r\n\t\t}\r\n\t\treturn res;\r\n\t},\r\n\r\n\tsplit: function() {\r\n\t\tvar curve = this.getCurve();\r\n\t\treturn curve ? curve.split(this.getParameter(), true) : null;\r\n\t},\r\n\r\n\tequals: function(loc, _ignoreOther) {\r\n\t\tvar res = this === loc,\r\n\t\t\tepsilon = 2e-7;\r\n\t\tif (!res && loc instanceof CurveLocation\r\n\t\t\t\t&& this.getPath() === loc.getPath()\r\n\t\t\t\t&& this.getPoint().isClose(loc.getPoint(), epsilon)) {\r\n\t\t\tvar c1 = this.getCurve(),\r\n\t\t\t\tc2 = loc.getCurve(),\r\n\t\t\t\tabs = Math.abs,\r\n\t\t\t\tdiff = abs(\r\n\t\t\t\t\t((c1.isLast() && c2.isFirst() ? -1 : c1.getIndex())\r\n\t\t\t\t\t\t\t+ this.getParameter()) -\r\n\t\t\t\t\t((c2.isLast() && c1.isFirst() ? -1 : c2.getIndex())\r\n\t\t\t\t\t\t\t+ loc.getParameter()));\r\n\t\t\tres = (diff < 4e-7\r\n\t\t\t\t|| ((diff = abs(this.getOffset() - loc.getOffset())) < epsilon\r\n\t\t\t\t\t|| abs(this.getPath().getLength() - diff) < epsilon))\r\n\t\t\t\t&& (_ignoreOther\r\n\t\t\t\t\t|| (!this._intersection && !loc._intersection\r\n\t\t\t\t\t\t|| this._intersection && this._intersection.equals(\r\n\t\t\t\t\t\t\t\tloc._intersection, true)));\r\n\t\t}\r\n\t\treturn res;\r\n\t},\r\n\r\n\ttoString: function() {\r\n\t\tvar parts = [],\r\n\t\t\tpoint = this.getPoint(),\r\n\t\t\tf = Formatter.instance;\r\n\t\tif (point)\r\n\t\t\tparts.push('point: ' + point);\r\n\t\tvar index = this.getIndex();\r\n\t\tif (index != null)\r\n\t\t\tparts.push('index: ' + index);\r\n\t\tvar parameter = this.getParameter();\r\n\t\tif (parameter != null)\r\n\t\t\tparts.push('parameter: ' + f.number(parameter));\r\n\t\tif (this._distance != null)\r\n\t\t\tparts.push('distance: ' + f.number(this._distance));\r\n\t\treturn '{ ' + parts.join(', ') + ' }';\r\n\t},\r\n\r\n\tisTouching: function() {\r\n\t\tvar inter = this._intersection;\r\n\t\tif (inter && this.getTangent().isCollinear(inter.getTangent())) {\r\n\t\t\tvar curve1 = this.getCurve(),\r\n\t\t\t\tcurve2 = inter.getCurve();\r\n\t\t\treturn !(curve1.isStraight() && curve2.isStraight()\r\n\t\t\t\t\t&& curve1.getLine().intersect(curve2.getLine()));\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tisCrossing: function() {\r\n\t\tvar inter = this._intersection;\r\n\t\tif (!inter)\r\n\t\t\treturn false;\r\n\t\tvar t1 = this.getParameter(),\r\n\t\t\tt2 = inter.getParameter(),\r\n\t\t\ttMin = 4e-7,\r\n\t\t\ttMax = 1 - tMin;\r\n\t\tif (t1 >= tMin && t1 <= tMax || t2 >= tMin && t2 <= tMax)\r\n\t\t\treturn !this.isTouching();\r\n\t\tvar c2 = this.getCurve(),\r\n\t\t\tc1 = c2.getPrevious(),\r\n\t\t\tc4 = inter.getCurve(),\r\n\t\t\tc3 = c4.getPrevious(),\r\n\t\t\tPI = Math.PI;\r\n\t\tif (!c1 || !c3)\r\n\t\t\treturn false;\r\n\r\n\t\tfunction isInRange(angle, min, max) {\r\n\t\t\treturn min < max\r\n\t\t\t\t? angle > min && angle < max\r\n\t\t\t\t: angle > min && angle <= PI || angle >= -PI && angle < max;\r\n\t\t}\r\n\r\n\t\tvar a1 = c1.getTangentAt(tMax, true).negate().getAngleInRadians(),\r\n\t\t\ta2 = c2.getTangentAt(tMin, true).getAngleInRadians(),\r\n\t\t\ta3 = c3.getTangentAt(tMax, true).negate().getAngleInRadians(),\r\n\t\t\ta4 = c4.getTangentAt(tMin, true).getAngleInRadians();\r\n\r\n\t\treturn (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2))\r\n\t\t\t&& (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1));\r\n\t},\r\n\r\n\tisOverlap: function() {\r\n\t\treturn !!this._overlap;\r\n\t}\r\n}, Base.each(Curve.evaluateMethods, function(name) {\r\n\tvar get = name + 'At';\r\n\tthis[name] = function() {\r\n\t\tvar parameter = this.getParameter(),\r\n\t\t\tcurve = this.getCurve();\r\n\t\treturn parameter != null && curve && curve[get](parameter, true);\r\n\t};\r\n}, {\r\n\tpreserve: true\r\n}),\r\nnew function() {\r\n\r\n\tfunction insert(locations, loc, merge) {\r\n\t\tvar length = locations.length,\r\n\t\t\tl = 0,\r\n\t\t\tr = length - 1;\r\n\r\n\t\tfunction search(index, dir) {\r\n\t\t\tfor (var i = index + dir; i >= -1 && i <= length; i += dir) {\r\n\t\t\t\tvar loc2 = locations[((i % length) + length) % length];\r\n\t\t\t\tif (!loc.getPoint().isClose(loc2.getPoint(),\r\n\t\t\t\t\t\t2e-7))\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tif (loc.equals(loc2))\r\n\t\t\t\t\treturn loc2;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\twhile (l <= r) {\r\n\t\t\tvar m = (l + r) >>> 1,\r\n\t\t\t\tloc2 = locations[m],\r\n\t\t\t\tfound;\r\n\t\t\tif (merge && (found = loc.equals(loc2) ? loc2\r\n\t\t\t\t\t: (search(m, -1) || search(m, 1)))) {\r\n\t\t\t\tif (loc._overlap) {\r\n\t\t\t\t\tfound._overlap = found._intersection._overlap = true;\r\n\t\t\t\t}\r\n\t\t\t\treturn found;\r\n\t\t\t}\r\n\t\tvar path1 = loc.getPath(),\r\n\t\t\tpath2 = loc2.getPath(),\r\n\t\t\tdiff = path1 === path2\r\n\t\t\t\t? (loc.getIndex() + loc.getParameter())\r\n\t\t\t\t- (loc2.getIndex() + loc2.getParameter())\r\n\t\t\t\t: path1._id - path2._id;\r\n\t\t\tif (diff < 0) {\r\n\t\t\t\tr = m - 1;\r\n\t\t\t} else {\r\n\t\t\t\tl = m + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tlocations.splice(l, 0, loc);\r\n\t\treturn loc;\r\n\t}\r\n\r\n\treturn { statics: {\r\n\t\tinsert: insert,\r\n\r\n\t\texpand: function(locations) {\r\n\t\t\tvar expanded = locations.slice();\r\n\t\t\tfor (var i = 0, l = locations.length; i < l; i++) {\r\n\t\t\t\tinsert(expanded, locations[i]._intersection, false);\r\n\t\t\t}\r\n\t\t\treturn expanded;\r\n\t\t}\r\n\t}};\r\n});\r\n\r\nvar PathItem = Item.extend({\r\n\t_class: 'PathItem',\r\n\r\n\tinitialize: function PathItem() {\r\n\t},\r\n\r\n\tgetIntersections: function(path, include, _matrix, _returnFirst) {\r\n\t\tvar self = this === path || !path,\r\n\t\t\tmatrix1 = this._matrix.orNullIfIdentity(),\r\n\t\t\tmatrix2 = self ? matrix1\r\n\t\t\t\t: (_matrix || path._matrix).orNullIfIdentity();\r\n\t\tif (!self && !this.getBounds(matrix1).touches(path.getBounds(matrix2)))\r\n\t\t\treturn [];\r\n\t\tvar curves1 = this.getCurves(),\r\n\t\t\tcurves2 = self ? curves1 : path.getCurves(),\r\n\t\t\tlength1 = curves1.length,\r\n\t\t\tlength2 = self ? length1 : curves2.length,\r\n\t\t\tvalues2 = [],\r\n\t\t\tarrays = [],\r\n\t\t\tlocations,\r\n\t\t\tpath;\r\n\t\tfor (var i = 0; i < length2; i++)\r\n\t\t\tvalues2[i] = curves2[i].getValues(matrix2);\r\n\t\tfor (var i = 0; i < length1; i++) {\r\n\t\t\tvar curve1 = curves1[i],\r\n\t\t\t\tvalues1 = self ? values2[i] : curve1.getValues(matrix1),\r\n\t\t\t\tpath1 = curve1.getPath();\r\n\t\t\tif (path1 !== path) {\r\n\t\t\t\tpath = path1;\r\n\t\t\t\tlocations = [];\r\n\t\t\t\tarrays.push(locations);\r\n\t\t\t}\r\n\t\t\tif (self) {\r\n\t\t\t\tCurve._getSelfIntersection(values1, curve1, locations, {\r\n\t\t\t\t\tinclude: include,\r\n\t\t\t\t\tstartConnected: length1 === 1 &&\r\n\t\t\t\t\t\t\tcurve1.getPoint1().equals(curve1.getPoint2())\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tfor (var j = self ? i + 1 : 0; j < length2; j++) {\r\n\t\t\t\tif (_returnFirst && locations.length)\r\n\t\t\t\t\treturn locations;\r\n\t\t\t\tvar curve2 = curves2[j];\r\n\t\t\t\tCurve._getIntersections(\r\n\t\t\t\t\tvalues1, values2[j], curve1, curve2, locations,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tinclude: include,\r\n\t\t\t\t\t\tstartConnected: self && curve1.getPrevious() === curve2,\r\n\t\t\t\t\t\tendConnected: self && curve1.getNext() === curve2\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\tlocations = [];\r\n\t\tfor (var i = 0, l = arrays.length; i < l; i++) {\r\n\t\t\tlocations.push.apply(locations, arrays[i]);\r\n\t\t}\r\n\t\treturn locations;\r\n\t},\r\n\r\n\tgetCrossings: function(path) {\r\n\t\treturn this.getIntersections(path, function(inter) {\r\n\t\t\treturn inter.isCrossing();\r\n\t\t});\r\n\t},\r\n\r\n\t_asPathItem: function() {\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetPathData: function(data) {\r\n\r\n\t\tvar parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),\r\n\t\t\tcoords,\r\n\t\t\trelative = false,\r\n\t\t\tprevious,\r\n\t\t\tcontrol,\r\n\t\t\tcurrent = new Point(),\r\n\t\t\tstart = new Point();\r\n\r\n\t\tfunction getCoord(index, coord) {\r\n\t\t\tvar val = +coords[index];\r\n\t\t\tif (relative)\r\n\t\t\t\tval += current[coord];\r\n\t\t\treturn val;\r\n\t\t}\r\n\r\n\t\tfunction getPoint(index) {\r\n\t\t\treturn new Point(\r\n\t\t\t\tgetCoord(index, 'x'),\r\n\t\t\t\tgetCoord(index + 1, 'y')\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tthis.clear();\r\n\r\n\t\tfor (var i = 0, l = parts && parts.length; i < l; i++) {\r\n\t\t\tvar part = parts[i],\r\n\t\t\t\tcommand = part[0],\r\n\t\t\t\tlower = command.toLowerCase();\r\n\t\t\tcoords = part.match(/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g);\r\n\t\t\tvar length = coords && coords.length;\r\n\t\t\trelative = command === lower;\r\n\t\t\tif (previous === 'z' && !/[mz]/.test(lower))\r\n\t\t\t\tthis.moveTo(current = start);\r\n\t\t\tswitch (lower) {\r\n\t\t\tcase 'm':\r\n\t\t\tcase 'l':\r\n\t\t\t\tvar move = lower === 'm';\r\n\t\t\t\tfor (var j = 0; j < length; j += 2)\r\n\t\t\t\t\tthis[j === 0 && move ? 'moveTo' : 'lineTo'](\r\n\t\t\t\t\t\t\tcurrent = getPoint(j));\r\n\t\t\t\tcontrol = current;\r\n\t\t\t\tif (move)\r\n\t\t\t\t\tstart = current;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'h':\r\n\t\t\tcase 'v':\r\n\t\t\t\tvar coord = lower === 'h' ? 'x' : 'y';\r\n\t\t\t\tfor (var j = 0; j < length; j++) {\r\n\t\t\t\t\tcurrent[coord] = getCoord(j, coord);\r\n\t\t\t\t\tthis.lineTo(current);\r\n\t\t\t\t}\r\n\t\t\t\tcontrol = current;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'c':\r\n\t\t\t\tfor (var j = 0; j < length; j += 6) {\r\n\t\t\t\t\tthis.cubicCurveTo(\r\n\t\t\t\t\t\t\tgetPoint(j),\r\n\t\t\t\t\t\t\tcontrol = getPoint(j + 2),\r\n\t\t\t\t\t\t\tcurrent = getPoint(j + 4));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 's':\r\n\t\t\t\tfor (var j = 0; j < length; j += 4) {\r\n\t\t\t\t\tthis.cubicCurveTo(\r\n\t\t\t\t\t\t\t/[cs]/.test(previous)\r\n\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\r\n\t\t\t\t\t\t\t\t\t: current,\r\n\t\t\t\t\t\t\tcontrol = getPoint(j),\r\n\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\r\n\t\t\t\t\tprevious = lower;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'q':\r\n\t\t\t\tfor (var j = 0; j < length; j += 4) {\r\n\t\t\t\t\tthis.quadraticCurveTo(\r\n\t\t\t\t\t\t\tcontrol = getPoint(j),\r\n\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 't':\r\n\t\t\t\tfor (var j = 0; j < length; j += 2) {\r\n\t\t\t\t\tthis.quadraticCurveTo(\r\n\t\t\t\t\t\t\tcontrol = (/[qt]/.test(previous)\r\n\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\r\n\t\t\t\t\t\t\t\t\t: current),\r\n\t\t\t\t\t\t\tcurrent = getPoint(j));\r\n\t\t\t\t\tprevious = lower;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'a':\r\n\t\t\t\tfor (var j = 0; j < length; j += 7) {\r\n\t\t\t\t\tthis.arcTo(current = getPoint(j + 5),\r\n\t\t\t\t\t\t\tnew Size(+coords[j], +coords[j + 1]),\r\n\t\t\t\t\t\t\t+coords[j + 2], +coords[j + 4], +coords[j + 3]);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'z':\r\n\t\t\t\tthis.closePath(true);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tprevious = lower;\r\n\t\t}\r\n\t},\r\n\r\n\t_canComposite: function() {\r\n\t\treturn !(this.hasFill() && this.hasStroke());\r\n\t},\r\n\r\n\t_contains: function(point) {\r\n\t\tvar winding = this._getWinding(point, false, true);\r\n\t\treturn !!(this.getWindingRule() === 'evenodd' ? winding & 1 : winding);\r\n\t}\r\n\r\n});\r\n\r\nvar Path = PathItem.extend({\r\n\t_class: 'Path',\r\n\t_serializeFields: {\r\n\t\tsegments: [],\r\n\t\tclosed: false\r\n\t},\r\n\r\n\tinitialize: function Path(arg) {\r\n\t\tthis._closed = false;\r\n\t\tthis._segments = [];\r\n\t\tthis._version = 0;\r\n\t\tvar segments = Array.isArray(arg)\r\n\t\t\t? typeof arg[0] === 'object'\r\n\t\t\t\t? arg\r\n\t\t\t\t: arguments\r\n\t\t\t: arg && (arg.size === undefined && (arg.x !== undefined\r\n\t\t\t\t\t|| arg.point !== undefined))\r\n\t\t\t\t? arguments\r\n\t\t\t\t: null;\r\n\t\tif (segments && segments.length > 0) {\r\n\t\t\tthis.setSegments(segments);\r\n\t\t} else {\r\n\t\t\tthis._curves = undefined;\r\n\t\t\tthis._selectedSegmentState = 0;\r\n\t\t\tif (!segments && typeof arg === 'string') {\r\n\t\t\t\tthis.setPathData(arg);\r\n\t\t\t\targ = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._initialize(!segments && arg);\r\n\t},\r\n\r\n\t_equals: function(item) {\r\n\t\treturn this._closed === item._closed\r\n\t\t\t\t&& Base.equals(this._segments, item._segments);\r\n\t},\r\n\r\n\tclone: function(insert) {\r\n\t\tvar copy = new Path(Item.NO_INSERT);\r\n\t\tcopy.setSegments(this._segments);\r\n\t\tcopy._closed = this._closed;\r\n\t\tif (this._clockwise !== undefined)\r\n\t\t\tcopy._clockwise = this._clockwise;\r\n\t\treturn this._clone(copy, insert);\r\n\t},\r\n\r\n\t_changed: function _changed(flags) {\r\n\t\t_changed.base.call(this, flags);\r\n\t\tif (flags & 8) {\r\n\t\t\tvar parent = this._parent;\r\n\t\t\tif (parent)\r\n\t\t\t\tparent._currentPath = undefined;\r\n\t\t\tthis._length = this._area = this._clockwise = this._monoCurves =\r\n\t\t\t\t\tundefined;\r\n\t\t\tif (flags & 16) {\r\n\t\t\t\tthis._version++;\r\n\t\t\t} else if (this._curves) {\r\n\t\t\t   for (var i = 0, l = this._curves.length; i < l; i++)\r\n\t\t\t\t\tthis._curves[i]._changed();\r\n\t\t\t}\r\n\t\t} else if (flags & 32) {\r\n\t\t\tthis._bounds = undefined;\r\n\t\t}\r\n\t},\r\n\r\n\tgetStyle: function() {\r\n\t\tvar parent = this._parent;\r\n\t\treturn (parent instanceof CompoundPath ? parent : this)._style;\r\n\t},\r\n\r\n\tgetSegments: function() {\r\n\t\treturn this._segments;\r\n\t},\r\n\r\n\tsetSegments: function(segments) {\r\n\t\tvar fullySelected = this.isFullySelected();\r\n\t\tthis._segments.length = 0;\r\n\t\tthis._selectedSegmentState = 0;\r\n\t\tthis._curves = undefined;\r\n\t\tif (segments && segments.length > 0)\r\n\t\t\tthis._add(Segment.readAll(segments));\r\n\t\tif (fullySelected)\r\n\t\t\tthis.setFullySelected(true);\r\n\t},\r\n\r\n\tgetFirstSegment: function() {\r\n\t\treturn this._segments[0];\r\n\t},\r\n\r\n\tgetLastSegment: function() {\r\n\t\treturn this._segments[this._segments.length - 1];\r\n\t},\r\n\r\n\tgetCurves: function() {\r\n\t\tvar curves = this._curves,\r\n\t\t\tsegments = this._segments;\r\n\t\tif (!curves) {\r\n\t\t\tvar length = this._countCurves();\r\n\t\t\tcurves = this._curves = new Array(length);\r\n\t\t\tfor (var i = 0; i < length; i++)\r\n\t\t\t\tcurves[i] = new Curve(this, segments[i],\r\n\t\t\t\t\tsegments[i + 1] || segments[0]);\r\n\t\t}\r\n\t\treturn curves;\r\n\t},\r\n\r\n\tgetFirstCurve: function() {\r\n\t\treturn this.getCurves()[0];\r\n\t},\r\n\r\n\tgetLastCurve: function() {\r\n\t\tvar curves = this.getCurves();\r\n\t\treturn curves[curves.length - 1];\r\n\t},\r\n\r\n\tisClosed: function() {\r\n\t\treturn this._closed;\r\n\t},\r\n\r\n\tsetClosed: function(closed) {\r\n\t\tif (this._closed != (closed = !!closed)) {\r\n\t\t\tthis._closed = closed;\r\n\t\t\tif (this._curves) {\r\n\t\t\t\tvar length = this._curves.length = this._countCurves();\r\n\t\t\t\tif (closed)\r\n\t\t\t\t\tthis._curves[length - 1] = new Curve(this,\r\n\t\t\t\t\t\tthis._segments[length - 1], this._segments[0]);\r\n\t\t\t}\r\n\t\t\tthis._changed(25);\r\n\t\t}\r\n\t}\r\n}, {\r\n\tbeans: true,\r\n\r\n\tgetPathData: function(_matrix, _precision) {\r\n\t\tvar segments = this._segments,\r\n\t\t\tlength = segments.length,\r\n\t\t\tf = new Formatter(_precision),\r\n\t\t\tcoords = new Array(6),\r\n\t\t\tfirst = true,\r\n\t\t\tcurX, curY,\r\n\t\t\tprevX, prevY,\r\n\t\t\tinX, inY,\r\n\t\t\toutX, outY,\r\n\t\t\tparts = [];\r\n\r\n\t\tfunction addSegment(segment, skipLine) {\r\n\t\t\tsegment._transformCoordinates(_matrix, coords, false);\r\n\t\t\tcurX = coords[0];\r\n\t\t\tcurY = coords[1];\r\n\t\t\tif (first) {\r\n\t\t\t\tparts.push('M' + f.pair(curX, curY));\r\n\t\t\t\tfirst = false;\r\n\t\t\t} else {\r\n\t\t\t\tinX = coords[2];\r\n\t\t\t\tinY = coords[3];\r\n\t\t\t\tif (inX === curX && inY === curY\r\n\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\r\n\t\t\t\t\tif (!skipLine)\r\n\t\t\t\t\t\tparts.push('l' + f.pair(curX - prevX, curY - prevY));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tparts.push('c' + f.pair(outX - prevX, outY - prevY)\r\n\t\t\t\t\t\t\t+ ' ' + f.pair(inX - prevX, inY - prevY)\r\n\t\t\t\t\t\t\t+ ' ' + f.pair(curX - prevX, curY - prevY));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tprevX = curX;\r\n\t\t\tprevY = curY;\r\n\t\t\toutX = coords[4];\r\n\t\t\toutY = coords[5];\r\n\t\t}\r\n\r\n\t\tif (length === 0)\r\n\t\t\treturn '';\r\n\r\n\t\tfor (var i = 0; i < length; i++)\r\n\t\t\taddSegment(segments[i]);\r\n\t\tif (this._closed && length > 0) {\r\n\t\t\taddSegment(segments[0], true);\r\n\t\t\tparts.push('z');\r\n\t\t}\r\n\t\treturn parts.join('');\r\n\t}\r\n}, {\r\n\r\n\tisEmpty: function() {\r\n\t\treturn this._segments.length === 0;\r\n\t},\r\n\r\n\t_transformContent: function(matrix) {\r\n\t\tvar coords = new Array(6);\r\n\t\tfor (var i = 0, l = this._segments.length; i < l; i++)\r\n\t\t\tthis._segments[i]._transformCoordinates(matrix, coords, true);\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_add: function(segs, index) {\r\n\t\tvar segments = this._segments,\r\n\t\t\tcurves = this._curves,\r\n\t\t\tamount = segs.length,\r\n\t\t\tappend = index == null,\r\n\t\t\tindex = append ? segments.length : index;\r\n\t\tfor (var i = 0; i < amount; i++) {\r\n\t\t\tvar segment = segs[i];\r\n\t\t\tif (segment._path)\r\n\t\t\t\tsegment = segs[i] = segment.clone();\r\n\t\t\tsegment._path = this;\r\n\t\t\tsegment._index = index + i;\r\n\t\t\tif (segment._selectionState)\r\n\t\t\t\tthis._updateSelection(segment, 0, segment._selectionState);\r\n\t\t}\r\n\t\tif (append) {\r\n\t\t\tsegments.push.apply(segments, segs);\r\n\t\t} else {\r\n\t\t\tsegments.splice.apply(segments, [index, 0].concat(segs));\r\n\t\t\tfor (var i = index + amount, l = segments.length; i < l; i++)\r\n\t\t\t\tsegments[i]._index = i;\r\n\t\t}\r\n\t\tif (curves) {\r\n\t\t\tvar total = this._countCurves(),\r\n\t\t\t\tfrom = index + amount - 1 === total ? index - 1 : index,\r\n\t\t\t\tstart = from,\r\n\t\t\t\tto = Math.min(from + amount, total);\r\n\t\t\tif (segs._curves) {\r\n\t\t\t\tcurves.splice.apply(curves, [from, 0].concat(segs._curves));\r\n\t\t\t\tstart += segs._curves.length;\r\n\t\t\t}\r\n\t\t\tfor (var i = start; i < to; i++)\r\n\t\t\t\tcurves.splice(i, 0, new Curve(this, null, null));\r\n\t\t\tthis._adjustCurves(from, to);\r\n\t\t}\r\n\t\tthis._changed(25);\r\n\t\treturn segs;\r\n\t},\r\n\r\n\t_adjustCurves: function(from, to) {\r\n\t\tvar segments = this._segments,\r\n\t\t\tcurves = this._curves,\r\n\t\t\tcurve;\r\n\t\tfor (var i = from; i < to; i++) {\r\n\t\t\tcurve = curves[i];\r\n\t\t\tcurve._path = this;\r\n\t\t\tcurve._segment1 = segments[i];\r\n\t\t\tcurve._segment2 = segments[i + 1] || segments[0];\r\n\t\t\tcurve._changed();\r\n\t\t}\r\n\t\tif (curve = curves[this._closed && from === 0 ? segments.length - 1\r\n\t\t\t\t: from - 1]) {\r\n\t\t\tcurve._segment2 = segments[from] || segments[0];\r\n\t\t\tcurve._changed();\r\n\t\t}\r\n\t\tif (curve = curves[to]) {\r\n\t\t\tcurve._segment1 = segments[to];\r\n\t\t\tcurve._changed();\r\n\t\t}\r\n\t},\r\n\r\n\t_countCurves: function() {\r\n\t\tvar length = this._segments.length;\r\n\t\treturn !this._closed && length > 0 ? length - 1 : length;\r\n\t},\r\n\r\n\tadd: function(segment1 ) {\r\n\t\treturn arguments.length > 1 && typeof segment1 !== 'number'\r\n\t\t\t? this._add(Segment.readAll(arguments))\r\n\t\t\t: this._add([ Segment.read(arguments) ])[0];\r\n\t},\r\n\r\n\tinsert: function(index, segment1 ) {\r\n\t\treturn arguments.length > 2 && typeof segment1 !== 'number'\r\n\t\t\t? this._add(Segment.readAll(arguments, 1), index)\r\n\t\t\t: this._add([ Segment.read(arguments, 1) ], index)[0];\r\n\t},\r\n\r\n\taddSegment: function() {\r\n\t\treturn this._add([ Segment.read(arguments) ])[0];\r\n\t},\r\n\r\n\tinsertSegment: function(index ) {\r\n\t\treturn this._add([ Segment.read(arguments, 1) ], index)[0];\r\n\t},\r\n\r\n\taddSegments: function(segments) {\r\n\t\treturn this._add(Segment.readAll(segments));\r\n\t},\r\n\r\n\tinsertSegments: function(index, segments) {\r\n\t\treturn this._add(Segment.readAll(segments), index);\r\n\t},\r\n\r\n\tremoveSegment: function(index) {\r\n\t\treturn this.removeSegments(index, index + 1)[0] || null;\r\n\t},\r\n\r\n\tremoveSegments: function(from, to, _includeCurves) {\r\n\t\tfrom = from || 0;\r\n\t\tto = Base.pick(to, this._segments.length);\r\n\t\tvar segments = this._segments,\r\n\t\t\tcurves = this._curves,\r\n\t\t\tcount = segments.length,\r\n\t\t\tremoved = segments.splice(from, to - from),\r\n\t\t\tamount = removed.length;\r\n\t\tif (!amount)\r\n\t\t\treturn removed;\r\n\t\tfor (var i = 0; i < amount; i++) {\r\n\t\t\tvar segment = removed[i];\r\n\t\t\tif (segment._selectionState)\r\n\t\t\t\tthis._updateSelection(segment, segment._selectionState, 0);\r\n\t\t\tsegment._index = segment._path = null;\r\n\t\t}\r\n\t\tfor (var i = from, l = segments.length; i < l; i++)\r\n\t\t\tsegments[i]._index = i;\r\n\t\tif (curves) {\r\n\t\t\tvar index = from > 0 && to === count + (this._closed ? 1 : 0)\r\n\t\t\t\t\t? from - 1\r\n\t\t\t\t\t: from,\r\n\t\t\t\tcurves = curves.splice(index, amount);\r\n\t\t\tif (_includeCurves)\r\n\t\t\t\tremoved._curves = curves.slice(1);\r\n\t\t\tthis._adjustCurves(index, index);\r\n\t\t}\r\n\t\tthis._changed(25);\r\n\t\treturn removed;\r\n\t},\r\n\r\n\tclear: '#removeSegments',\r\n\r\n\thasHandles: function() {\r\n\t\tvar segments = this._segments;\r\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\r\n\t\t\tif (segments[i].hasHandles())\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tclearHandles: function() {\r\n\t\tvar segments = this._segments;\r\n\t\tfor (var i = 0, l = segments.length; i < l; i++)\r\n\t\t\tsegments[i].clearHandles();\r\n\t},\r\n\r\n\tgetLength: function() {\r\n\t\tif (this._length == null) {\r\n\t\t\tvar curves = this.getCurves(),\r\n\t\t\t\tlength = 0;\r\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++)\r\n\t\t\t\tlength += curves[i].getLength();\r\n\t\t\tthis._length = length;\r\n\t\t}\r\n\t\treturn this._length;\r\n\t},\r\n\r\n\tgetArea: function() {\r\n\t\tif (this._area == null) {\r\n\t\t\tvar segments = this._segments,\r\n\t\t\t\tcount = segments.length,\r\n\t\t\t\tlast = count - 1,\r\n\t\t\t\tarea = 0;\r\n\t\t\tfor (var i = 0, l = this._closed ? count : last; i < l; i++) {\r\n\t\t\t\tarea += Curve.getArea(Curve.getValues(\r\n\t\t\t\t\t\tsegments[i], segments[i < last ? i + 1 : 0]));\r\n\t\t\t}\r\n\t\t\tthis._area = area;\r\n\t\t}\r\n\t\treturn this._area;\r\n\t},\r\n\r\n\tisClockwise: function() {\r\n\t\tif (this._clockwise !== undefined)\r\n\t\t\treturn this._clockwise;\r\n\t\treturn this.getArea() >= 0;\r\n\t},\r\n\r\n\tsetClockwise: function(clockwise) {\r\n\t\tif (this.isClockwise() != (clockwise = !!clockwise))\r\n\t\t\tthis.reverse();\r\n\t\tthis._clockwise = clockwise;\r\n\t},\r\n\r\n\tisFullySelected: function() {\r\n\t\tvar length = this._segments.length;\r\n\t\treturn this._selected && length > 0 && this._selectedSegmentState\r\n\t\t\t\t=== length * 7;\r\n\t},\r\n\r\n\tsetFullySelected: function(selected) {\r\n\t\tif (selected)\r\n\t\t\tthis._selectSegments(true);\r\n\t\tthis.setSelected(selected);\r\n\t},\r\n\r\n\tsetSelected: function setSelected(selected) {\r\n\t\tif (!selected)\r\n\t\t\tthis._selectSegments(false);\r\n\t\tsetSelected.base.call(this, selected);\r\n\t},\r\n\r\n\t_selectSegments: function(selected) {\r\n\t\tvar length = this._segments.length;\r\n\t\tthis._selectedSegmentState = selected\r\n\t\t\t\t? length * 7 : 0;\r\n\t\tfor (var i = 0; i < length; i++)\r\n\t\t\tthis._segments[i]._selectionState = selected\r\n\t\t\t\t\t? 7 : 0;\r\n\t},\r\n\r\n\t_updateSelection: function(segment, oldState, newState) {\r\n\t\tsegment._selectionState = newState;\r\n\t\tvar total = this._selectedSegmentState += newState - oldState;\r\n\t\tif (total > 0)\r\n\t\t\tthis.setSelected(true);\r\n\t},\r\n\r\n\tflatten: function(maxDistance) {\r\n\t\tvar iterator = new PathIterator(this, 64, 0.1),\r\n\t\t\tpos = 0,\r\n\t\t\tstep = iterator.length / Math.ceil(iterator.length / maxDistance),\r\n\t\t\tend = iterator.length + (this._closed ? -step : step) / 2;\r\n\t\tvar segments = [];\r\n\t\twhile (pos <= end) {\r\n\t\t\tsegments.push(new Segment(iterator.getPointAt(pos)));\r\n\t\t\tpos += step;\r\n\t\t}\r\n\t\tthis.setSegments(segments);\r\n\t},\r\n\r\n\treduce: function() {\r\n\t\tvar curves = this.getCurves();\r\n\t\tfor (var i = curves.length - 1; i >= 0; i--) {\r\n\t\t\tvar curve = curves[i];\r\n\t\t\tif (!curve.hasHandles() && (curve.getLength() === 0\r\n\t\t\t\t\t|| curve.isCollinear(curve.getNext())))\r\n\t\t\t\tcurve.remove();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsimplify: function(tolerance) {\r\n\t\tif (this._segments.length > 2) {\r\n\t\t\tvar fitter = new PathFitter(this, tolerance || 2.5);\r\n\t\t\tthis.setSegments(fitter.fit());\r\n\t\t}\r\n\t},\r\n\r\n\tsplit: function(index, parameter) {\r\n\t\tif (parameter === null)\r\n\t\t\treturn null;\r\n\t\tif (arguments.length === 1) {\r\n\t\t\tvar arg = index;\r\n\t\t\tif (typeof arg === 'number')\r\n\t\t\t\targ = this.getLocationAt(arg);\r\n\t\t\tif (!arg)\r\n\t\t\t\treturn null\r\n\t\t\tindex = arg.index;\r\n\t\t\tparameter = arg.parameter;\r\n\t\t}\r\n\t\tvar tMin = 4e-7,\r\n\t\t\ttMax = 1 - tMin;\r\n\t\tif (parameter >= tMax) {\r\n\t\t\tindex++;\r\n\t\t\tparameter--;\r\n\t\t}\r\n\t\tvar curves = this.getCurves();\r\n\t\tif (index >= 0 && index < curves.length) {\r\n\t\t\tif (parameter >= tMin) {\r\n\t\t\t\tcurves[index++].divide(parameter, true);\r\n\t\t\t}\r\n\t\t\tvar segs = this.removeSegments(index, this._segments.length, true),\r\n\t\t\t\tpath;\r\n\t\t\tif (this._closed) {\r\n\t\t\t\tthis.setClosed(false);\r\n\t\t\t\tpath = this;\r\n\t\t\t} else {\r\n\t\t\t\tpath = new Path(Item.NO_INSERT);\r\n\t\t\t\tpath.insertAbove(this, true);\r\n\t\t\t\tthis._clone(path);\r\n\t\t\t}\r\n\t\t\tpath._add(segs, 0);\r\n\t\t\tthis.addSegment(segs[0]);\r\n\t\t\treturn path;\r\n\t\t}\r\n\t\treturn null;\r\n\t},\r\n\r\n\treverse: function() {\r\n\t\tthis._segments.reverse();\r\n\t\tfor (var i = 0, l = this._segments.length; i < l; i++) {\r\n\t\t\tvar segment = this._segments[i];\r\n\t\t\tvar handleIn = segment._handleIn;\r\n\t\t\tsegment._handleIn = segment._handleOut;\r\n\t\t\tsegment._handleOut = handleIn;\r\n\t\t\tsegment._index = i;\r\n\t\t}\r\n\t\tthis._curves = null;\r\n\t\tif (this._clockwise !== undefined)\r\n\t\t\tthis._clockwise = !this._clockwise;\r\n\t\tthis._changed(9);\r\n\t},\r\n\r\n\tjoin: function(path) {\r\n\t\tif (path) {\r\n\t\t\tvar segments = path._segments,\r\n\t\t\t\tlast1 = this.getLastSegment(),\r\n\t\t\t\tlast2 = path.getLastSegment();\r\n\t\t\tif (!last2)\r\n\t\t\t\treturn this;\r\n\t\t\tif (last1 && last1._point.equals(last2._point))\r\n\t\t\t\tpath.reverse();\r\n\t\t\tvar first2 = path.getFirstSegment();\r\n\t\t\tif (last1 && last1._point.equals(first2._point)) {\r\n\t\t\t\tlast1.setHandleOut(first2._handleOut);\r\n\t\t\t\tthis._add(segments.slice(1));\r\n\t\t\t} else {\r\n\t\t\t\tvar first1 = this.getFirstSegment();\r\n\t\t\t\tif (first1 && first1._point.equals(first2._point))\r\n\t\t\t\t\tpath.reverse();\r\n\t\t\t\tlast2 = path.getLastSegment();\r\n\t\t\t\tif (first1 && first1._point.equals(last2._point)) {\r\n\t\t\t\t\tfirst1.setHandleIn(last2._handleIn);\r\n\t\t\t\t\tthis._add(segments.slice(0, segments.length - 1), 0);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._add(segments.slice());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (path._closed)\r\n\t\t\t\tthis._add([segments[0]]);\r\n\t\t\tpath.remove();\r\n\t\t}\r\n\t\tvar first = this.getFirstSegment(),\r\n\t\t\tlast = this.getLastSegment();\r\n\t\tif (first !== last && first._point.equals(last._point)) {\r\n\t\t\tfirst.setHandleIn(last._handleIn);\r\n\t\t\tlast.remove();\r\n\t\t\tthis.setClosed(true);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\ttoShape: function(insert) {\r\n\t\tif (!this._closed)\r\n\t\t\treturn null;\r\n\r\n\t\tvar segments = this._segments,\r\n\t\t\ttype,\r\n\t\t\tsize,\r\n\t\t\tradius,\r\n\t\t\ttopCenter;\r\n\r\n\t\tfunction isCollinear(i, j) {\r\n\t\t\tvar seg1 = segments[i],\r\n\t\t\t\tseg2 = seg1.getNext(),\r\n\t\t\t\tseg3 = segments[j],\r\n\t\t\t\tseg4 = seg3.getNext();\r\n\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\r\n\t\t\t\t\t&& seg3._handleOut.isZero() && seg4._handleIn.isZero()\r\n\t\t\t\t\t&& seg2._point.subtract(seg1._point).isCollinear(\r\n\t\t\t\t\t\tseg4._point.subtract(seg3._point));\r\n\t\t}\r\n\r\n\t\tfunction isOrthogonal(i) {\r\n\t\t\tvar seg2 = segments[i],\r\n\t\t\t\tseg1 = seg2.getPrevious(),\r\n\t\t\t\tseg3 = seg2.getNext();\r\n\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\r\n\t\t\t\t\t&& seg2._handleOut.isZero() && seg3._handleIn.isZero()\r\n\t\t\t\t\t&& seg2._point.subtract(seg1._point).isOrthogonal(\r\n\t\t\t\t\t\tseg3._point.subtract(seg2._point));\r\n\t\t}\r\n\r\n\t\tfunction isArc(i) {\r\n\t\t\tvar seg1 = segments[i],\r\n\t\t\t\tseg2 = seg1.getNext(),\r\n\t\t\t\thandle1 = seg1._handleOut,\r\n\t\t\t\thandle2 = seg2._handleIn,\r\n\t\t\t\tkappa = 0.5522847498307936;\r\n\t\t\tif (handle1.isOrthogonal(handle2)) {\r\n\t\t\t\tvar pt1 = seg1._point,\r\n\t\t\t\t\tpt2 = seg2._point,\r\n\t\t\t\t\tcorner = new Line(pt1, handle1, true).intersect(\r\n\t\t\t\t\t\t\tnew Line(pt2, handle2, true), true);\r\n\t\t\t\treturn corner && Numerical.isZero(handle1.getLength() /\r\n\t\t\t\t\t\tcorner.subtract(pt1).getLength() - kappa)\r\n\t\t\t\t\t&& Numerical.isZero(handle2.getLength() /\r\n\t\t\t\t\t\tcorner.subtract(pt2).getLength() - kappa);\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tfunction getDistance(i, j) {\r\n\t\t\treturn segments[i]._point.getDistance(segments[j]._point);\r\n\t\t}\r\n\r\n\t\tif (!this.hasHandles() && segments.length === 4\r\n\t\t\t\t&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {\r\n\t\t\ttype = Shape.Rectangle;\r\n\t\t\tsize = new Size(getDistance(0, 3), getDistance(0, 1));\r\n\t\t\ttopCenter = segments[1]._point.add(segments[2]._point).divide(2);\r\n\t\t} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)\r\n\t\t\t\t&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {\r\n\t\t\ttype = Shape.Rectangle;\r\n\t\t\tsize = new Size(getDistance(1, 6), getDistance(0, 3));\r\n\t\t\tradius = size.subtract(new Size(getDistance(0, 7),\r\n\t\t\t\t\tgetDistance(1, 2))).divide(2);\r\n\t\t\ttopCenter = segments[3]._point.add(segments[4]._point).divide(2);\r\n\t\t} else if (segments.length === 4\r\n\t\t\t\t&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {\r\n\t\t\tif (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {\r\n\t\t\t\ttype = Shape.Circle;\r\n\t\t\t\tradius = getDistance(0, 2) / 2;\r\n\t\t\t} else {\r\n\t\t\t\ttype = Shape.Ellipse;\r\n\t\t\t\tradius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);\r\n\t\t\t}\r\n\t\t\ttopCenter = segments[1]._point;\r\n\t\t}\r\n\r\n\t\tif (type) {\r\n\t\t\tvar center = this.getPosition(true),\r\n\t\t\t\tshape = this._clone(new type({\r\n\t\t\t\t\tcenter: center,\r\n\t\t\t\t\tsize: size,\r\n\t\t\t\t\tradius: radius,\r\n\t\t\t\t\tinsert: false\r\n\t\t\t\t}), insert, false);\r\n\t\t\tshape.rotate(topCenter.subtract(center).getAngle() + 90);\r\n\t\t\treturn shape;\r\n\t\t}\r\n\t\treturn null;\r\n\t},\r\n\r\n\t_hitTestSelf: function(point, options) {\r\n\t\tvar that = this,\r\n\t\t\tstyle = this.getStyle(),\r\n\t\t\tsegments = this._segments,\r\n\t\t\tnumSegments = segments.length,\r\n\t\t\tclosed = this._closed,\r\n\t\t\ttolerancePadding = options._tolerancePadding,\r\n\t\t\tstrokePadding = tolerancePadding,\r\n\t\t\tjoin, cap, miterLimit,\r\n\t\t\tarea, loc, res,\r\n\t\t\thitStroke = options.stroke && style.hasStroke(),\r\n\t\t\thitFill = options.fill && style.hasFill(),\r\n\t\t\thitCurves = options.curves,\r\n\t\t\tradius = hitStroke\r\n\t\t\t\t\t? style.getStrokeWidth() / 2\r\n\t\t\t\t\t: hitFill && options.tolerance > 0 || hitCurves\r\n\t\t\t\t\t\t? 0 : null;\r\n\t\tif (radius !== null) {\r\n\t\t\tif (radius > 0) {\r\n\t\t\t\tjoin = style.getStrokeJoin();\r\n\t\t\t\tcap = style.getStrokeCap();\r\n\t\t\t\tmiterLimit = radius * style.getMiterLimit();\r\n\t\t\t\tstrokePadding = tolerancePadding.add(new Point(radius, radius));\r\n\t\t\t} else {\r\n\t\t\t\tjoin = cap = 'round';\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction isCloseEnough(pt, padding) {\r\n\t\t\treturn point.subtract(pt).divide(padding).length <= 1;\r\n\t\t}\r\n\r\n\t\tfunction checkSegmentPoint(seg, pt, name) {\r\n\t\t\tif (!options.selected || pt.isSelected()) {\r\n\t\t\t\tvar anchor = seg._point;\r\n\t\t\t\tif (pt !== anchor)\r\n\t\t\t\t\tpt = pt.add(anchor);\r\n\t\t\t\tif (isCloseEnough(pt, strokePadding)) {\r\n\t\t\t\t\treturn new HitResult(name, that, {\r\n\t\t\t\t\t\tsegment: seg,\r\n\t\t\t\t\t\tpoint: pt\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction checkSegmentPoints(seg, ends) {\r\n\t\t\treturn (ends || options.segments)\r\n\t\t\t\t&& checkSegmentPoint(seg, seg._point, 'segment')\r\n\t\t\t\t|| (!ends && options.handles) && (\r\n\t\t\t\t\tcheckSegmentPoint(seg, seg._handleIn, 'handle-in') ||\r\n\t\t\t\t\tcheckSegmentPoint(seg, seg._handleOut, 'handle-out'));\r\n\t\t}\r\n\r\n\t\tfunction addToArea(point) {\r\n\t\t\tarea.add(point);\r\n\t\t}\r\n\r\n\t\tfunction checkSegmentStroke(segment) {\r\n\t\t\tif (join !== 'round' || cap !== 'round') {\r\n\t\t\t\tarea = new Path({ internal: true, closed: true });\r\n\t\t\t\tif (closed || segment._index > 0\r\n\t\t\t\t\t\t&& segment._index < numSegments - 1) {\r\n\t\t\t\t\tif (join !== 'round' && (segment._handleIn.isZero()\r\n\t\t\t\t\t\t\t|| segment._handleOut.isZero()))\r\n\t\t\t\t\t\tPath._addBevelJoin(segment, join, radius, miterLimit,\r\n\t\t\t\t\t\t\t\taddToArea, true);\r\n\t\t\t\t} else if (cap !== 'round') {\r\n\t\t\t\t\tPath._addSquareCap(segment, cap, radius, addToArea, true);\r\n\t\t\t\t}\r\n\t\t\t\tif (!area.isEmpty()) {\r\n\t\t\t\t\tvar loc;\r\n\t\t\t\t\treturn area.contains(point)\r\n\t\t\t\t\t\t|| (loc = area.getNearestLocation(point))\r\n\t\t\t\t\t\t\t&& isCloseEnough(loc.getPoint(), tolerancePadding);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn isCloseEnough(segment._point, strokePadding);\r\n\t\t}\r\n\r\n\t\tif (options.ends && !options.segments && !closed) {\r\n\t\t\tif (res = checkSegmentPoints(segments[0], true)\r\n\t\t\t\t\t|| checkSegmentPoints(segments[numSegments - 1], true))\r\n\t\t\t\treturn res;\r\n\t\t} else if (options.segments || options.handles) {\r\n\t\t\tfor (var i = 0; i < numSegments; i++)\r\n\t\t\t\tif (res = checkSegmentPoints(segments[i]))\r\n\t\t\t\t\treturn res;\r\n\t\t}\r\n\t\tif (radius !== null) {\r\n\t\t\tloc = this.getNearestLocation(point);\r\n\t\t\tif (loc) {\r\n\t\t\t\tvar parameter = loc.getParameter();\r\n\t\t\t\tif (parameter === 0 || parameter === 1 && numSegments > 1) {\r\n\t\t\t\t\tif (!checkSegmentStroke(loc.getSegment()))\r\n\t\t\t\t\t\tloc = null;\r\n\t\t\t\t} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {\r\n\t\t\t\t\tloc = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!loc && join === 'miter' && numSegments > 1) {\r\n\t\t\t\tfor (var i = 0; i < numSegments; i++) {\r\n\t\t\t\t\tvar segment = segments[i];\r\n\t\t\t\t\tif (point.getDistance(segment._point) <= miterLimit\r\n\t\t\t\t\t\t\t&& checkSegmentStroke(segment)) {\r\n\t\t\t\t\t\tloc = segment.getLocation();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn !loc && hitFill && this._contains(point)\r\n\t\t\t\t|| loc && !hitStroke && !hitCurves\r\n\t\t\t\t\t? new HitResult('fill', this)\r\n\t\t\t\t\t: loc\r\n\t\t\t\t\t\t? new HitResult(hitStroke ? 'stroke' : 'curve', this, {\r\n\t\t\t\t\t\t\tlocation: loc,\r\n\t\t\t\t\t\t\tpoint: loc.getPoint()\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t: null;\r\n\t}\r\n\r\n}, Base.each(Curve.evaluateMethods,\r\n\tfunction(name) {\r\n\t\tthis[name + 'At'] = function(offset, isParameter) {\r\n\t\t\tvar loc = this.getLocationAt(offset, isParameter);\r\n\t\t\treturn loc && loc[name]();\r\n\t\t};\r\n\t},\r\n{\r\n\tbeans: false,\r\n\r\n\tgetLocationOf: function() {\r\n\t\tvar point = Point.read(arguments),\r\n\t\t\tcurves = this.getCurves();\r\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\r\n\t\t\tvar loc = curves[i].getLocationOf(point);\r\n\t\t\tif (loc)\r\n\t\t\t\treturn loc;\r\n\t\t}\r\n\t\treturn null;\r\n\t},\r\n\r\n\tgetOffsetOf: function() {\r\n\t\tvar loc = this.getLocationOf.apply(this, arguments);\r\n\t\treturn loc ? loc.getOffset() : null;\r\n\t},\r\n\r\n\tgetLocationAt: function(offset, isParameter) {\r\n\t\tvar curves = this.getCurves(),\r\n\t\t\tlength = 0;\r\n\t\tif (isParameter) {\r\n\t\t\tvar index = ~~offset,\r\n\t\t\t\tcurve = curves[index];\r\n\t\t\treturn curve ? curve.getLocationAt(offset - index, true) : null;\r\n\t\t}\r\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\r\n\t\t\tvar start = length,\r\n\t\t\t\tcurve = curves[i];\r\n\t\t\tlength += curve.getLength();\r\n\t\t\tif (length > offset) {\r\n\t\t\t\treturn curve.getLocationAt(offset - start);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (curves.length > 0 && offset <= this.getLength())\r\n\t\t\treturn new CurveLocation(curves[curves.length - 1], 1);\r\n\t\treturn null;\r\n\t},\r\n\r\n\tgetNearestLocation: function() {\r\n\t\tvar point = Point.read(arguments),\r\n\t\t\tcurves = this.getCurves(),\r\n\t\t\tminDist = Infinity,\r\n\t\t\tminLoc = null;\r\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\r\n\t\t\tvar loc = curves[i].getNearestLocation(point);\r\n\t\t\tif (loc._distance < minDist) {\r\n\t\t\t\tminDist = loc._distance;\r\n\t\t\t\tminLoc = loc;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn minLoc;\r\n\t},\r\n\r\n\tgetNearestPoint: function() {\r\n\t\treturn this.getNearestLocation.apply(this, arguments).getPoint();\r\n\t}\r\n}),\r\nnew function() {\r\n\r\n\tfunction drawHandles(ctx, segments, matrix, size) {\r\n\t\tvar half = size / 2;\r\n\r\n\t\tfunction drawHandle(index) {\r\n\t\t\tvar hX = coords[index],\r\n\t\t\t\thY = coords[index + 1];\r\n\t\t\tif (pX != hX || pY != hY) {\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.moveTo(pX, pY);\r\n\t\t\t\tctx.lineTo(hX, hY);\r\n\t\t\t\tctx.stroke();\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.arc(hX, hY, half, 0, Math.PI * 2, true);\r\n\t\t\t\tctx.fill();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar coords = new Array(6);\r\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\r\n\t\t\tvar segment = segments[i];\r\n\t\t\tsegment._transformCoordinates(matrix, coords, false);\r\n\t\t\tvar state = segment._selectionState,\r\n\t\t\t\tpX = coords[0],\r\n\t\t\t\tpY = coords[1];\r\n\t\t\tif (state & 1)\r\n\t\t\t\tdrawHandle(2);\r\n\t\t\tif (state & 2)\r\n\t\t\t\tdrawHandle(4);\r\n\t\t\tctx.fillRect(pX - half, pY - half, size, size);\r\n\t\t\tif (!(state & 4)) {\r\n\t\t\t\tvar fillStyle = ctx.fillStyle;\r\n\t\t\t\tctx.fillStyle = '#ffffff';\r\n\t\t\t\tctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);\r\n\t\t\t\tctx.fillStyle = fillStyle;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction drawSegments(ctx, path, matrix) {\r\n\t\tvar segments = path._segments,\r\n\t\t\tlength = segments.length,\r\n\t\t\tcoords = new Array(6),\r\n\t\t\tfirst = true,\r\n\t\t\tcurX, curY,\r\n\t\t\tprevX, prevY,\r\n\t\t\tinX, inY,\r\n\t\t\toutX, outY;\r\n\r\n\t\tfunction drawSegment(segment) {\r\n\t\t\tif (matrix) {\r\n\t\t\t\tsegment._transformCoordinates(matrix, coords, false);\r\n\t\t\t\tcurX = coords[0];\r\n\t\t\t\tcurY = coords[1];\r\n\t\t\t} else {\r\n\t\t\t\tvar point = segment._point;\r\n\t\t\t\tcurX = point._x;\r\n\t\t\t\tcurY = point._y;\r\n\t\t\t}\r\n\t\t\tif (first) {\r\n\t\t\t\tctx.moveTo(curX, curY);\r\n\t\t\t\tfirst = false;\r\n\t\t\t} else {\r\n\t\t\t\tif (matrix) {\r\n\t\t\t\t\tinX = coords[2];\r\n\t\t\t\t\tinY = coords[3];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar handle = segment._handleIn;\r\n\t\t\t\t\tinX = curX + handle._x;\r\n\t\t\t\t\tinY = curY + handle._y;\r\n\t\t\t\t}\r\n\t\t\t\tif (inX === curX && inY === curY\r\n\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\r\n\t\t\t\t\tctx.lineTo(curX, curY);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tprevX = curX;\r\n\t\t\tprevY = curY;\r\n\t\t\tif (matrix) {\r\n\t\t\t\toutX = coords[4];\r\n\t\t\t\toutY = coords[5];\r\n\t\t\t} else {\r\n\t\t\t\tvar handle = segment._handleOut;\r\n\t\t\t\toutX = prevX + handle._x;\r\n\t\t\t\toutY = prevY + handle._y;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < length; i++)\r\n\t\t\tdrawSegment(segments[i]);\r\n\t\tif (path._closed && length > 0)\r\n\t\t\tdrawSegment(segments[0]);\r\n\t}\r\n\r\n\treturn {\r\n\t\t_draw: function(ctx, param, strokeMatrix) {\r\n\t\t\tvar dontStart = param.dontStart,\r\n\t\t\t\tdontPaint = param.dontFinish || param.clip,\r\n\t\t\t\tstyle = this.getStyle(),\r\n\t\t\t\thasFill = style.hasFill(),\r\n\t\t\t\thasStroke = style.hasStroke(),\r\n\t\t\t\tdashArray = style.getDashArray(),\r\n\t\t\t\tdashLength = !paper.support.nativeDash && hasStroke\r\n\t\t\t\t\t\t&& dashArray && dashArray.length;\r\n\r\n\t\t\tif (!dontStart)\r\n\t\t\t\tctx.beginPath();\r\n\r\n\t\t\tif (!dontStart && this._currentPath) {\r\n\t\t\t\tctx.currentPath = this._currentPath;\r\n\t\t\t} else if (hasFill || hasStroke && !dashLength || dontPaint) {\r\n\t\t\t\tdrawSegments(ctx, this, strokeMatrix);\r\n\t\t\t\tif (this._closed)\r\n\t\t\t\t\tctx.closePath();\r\n\t\t\t\tif (!dontStart)\r\n\t\t\t\t\tthis._currentPath = ctx.currentPath;\r\n\t\t\t}\r\n\r\n\t\t\tfunction getOffset(i) {\r\n\t\t\t\treturn dashArray[((i % dashLength) + dashLength) % dashLength];\r\n\t\t\t}\r\n\r\n\t\t\tif (!dontPaint && (hasFill || hasStroke)) {\r\n\t\t\t\tthis._setStyles(ctx);\r\n\t\t\t\tif (hasFill) {\r\n\t\t\t\t\tctx.fill(style.getWindingRule());\r\n\t\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\r\n\t\t\t\t}\r\n\t\t\t\tif (hasStroke) {\r\n\t\t\t\t\tif (dashLength) {\r\n\t\t\t\t\t\tif (!dontStart)\r\n\t\t\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\t\tvar iterator = new PathIterator(this, 32, 0.25,\r\n\t\t\t\t\t\t\t\tstrokeMatrix),\r\n\t\t\t\t\t\t\tlength = iterator.length,\r\n\t\t\t\t\t\t\tfrom = -style.getDashOffset(), to,\r\n\t\t\t\t\t\t\ti = 0;\r\n\t\t\t\t\t\tfrom = from % length;\r\n\t\t\t\t\t\twhile (from > 0) {\r\n\t\t\t\t\t\t\tfrom -= getOffset(i--) + getOffset(i--);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twhile (from < length) {\r\n\t\t\t\t\t\t\tto = from + getOffset(i++);\r\n\t\t\t\t\t\t\tif (from > 0 || to > 0)\r\n\t\t\t\t\t\t\t\titerator.drawPart(ctx,\r\n\t\t\t\t\t\t\t\t\t\tMath.max(from, 0), Math.max(to, 0));\r\n\t\t\t\t\t\t\tfrom = to + getOffset(i++);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tctx.stroke();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_drawSelected: function(ctx, matrix) {\r\n\t\t\tctx.beginPath();\r\n\t\t\tdrawSegments(ctx, this, matrix);\r\n\t\t\tctx.stroke();\r\n\t\t\tdrawHandles(ctx, this._segments, matrix, paper.settings.handleSize);\r\n\t\t}\r\n\t};\r\n},\r\nnew function() {\r\n\tfunction getFirstControlPoints(rhs) {\r\n\t\tvar n = rhs.length,\r\n\t\t\tx = [],\r\n\t\t\ttmp = [],\r\n\t\t\tb = 2;\r\n\t\tx[0] = rhs[0] / b;\r\n\t\tfor (var i = 1; i < n; i++) {\r\n\t\t\ttmp[i] = 1 / b;\r\n\t\t\tb = (i < n - 1 ? 4 : 2) - tmp[i];\r\n\t\t\tx[i] = (rhs[i] - x[i - 1]) / b;\r\n\t\t}\r\n\t\tfor (var i = 1; i < n; i++) {\r\n\t\t\tx[n - i - 1] -= tmp[n - i] * x[n - i];\r\n\t\t}\r\n\t\treturn x;\r\n\t}\r\n\r\n\treturn {\r\n\t\tsmooth: function() {\r\n\t\t\tvar segments = this._segments,\r\n\t\t\t\tsize = segments.length,\r\n\t\t\t\tclosed = this._closed,\r\n\t\t\t\tn = size,\r\n\t\t\t\toverlap = 0;\r\n\t\t\tif (size <= 2)\r\n\t\t\t\treturn;\r\n\t\t\tif (closed) {\r\n\t\t\t\toverlap = Math.min(size, 4);\r\n\t\t\t\tn += Math.min(size, overlap) * 2;\r\n\t\t\t}\r\n\t\t\tvar knots = [];\r\n\t\t\tfor (var i = 0; i < size; i++)\r\n\t\t\t\tknots[i + overlap] = segments[i]._point;\r\n\t\t\tif (closed) {\r\n\t\t\t\tfor (var i = 0; i < overlap; i++) {\r\n\t\t\t\t\tknots[i] = segments[i + size - overlap]._point;\r\n\t\t\t\t\tknots[i + size + overlap] = segments[i]._point;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tn--;\r\n\t\t\t}\r\n\t\t\tvar rhs = [];\r\n\r\n\t\t\tfor (var i = 1; i < n - 1; i++)\r\n\t\t\t\trhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;\r\n\t\t\trhs[0] = knots[0]._x + 2 * knots[1]._x;\r\n\t\t\trhs[n - 1] = 3 * knots[n - 1]._x;\r\n\t\t\tvar x = getFirstControlPoints(rhs);\r\n\r\n\t\t\tfor (var i = 1; i < n - 1; i++)\r\n\t\t\t\trhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;\r\n\t\t\trhs[0] = knots[0]._y + 2 * knots[1]._y;\r\n\t\t\trhs[n - 1] = 3 * knots[n - 1]._y;\r\n\t\t\tvar y = getFirstControlPoints(rhs);\r\n\r\n\t\t\tif (closed) {\r\n\t\t\t\tfor (var i = 0, j = size; i < overlap; i++, j++) {\r\n\t\t\t\t\tvar f1 = i / overlap,\r\n\t\t\t\t\t\tf2 = 1 - f1,\r\n\t\t\t\t\t\tie = i + overlap,\r\n\t\t\t\t\t\tje = j + overlap;\r\n\t\t\t\t\tx[j] = x[i] * f1 + x[j] * f2;\r\n\t\t\t\t\ty[j] = y[i] * f1 + y[j] * f2;\r\n\t\t\t\t\tx[je] = x[ie] * f2 + x[je] * f1;\r\n\t\t\t\t\ty[je] = y[ie] * f2 + y[je] * f1;\r\n\t\t\t\t}\r\n\t\t\t\tn--;\r\n\t\t\t}\r\n\t\t\tvar handleIn = null;\r\n\t\t\tfor (var i = overlap; i <= n - overlap; i++) {\r\n\t\t\t\tvar segment = segments[i - overlap];\r\n\t\t\t\tif (handleIn)\r\n\t\t\t\t\tsegment.setHandleIn(handleIn.subtract(segment._point));\r\n\t\t\t\tif (i < n) {\r\n\t\t\t\t\tsegment.setHandleOut(\r\n\t\t\t\t\t\t\tnew Point(x[i], y[i]).subtract(segment._point));\r\n\t\t\t\t\thandleIn = i < n - 1\r\n\t\t\t\t\t\t\t? new Point(\r\n\t\t\t\t\t\t\t\t2 * knots[i + 1]._x - x[i + 1],\r\n\t\t\t\t\t\t\t\t2 * knots[i + 1]._y - y[i + 1])\r\n\t\t\t\t\t\t\t: new Point(\r\n\t\t\t\t\t\t\t\t(knots[n]._x + x[n - 1]) / 2,\r\n\t\t\t\t\t\t\t\t(knots[n]._y + y[n - 1]) / 2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (closed && handleIn) {\r\n\t\t\t\tvar segment = this._segments[0];\r\n\t\t\t\tsegment.setHandleIn(handleIn.subtract(segment._point));\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n},\r\nnew function() {\r\n\tfunction getCurrentSegment(that) {\r\n\t\tvar segments = that._segments;\r\n\t\tif (segments.length === 0)\r\n\t\t\tthrow new Error('Use a moveTo() command first');\r\n\t\treturn segments[segments.length - 1];\r\n\t}\r\n\r\n\treturn {\r\n\t\tmoveTo: function() {\r\n\t\t\tvar segments = this._segments;\r\n\t\t\tif (segments.length === 1)\r\n\t\t\t\tthis.removeSegment(0);\r\n\t\t\tif (!segments.length)\r\n\t\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\r\n\t\t},\r\n\r\n\t\tmoveBy: function() {\r\n\t\t\tthrow new Error('moveBy() is unsupported on Path items.');\r\n\t\t},\r\n\r\n\t\tlineTo: function() {\r\n\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\r\n\t\t},\r\n\r\n\t\tcubicCurveTo: function() {\r\n\t\t\tvar handle1 = Point.read(arguments),\r\n\t\t\t\thandle2 = Point.read(arguments),\r\n\t\t\t\tto = Point.read(arguments),\r\n\t\t\t\tcurrent = getCurrentSegment(this);\r\n\t\t\tcurrent.setHandleOut(handle1.subtract(current._point));\r\n\t\t\tthis._add([ new Segment(to, handle2.subtract(to)) ]);\r\n\t\t},\r\n\r\n\t\tquadraticCurveTo: function() {\r\n\t\t\tvar handle = Point.read(arguments),\r\n\t\t\t\tto = Point.read(arguments),\r\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\r\n\t\t\tthis.cubicCurveTo(\r\n\t\t\t\thandle.add(current.subtract(handle).multiply(1 / 3)),\r\n\t\t\t\thandle.add(to.subtract(handle).multiply(1 / 3)),\r\n\t\t\t\tto\r\n\t\t\t);\r\n\t\t},\r\n\r\n\t\tcurveTo: function() {\r\n\t\t\tvar through = Point.read(arguments),\r\n\t\t\t\tto = Point.read(arguments),\r\n\t\t\t\tt = Base.pick(Base.read(arguments), 0.5),\r\n\t\t\t\tt1 = 1 - t,\r\n\t\t\t\tcurrent = getCurrentSegment(this)._point,\r\n\t\t\t\thandle = through.subtract(current.multiply(t1 * t1))\r\n\t\t\t\t\t.subtract(to.multiply(t * t)).divide(2 * t * t1);\r\n\t\t\tif (handle.isNaN())\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t'Cannot put a curve through points with parameter = ' + t);\r\n\t\t\tthis.quadraticCurveTo(handle, to);\r\n\t\t},\r\n\r\n\t\tarcTo: function() {\r\n\t\t\tvar current = getCurrentSegment(this),\r\n\t\t\t\tfrom = current._point,\r\n\t\t\t\tto = Point.read(arguments),\r\n\t\t\t\tthrough,\r\n\t\t\t\tpeek = Base.peek(arguments),\r\n\t\t\t\tclockwise = Base.pick(peek, true),\r\n\t\t\t\tcenter, extent, vector, matrix;\r\n\t\t\tif (typeof clockwise === 'boolean') {\r\n\t\t\t\tvar middle = from.add(to).divide(2),\r\n\t\t\t\tthrough = middle.add(middle.subtract(from).rotate(\r\n\t\t\t\t\t\tclockwise ? -90 : 90));\r\n\t\t\t} else if (Base.remain(arguments) <= 2) {\r\n\t\t\t\tthrough = to;\r\n\t\t\t\tto = Point.read(arguments);\r\n\t\t\t} else {\r\n\t\t\t\tvar radius = Size.read(arguments);\r\n\t\t\t\tif (radius.isZero())\r\n\t\t\t\t\treturn this.lineTo(to);\r\n\t\t\t\tvar rotation = Base.read(arguments),\r\n\t\t\t\t\tclockwise = !!Base.read(arguments),\r\n\t\t\t\t\tlarge = !!Base.read(arguments),\r\n\t\t\t\t\tmiddle = from.add(to).divide(2),\r\n\t\t\t\t\tpt = from.subtract(middle).rotate(-rotation),\r\n\t\t\t\t\tx = pt.x,\r\n\t\t\t\t\ty = pt.y,\r\n\t\t\t\t\tabs = Math.abs,\r\n\t\t\t\t\trx = abs(radius.width),\r\n\t\t\t\t\try = abs(radius.height),\r\n\t\t\t\t\trxSq = rx * rx,\r\n\t\t\t\t\trySq = ry * ry,\r\n\t\t\t\t\txSq =  x * x,\r\n\t\t\t\t\tySq =  y * y;\r\n\t\t\t\tvar factor = Math.sqrt(xSq / rxSq + ySq / rySq);\r\n\t\t\t\tif (factor > 1) {\r\n\t\t\t\t\trx *= factor;\r\n\t\t\t\t\try *= factor;\r\n\t\t\t\t\trxSq = rx * rx;\r\n\t\t\t\t\trySq = ry * ry;\r\n\t\t\t\t}\r\n\t\t\t\tfactor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /\r\n\t\t\t\t\t\t(rxSq * ySq + rySq * xSq);\r\n\t\t\t\tif (abs(factor) < 1e-12)\r\n\t\t\t\t\tfactor = 0;\r\n\t\t\t\tif (factor < 0)\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\r\n\t\t\t\tcenter = new Point(rx * y / ry, -ry * x / rx)\r\n\t\t\t\t\t\t.multiply((large === clockwise ? -1 : 1)\r\n\t\t\t\t\t\t\t* Math.sqrt(factor))\r\n\t\t\t\t\t\t.rotate(rotation).add(middle);\r\n\t\t\t\tmatrix = new Matrix().translate(center).rotate(rotation)\r\n\t\t\t\t\t\t.scale(rx, ry);\r\n\t\t\t\tvector = matrix._inverseTransform(from);\r\n\t\t\t\textent = vector.getDirectedAngle(matrix._inverseTransform(to));\r\n\t\t\t\tif (!clockwise && extent > 0)\r\n\t\t\t\t\textent -= 360;\r\n\t\t\t\telse if (clockwise && extent < 0)\r\n\t\t\t\t\textent += 360;\r\n\t\t\t}\r\n\t\t\tif (through) {\r\n\t\t\t\tvar l1 = new Line(from.add(through).divide(2),\r\n\t\t\t\t\t\t\tthrough.subtract(from).rotate(90), true),\r\n\t\t\t\t\tl2 = new Line(through.add(to).divide(2),\r\n\t\t\t\t\t\t\tto.subtract(through).rotate(90), true),\r\n\t\t\t\t\tline = new Line(from, to),\r\n\t\t\t\t\tthroughSide = line.getSide(through);\r\n\t\t\t\tcenter = l1.intersect(l2, true);\r\n\t\t\t\tif (!center) {\r\n\t\t\t\t\tif (!throughSide)\r\n\t\t\t\t\t\treturn this.lineTo(to);\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\r\n\t\t\t\t}\r\n\t\t\t\tvector = from.subtract(center);\r\n\t\t\t\textent = vector.getDirectedAngle(to.subtract(center));\r\n\t\t\t\tvar centerSide = line.getSide(center);\r\n\t\t\t\tif (centerSide === 0) {\r\n\t\t\t\t\textent = throughSide * Math.abs(extent);\r\n\t\t\t\t} else if (throughSide === centerSide) {\r\n\t\t\t\t\textent += extent < 0 ? 360 : -360;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar ext = Math.abs(extent),\r\n\t\t\t\tcount = ext >= 360 ? 4 : Math.ceil(ext / 90),\r\n\t\t\t\tinc = extent / count,\r\n\t\t\t\thalf = inc * Math.PI / 360,\r\n\t\t\t\tz = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),\r\n\t\t\t\tsegments = [];\r\n\t\t\tfor (var i = 0; i <= count; i++) {\r\n\t\t\t\tvar pt = to,\r\n\t\t\t\t\tout = null;\r\n\t\t\t\tif (i < count) {\r\n\t\t\t\t\tout = vector.rotate(90).multiply(z);\r\n\t\t\t\t\tif (matrix) {\r\n\t\t\t\t\t\tpt = matrix._transformPoint(vector);\r\n\t\t\t\t\t\tout = matrix._transformPoint(vector.add(out))\r\n\t\t\t\t\t\t\t\t.subtract(pt);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpt = center.add(vector);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (i === 0) {\r\n\t\t\t\t\tcurrent.setHandleOut(out);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar _in = vector.rotate(-90).multiply(z);\r\n\t\t\t\t\tif (matrix) {\r\n\t\t\t\t\t\t_in = matrix._transformPoint(vector.add(_in))\r\n\t\t\t\t\t\t\t\t.subtract(pt);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsegments.push(new Segment(pt, _in, out));\r\n\t\t\t\t}\r\n\t\t\t\tvector = vector.rotate(inc);\r\n\t\t\t}\r\n\t\t\tthis._add(segments);\r\n\t\t},\r\n\r\n\t\tlineBy: function() {\r\n\t\t\tvar to = Point.read(arguments),\r\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\r\n\t\t\tthis.lineTo(current.add(to));\r\n\t\t},\r\n\r\n\t\tcurveBy: function() {\r\n\t\t\tvar through = Point.read(arguments),\r\n\t\t\t\tto = Point.read(arguments),\r\n\t\t\t\tparameter = Base.read(arguments),\r\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\r\n\t\t\tthis.curveTo(current.add(through), current.add(to), parameter);\r\n\t\t},\r\n\r\n\t\tcubicCurveBy: function() {\r\n\t\t\tvar handle1 = Point.read(arguments),\r\n\t\t\t\thandle2 = Point.read(arguments),\r\n\t\t\t\tto = Point.read(arguments),\r\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\r\n\t\t\tthis.cubicCurveTo(current.add(handle1), current.add(handle2),\r\n\t\t\t\t\tcurrent.add(to));\r\n\t\t},\r\n\r\n\t\tquadraticCurveBy: function() {\r\n\t\t\tvar handle = Point.read(arguments),\r\n\t\t\t\tto = Point.read(arguments),\r\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\r\n\t\t\tthis.quadraticCurveTo(current.add(handle), current.add(to));\r\n\t\t},\r\n\r\n\t\tarcBy: function() {\r\n\t\t\tvar current = getCurrentSegment(this)._point,\r\n\t\t\t\tpoint = current.add(Point.read(arguments)),\r\n\t\t\t\tclockwise = Base.pick(Base.peek(arguments), true);\r\n\t\t\tif (typeof clockwise === 'boolean') {\r\n\t\t\t\tthis.arcTo(point, clockwise);\r\n\t\t\t} else {\r\n\t\t\t\tthis.arcTo(point, current.add(Point.read(arguments)));\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tclosePath: function(join) {\r\n\t\t\tthis.setClosed(true);\r\n\t\t\tif (join)\r\n\t\t\t\tthis.join();\r\n\t\t}\r\n\t};\r\n}, {\r\n\r\n\t_getBounds: function(getter, matrix) {\r\n\t\treturn Path[getter](this._segments, this._closed, this.getStyle(),\r\n\t\t\t\tmatrix);\r\n\t},\r\n\r\nstatics: {\r\n\tgetBounds: function(segments, closed, style, matrix, strokePadding) {\r\n\t\tvar first = segments[0];\r\n\t\tif (!first)\r\n\t\t\treturn new Rectangle();\r\n\t\tvar coords = new Array(6),\r\n\t\t\tprevCoords = first._transformCoordinates(matrix, new Array(6), false),\r\n\t\t\tmin = prevCoords.slice(0, 2),\r\n\t\t\tmax = min.slice(),\r\n\t\t\troots = new Array(2);\r\n\r\n\t\tfunction processSegment(segment) {\r\n\t\t\tsegment._transformCoordinates(matrix, coords, false);\r\n\t\t\tfor (var i = 0; i < 2; i++) {\r\n\t\t\t\tCurve._addBounds(\r\n\t\t\t\t\tprevCoords[i],\r\n\t\t\t\t\tprevCoords[i + 4],\r\n\t\t\t\t\tcoords[i + 2],\r\n\t\t\t\t\tcoords[i],\r\n\t\t\t\t\ti, strokePadding ? strokePadding[i] : 0, min, max, roots);\r\n\t\t\t}\r\n\t\t\tvar tmp = prevCoords;\r\n\t\t\tprevCoords = coords;\r\n\t\t\tcoords = tmp;\r\n\t\t}\r\n\r\n\t\tfor (var i = 1, l = segments.length; i < l; i++)\r\n\t\t\tprocessSegment(segments[i]);\r\n\t\tif (closed)\r\n\t\t\tprocessSegment(first);\r\n\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\r\n\t},\r\n\r\n\tgetStrokeBounds: function(segments, closed, style, matrix) {\r\n\t\tif (!style.hasStroke())\r\n\t\t\treturn Path.getBounds(segments, closed, style, matrix);\r\n\t\tvar length = segments.length - (closed ? 0 : 1),\r\n\t\t\tradius = style.getStrokeWidth() / 2,\r\n\t\t\tpadding = Path._getPenPadding(radius, matrix),\r\n\t\t\tbounds = Path.getBounds(segments, closed, style, matrix, padding),\r\n\t\t\tjoin = style.getStrokeJoin(),\r\n\t\t\tcap = style.getStrokeCap(),\r\n\t\t\tmiterLimit = radius * style.getMiterLimit();\r\n\t\tvar joinBounds = new Rectangle(new Size(padding).multiply(2));\r\n\r\n\t\tfunction add(point) {\r\n\t\t\tbounds = bounds.include(matrix\r\n\t\t\t\t? matrix._transformPoint(point, point) : point);\r\n\t\t}\r\n\r\n\t\tfunction addRound(segment) {\r\n\t\t\tbounds = bounds.unite(joinBounds.setCenter(matrix\r\n\t\t\t\t? matrix._transformPoint(segment._point) : segment._point));\r\n\t\t}\r\n\r\n\t\tfunction addJoin(segment, join) {\r\n\t\t\tvar handleIn = segment._handleIn,\r\n\t\t\t\thandleOut = segment._handleOut;\r\n\t\t\tif (join === 'round' || !handleIn.isZero() && !handleOut.isZero()\r\n\t\t\t\t\t&& handleIn.isCollinear(handleOut)) {\r\n\t\t\t\taddRound(segment);\r\n\t\t\t} else {\r\n\t\t\t\tPath._addBevelJoin(segment, join, radius, miterLimit, add);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction addCap(segment, cap) {\r\n\t\t\tif (cap === 'round') {\r\n\t\t\t\taddRound(segment);\r\n\t\t\t} else {\r\n\t\t\t\tPath._addSquareCap(segment, cap, radius, add);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var i = 1; i < length; i++)\r\n\t\t\taddJoin(segments[i], join);\r\n\t\tif (closed) {\r\n\t\t\taddJoin(segments[0], join);\r\n\t\t} else if (length > 0) {\r\n\t\t\taddCap(segments[0], cap);\r\n\t\t\taddCap(segments[segments.length - 1], cap);\r\n\t\t}\r\n\t\treturn bounds;\r\n\t},\r\n\r\n\t_getPenPadding: function(radius, matrix) {\r\n\t\tif (!matrix)\r\n\t\t\treturn [radius, radius];\r\n\t\tvar mx = matrix.shiftless(),\r\n\t\t\thor = mx.transform(new Point(radius, 0)),\r\n\t\t\tver = mx.transform(new Point(0, radius)),\r\n\t\t\tphi = hor.getAngleInRadians(),\r\n\t\t\ta = hor.getLength(),\r\n\t\t\tb = ver.getLength();\r\n\t\tvar sin = Math.sin(phi),\r\n\t\t\tcos = Math.cos(phi),\r\n\t\t\ttan = Math.tan(phi),\r\n\t\t\ttx = -Math.atan(b * tan / a),\r\n\t\t\tty = Math.atan(b / (tan * a));\r\n\t\treturn [Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin),\r\n\t\t\t\tMath.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];\r\n\t},\r\n\r\n\t_addBevelJoin: function(segment, join, radius, miterLimit, addPoint, area) {\r\n\t\tvar curve2 = segment.getCurve(),\r\n\t\t\tcurve1 = curve2.getPrevious(),\r\n\t\t\tpoint = curve2.getPointAt(0, true),\r\n\t\t\tnormal1 = curve1.getNormalAt(1, true),\r\n\t\t\tnormal2 = curve2.getNormalAt(0, true),\r\n\t\t\tstep = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;\r\n\t\tnormal1.setLength(step);\r\n\t\tnormal2.setLength(step);\r\n\t\tif (area) {\r\n\t\t\taddPoint(point);\r\n\t\t\taddPoint(point.add(normal1));\r\n\t\t}\r\n\t\tif (join === 'miter') {\r\n\t\t\tvar corner = new Line(\r\n\t\t\t\t\tpoint.add(normal1),\r\n\t\t\t\t\tnew Point(-normal1.y, normal1.x), true\r\n\t\t\t\t).intersect(new Line(\r\n\t\t\t\t\tpoint.add(normal2),\r\n\t\t\t\t\tnew Point(-normal2.y, normal2.x), true\r\n\t\t\t\t), true);\r\n\t\t\tif (corner && point.getDistance(corner) <= miterLimit) {\r\n\t\t\t\taddPoint(corner);\r\n\t\t\t\tif (!area)\r\n\t\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!area)\r\n\t\t\taddPoint(point.add(normal1));\r\n\t\taddPoint(point.add(normal2));\r\n\t},\r\n\r\n\t_addSquareCap: function(segment, cap, radius, addPoint, area) {\r\n\t\tvar point = segment._point,\r\n\t\t\tloc = segment.getLocation(),\r\n\t\t\tnormal = loc.getNormal().multiply(radius);\r\n\t\tif (area) {\r\n\t\t\taddPoint(point.subtract(normal));\r\n\t\t\taddPoint(point.add(normal));\r\n\t\t}\r\n\t\tif (cap === 'square')\r\n\t\t\tpoint = point.add(normal.rotate(loc.getParameter() === 0 ? -90 : 90));\r\n\t\taddPoint(point.add(normal));\r\n\t\taddPoint(point.subtract(normal));\r\n\t},\r\n\r\n\tgetHandleBounds: function(segments, closed, style, matrix, strokePadding,\r\n\t\t\tjoinPadding) {\r\n\t\tvar coords = new Array(6),\r\n\t\t\tx1 = Infinity,\r\n\t\t\tx2 = -x1,\r\n\t\t\ty1 = x1,\r\n\t\t\ty2 = x2;\r\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\r\n\t\t\tvar segment = segments[i];\r\n\t\t\tsegment._transformCoordinates(matrix, coords, false);\r\n\t\t\tfor (var j = 0; j < 6; j += 2) {\r\n\t\t\t\tvar padding = j === 0 ? joinPadding : strokePadding,\r\n\t\t\t\t\tpaddingX = padding ? padding[0] : 0,\r\n\t\t\t\t\tpaddingY = padding ? padding[1] : 0,\r\n\t\t\t\t\tx = coords[j],\r\n\t\t\t\t\ty = coords[j + 1],\r\n\t\t\t\t\txn = x - paddingX,\r\n\t\t\t\t\txx = x + paddingX,\r\n\t\t\t\t\tyn = y - paddingY,\r\n\t\t\t\t\tyx = y + paddingY;\r\n\t\t\t\tif (xn < x1) x1 = xn;\r\n\t\t\t\tif (xx > x2) x2 = xx;\r\n\t\t\t\tif (yn < y1) y1 = yn;\r\n\t\t\t\tif (yx > y2) y2 = yx;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\r\n\t},\r\n\r\n\tgetRoughBounds: function(segments, closed, style, matrix) {\r\n\t\tvar strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0,\r\n\t\t\tjoinRadius = strokeRadius;\r\n\t\tif (strokeRadius > 0) {\r\n\t\t\tif (style.getStrokeJoin() === 'miter')\r\n\t\t\t\tjoinRadius = strokeRadius * style.getMiterLimit();\r\n\t\t\tif (style.getStrokeCap() === 'square')\r\n\t\t\t\tjoinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2));\r\n\t\t}\r\n\t\treturn Path.getHandleBounds(segments, closed, style, matrix,\r\n\t\t\t\tPath._getPenPadding(strokeRadius, matrix),\r\n\t\t\t\tPath._getPenPadding(joinRadius, matrix));\r\n\t}\r\n}});\r\n\r\nPath.inject({ statics: new function() {\r\n\r\n\tvar kappa = 0.5522847498307936,\r\n\t\tellipseSegments = [\r\n\t\t\tnew Segment([-1, 0], [0, kappa ], [0, -kappa]),\r\n\t\t\tnew Segment([0, -1], [-kappa, 0], [kappa, 0 ]),\r\n\t\t\tnew Segment([1, 0], [0, -kappa], [0, kappa ]),\r\n\t\t\tnew Segment([0, 1], [kappa, 0 ], [-kappa, 0])\r\n\t\t];\r\n\r\n\tfunction createPath(segments, closed, args) {\r\n\t\tvar props = Base.getNamed(args),\r\n\t\t\tpath = new Path(props && props.insert === false && Item.NO_INSERT);\r\n\t\tpath._add(segments);\r\n\t\tpath._closed = closed;\r\n\t\treturn path.set(props);\r\n\t}\r\n\r\n\tfunction createEllipse(center, radius, args) {\r\n\t\tvar segments = new Array(4);\r\n\t\tfor (var i = 0; i < 4; i++) {\r\n\t\t\tvar segment = ellipseSegments[i];\r\n\t\t\tsegments[i] = new Segment(\r\n\t\t\t\tsegment._point.multiply(radius).add(center),\r\n\t\t\t\tsegment._handleIn.multiply(radius),\r\n\t\t\t\tsegment._handleOut.multiply(radius)\r\n\t\t\t);\r\n\t\t}\r\n\t\treturn createPath(segments, true, args);\r\n\t}\r\n\r\n\treturn {\r\n\t\tLine: function() {\r\n\t\t\treturn createPath([\r\n\t\t\t\tnew Segment(Point.readNamed(arguments, 'from')),\r\n\t\t\t\tnew Segment(Point.readNamed(arguments, 'to'))\r\n\t\t\t], false, arguments);\r\n\t\t},\r\n\r\n\t\tCircle: function() {\r\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\r\n\t\t\t\tradius = Base.readNamed(arguments, 'radius');\r\n\t\t\treturn createEllipse(center, new Size(radius), arguments);\r\n\t\t},\r\n\r\n\t\tRectangle: function() {\r\n\t\t\tvar rect = Rectangle.readNamed(arguments, 'rectangle'),\r\n\t\t\t\tradius = Size.readNamed(arguments, 'radius', 0,\r\n\t\t\t\t\t\t{ readNull: true }),\r\n\t\t\t\tbl = rect.getBottomLeft(true),\r\n\t\t\t\ttl = rect.getTopLeft(true),\r\n\t\t\t\ttr = rect.getTopRight(true),\r\n\t\t\t\tbr = rect.getBottomRight(true),\r\n\t\t\t\tsegments;\r\n\t\t\tif (!radius || radius.isZero()) {\r\n\t\t\t\tsegments = [\r\n\t\t\t\t\tnew Segment(bl),\r\n\t\t\t\t\tnew Segment(tl),\r\n\t\t\t\t\tnew Segment(tr),\r\n\t\t\t\t\tnew Segment(br)\r\n\t\t\t\t];\r\n\t\t\t} else {\r\n\t\t\t\tradius = Size.min(radius, rect.getSize(true).divide(2));\r\n\t\t\t\tvar rx = radius.width,\r\n\t\t\t\t\try = radius.height,\r\n\t\t\t\t\thx = rx * kappa,\r\n\t\t\t\t\thy = ry * kappa;\r\n\t\t\t\tsegments = [\r\n\t\t\t\t\tnew Segment(bl.add(rx, 0), null, [-hx, 0]),\r\n\t\t\t\t\tnew Segment(bl.subtract(0, ry), [0, hy]),\r\n\t\t\t\t\tnew Segment(tl.add(0, ry), null, [0, -hy]),\r\n\t\t\t\t\tnew Segment(tl.add(rx, 0), [-hx, 0], null),\r\n\t\t\t\t\tnew Segment(tr.subtract(rx, 0), null, [hx, 0]),\r\n\t\t\t\t\tnew Segment(tr.add(0, ry), [0, -hy], null),\r\n\t\t\t\t\tnew Segment(br.subtract(0, ry), null, [0, hy]),\r\n\t\t\t\t\tnew Segment(br.subtract(rx, 0), [hx, 0])\r\n\t\t\t\t];\r\n\t\t\t}\r\n\t\t\treturn createPath(segments, true, arguments);\r\n\t\t},\r\n\r\n\t\tRoundRectangle: '#Rectangle',\r\n\r\n\t\tEllipse: function() {\r\n\t\t\tvar ellipse = Shape._readEllipse(arguments);\r\n\t\t\treturn createEllipse(ellipse.center, ellipse.radius, arguments);\r\n\t\t},\r\n\r\n\t\tOval: '#Ellipse',\r\n\r\n\t\tArc: function() {\r\n\t\t\tvar from = Point.readNamed(arguments, 'from'),\r\n\t\t\t\tthrough = Point.readNamed(arguments, 'through'),\r\n\t\t\t\tto = Point.readNamed(arguments, 'to'),\r\n\t\t\t\tprops = Base.getNamed(arguments),\r\n\t\t\t\tpath = new Path(props && props.insert === false\r\n\t\t\t\t\t\t&& Item.NO_INSERT);\r\n\t\t\tpath.moveTo(from);\r\n\t\t\tpath.arcTo(through, to);\r\n\t\t\treturn path.set(props);\r\n\t\t},\r\n\r\n\t\tRegularPolygon: function() {\r\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\r\n\t\t\t\tsides = Base.readNamed(arguments, 'sides'),\r\n\t\t\t\tradius = Base.readNamed(arguments, 'radius'),\r\n\t\t\t\tstep = 360 / sides,\r\n\t\t\t\tthree = !(sides % 3),\r\n\t\t\t\tvector = new Point(0, three ? -radius : radius),\r\n\t\t\t\toffset = three ? -1 : 0.5,\r\n\t\t\t\tsegments = new Array(sides);\r\n\t\t\tfor (var i = 0; i < sides; i++)\r\n\t\t\t\tsegments[i] = new Segment(center.add(\r\n\t\t\t\t\tvector.rotate((i + offset) * step)));\r\n\t\t\treturn createPath(segments, true, arguments);\r\n\t\t},\r\n\r\n\t\tStar: function() {\r\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\r\n\t\t\t\tpoints = Base.readNamed(arguments, 'points') * 2,\r\n\t\t\t\tradius1 = Base.readNamed(arguments, 'radius1'),\r\n\t\t\t\tradius2 = Base.readNamed(arguments, 'radius2'),\r\n\t\t\t\tstep = 360 / points,\r\n\t\t\t\tvector = new Point(0, -1),\r\n\t\t\t\tsegments = new Array(points);\r\n\t\t\tfor (var i = 0; i < points; i++)\r\n\t\t\t\tsegments[i] = new Segment(center.add(vector.rotate(step * i)\r\n\t\t\t\t\t\t.multiply(i % 2 ? radius2 : radius1)));\r\n\t\t\treturn createPath(segments, true, arguments);\r\n\t\t}\r\n\t};\r\n}});\r\n\r\nvar CompoundPath = PathItem.extend({\r\n\t_class: 'CompoundPath',\r\n\t_serializeFields: {\r\n\t\tchildren: []\r\n\t},\r\n\r\n\tinitialize: function CompoundPath(arg) {\r\n\t\tthis._children = [];\r\n\t\tthis._namedChildren = {};\r\n\t\tif (!this._initialize(arg)) {\r\n\t\t\tif (typeof arg === 'string') {\r\n\t\t\t\tthis.setPathData(arg);\r\n\t\t\t} else {\r\n\t\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tinsertChildren: function insertChildren(index, items, _preserve) {\r\n\t\tfor (var i = items.length - 1; i >= 0; i--) {\r\n\t\t\tvar item = items[i];\r\n\t\t\tif (item instanceof CompoundPath) {\r\n\t\t\t\titems.splice.apply(items, [i, 1].concat(item.removeChildren()));\r\n\t\t\t\titem.remove();\r\n\t\t\t}\r\n\t\t}\r\n\t\titems = insertChildren.base.call(this, index, items, _preserve, Path);\r\n\t\tfor (var i = 0, l = !_preserve && items && items.length; i < l; i++) {\r\n\t\t\tvar item = items[i];\r\n\t\t\tif (item._clockwise === undefined)\r\n\t\t\t\titem.setClockwise(item._index === 0);\r\n\t\t}\r\n\t\treturn items;\r\n\t},\r\n\r\n\treverse: function() {\r\n\t\tvar children = this._children;\r\n\t\tfor (var i = 0, l = children.length; i < l; i++)\r\n\t\t\tchildren[i].reverse();\r\n\t},\r\n\r\n\tsmooth: function() {\r\n\t\tfor (var i = 0, l = this._children.length; i < l; i++)\r\n\t\t\tthis._children[i].smooth();\r\n\t},\r\n\r\n\treduce: function reduce() {\r\n\t\tvar children = this._children;\r\n\t\tfor (var i = children.length - 1; i >= 0; i--) {\r\n\t\t\tvar path = children[i].reduce();\r\n\t\t\tif (path.isEmpty())\r\n\t\t\t\tchildren.splice(i, 1);\r\n\t\t}\r\n\t\tif (children.length === 0) {\r\n\t\t\tvar path = new Path(Item.NO_INSERT);\r\n\t\t\tpath.insertAbove(this);\r\n\t\t\tpath.setStyle(this._style);\r\n\t\t\tthis.remove();\r\n\t\t\treturn path;\r\n\t\t}\r\n\t\treturn reduce.base.call(this);\r\n\t},\r\n\r\n\tisClockwise: function() {\r\n\t\tvar child = this.getFirstChild();\r\n\t\treturn child && child.isClockwise();\r\n\t},\r\n\r\n\tsetClockwise: function(clockwise) {\r\n\t\tif (this.isClockwise() !== !!clockwise)\r\n\t\t\tthis.reverse();\r\n\t},\r\n\r\n\tgetFirstSegment: function() {\r\n\t\tvar first = this.getFirstChild();\r\n\t\treturn first && first.getFirstSegment();\r\n\t},\r\n\r\n\tgetLastSegment: function() {\r\n\t\tvar last = this.getLastChild();\r\n\t\treturn last && last.getLastSegment();\r\n\t},\r\n\r\n\tgetCurves: function() {\r\n\t\tvar children = this._children,\r\n\t\t\tcurves = [];\r\n\t\tfor (var i = 0, l = children.length; i < l; i++)\r\n\t\t\tcurves.push.apply(curves, children[i].getCurves());\r\n\t\treturn curves;\r\n\t},\r\n\r\n\tgetFirstCurve: function() {\r\n\t\tvar first = this.getFirstChild();\r\n\t\treturn first && first.getFirstCurve();\r\n\t},\r\n\r\n\tgetLastCurve: function() {\r\n\t\tvar last = this.getLastChild();\r\n\t\treturn last && last.getFirstCurve();\r\n\t},\r\n\r\n\tgetArea: function() {\r\n\t\tvar children = this._children,\r\n\t\t\tarea = 0;\r\n\t\tfor (var i = 0, l = children.length; i < l; i++)\r\n\t\t\tarea += children[i].getArea();\r\n\t\treturn area;\r\n\t}\r\n}, {\r\n\tbeans: true,\r\n\r\n\tgetPathData: function(_matrix, _precision) {\r\n\t\tvar children = this._children,\r\n\t\t\tpaths = [];\r\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\r\n\t\t\tvar child = children[i],\r\n\t\t\t\tmx = child._matrix;\r\n\t\t\tpaths.push(child.getPathData(_matrix && !mx.isIdentity()\r\n\t\t\t\t\t? _matrix.chain(mx) : _matrix, _precision));\r\n\t\t}\r\n\t\treturn paths.join(' ');\r\n\t}\r\n}, {\r\n\t_getChildHitTestOptions: function(options) {\r\n\t\treturn options.class === Path || options.type === 'path'\r\n\t\t\t\t? options\r\n\t\t\t\t: new Base(options, { fill: false });\r\n\t},\r\n\r\n\t_draw: function(ctx, param, strokeMatrix) {\r\n\t\tvar children = this._children;\r\n\t\tif (children.length === 0)\r\n\t\t\treturn;\r\n\r\n\t\tif (this._currentPath) {\r\n\t\t\tctx.currentPath = this._currentPath;\r\n\t\t} else {\r\n\t\t\tparam = param.extend({ dontStart: true, dontFinish: true });\r\n\t\t\tctx.beginPath();\r\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\r\n\t\t\t\tchildren[i].draw(ctx, param, strokeMatrix);\r\n\t\t\tthis._currentPath = ctx.currentPath;\r\n\t\t}\r\n\r\n\t\tif (!param.clip) {\r\n\t\t\tthis._setStyles(ctx);\r\n\t\t\tvar style = this._style;\r\n\t\t\tif (style.hasFill()) {\r\n\t\t\t\tctx.fill(style.getWindingRule());\r\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\r\n\t\t\t}\r\n\t\t\tif (style.hasStroke())\r\n\t\t\t\tctx.stroke();\r\n\t\t}\r\n\t},\r\n\r\n\t_drawSelected: function(ctx, matrix, selectedItems) {\r\n\t\tvar children = this._children;\r\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\r\n\t\t\tvar child = children[i],\r\n\t\t\t\tmx = child._matrix;\r\n\t\t\tif (!selectedItems[child._id])\r\n\t\t\t\tchild._drawSelected(ctx, mx.isIdentity() ? matrix\r\n\t\t\t\t\t\t: matrix.chain(mx));\r\n\t\t}\r\n\t}\r\n},\r\nnew function() {\r\n\tfunction getCurrentPath(that, check) {\r\n\t\tvar children = that._children;\r\n\t\tif (check && children.length === 0)\r\n\t\t\tthrow new Error('Use a moveTo() command first');\r\n\t\treturn children[children.length - 1];\r\n\t}\r\n\r\n\tvar fields = {\r\n\t\tmoveTo: function() {\r\n\t\t\tvar current = getCurrentPath(this),\r\n\t\t\t\tpath = current && current.isEmpty() ? current\r\n\t\t\t\t\t\t: new Path(Item.NO_INSERT);\r\n\t\t\tif (path !== current)\r\n\t\t\t\tthis.addChild(path);\r\n\t\t\tpath.moveTo.apply(path, arguments);\r\n\t\t},\r\n\r\n\t\tmoveBy: function() {\r\n\t\t\tvar current = getCurrentPath(this, true),\r\n\t\t\t\tlast = current && current.getLastSegment(),\r\n\t\t\t\tpoint = Point.read(arguments);\r\n\t\t\tthis.moveTo(last ? point.add(last._point) : point);\r\n\t\t},\r\n\r\n\t\tclosePath: function(join) {\r\n\t\t\tgetCurrentPath(this, true).closePath(join);\r\n\t\t}\r\n\t};\r\n\r\n\tBase.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo',\r\n\t\t\t'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'],\r\n\t\t\tfunction(key) {\r\n\t\t\t\tfields[key] = function() {\r\n\t\t\t\t\tvar path = getCurrentPath(this, true);\r\n\t\t\t\t\tpath[key].apply(path, arguments);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t);\r\n\r\n\treturn fields;\r\n});\r\n\r\nPathItem.inject(new function() {\r\n\tvar operators = {\r\n\t\tunite: function(w) {\r\n\t\t\treturn w === 1 || w === 0;\r\n\t\t},\r\n\r\n\t\tintersect: function(w) {\r\n\t\t\treturn w === 2;\r\n\t\t},\r\n\r\n\t\tsubtract: function(w) {\r\n\t\t\treturn w === 1;\r\n\t\t},\r\n\r\n\t\texclude: function(w) {\r\n\t\t\treturn w === 1;\r\n\t\t}\r\n\t};\r\n\r\n\tfunction preparePath(path, resolve) {\r\n\t\tvar res = path.clone(false).reduce().transform(null, true, true);\r\n\t\treturn resolve ? res.resolveCrossings().reorient() : res;\r\n\t}\r\n\r\n\tfunction finishBoolean(ctor, paths, path1, path2, reduce) {\r\n\t\tvar result = new ctor(Item.NO_INSERT);\r\n\t\tresult.addChildren(paths, true);\r\n\t\tif (reduce)\r\n\t\t\tresult = result.reduce();\r\n\t\tresult.insertAbove(path2 && path1.isSibling(path2)\r\n\t\t\t\t&& path1.getIndex() < path2.getIndex()\r\n\t\t\t\t\t? path2 : path1);\r\n\t\tresult.setStyle(path1._style);\r\n\t\treturn result;\r\n\t}\r\n\r\n\tfunction computeBoolean(path1, path2, operation) {\r\n\t\tif (!path1._children && !path1._closed)\r\n\t\t\treturn computeOpenBoolean(path1, path2, operation);\r\n\t\tvar _path1 = preparePath(path1, true),\r\n\t\t\t_path2 = path2 && path1 !== path2 && preparePath(path2, true);\r\n\t\tif (_path2 && /^(subtract|exclude)$/.test(operation)\r\n\t\t\t\t^ (_path2.isClockwise() !== _path1.isClockwise()))\r\n\t\t\t_path2.reverse();\r\n\t\tvar intersections = CurveLocation.expand(\r\n\t\t\t_path1.getIntersections(_path2, function(inter) {\r\n\t\t\t\treturn _path2 && inter.isOverlap() || inter.isCrossing();\r\n\t\t\t})\r\n\t\t);\r\n\t\tdivideLocations(intersections);\r\n\r\n\t\tvar segments = [],\r\n\t\t\tmonoCurves = [];\r\n\r\n\t\tfunction collect(paths) {\r\n\t\t\tfor (var i = 0, l = paths.length; i < l; i++) {\r\n\t\t\t\tvar path = paths[i];\r\n\t\t\t\tsegments.push.apply(segments, path._segments);\r\n\t\t\t\tmonoCurves.push.apply(monoCurves, path._getMonoCurves());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcollect(_path1._children || [_path1]);\r\n\t\tif (_path2)\r\n\t\t\tcollect(_path2._children || [_path2]);\r\n\t\tfor (var i = 0, l = intersections.length; i < l; i++) {\r\n\t\t\tpropagateWinding(intersections[i]._segment, _path1, _path2,\r\n\t\t\t\t\tmonoCurves, operation);\r\n\t\t}\r\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\r\n\t\t\tvar segment = segments[i];\r\n\t\t\tif (segment._winding == null) {\r\n\t\t\t\tpropagateWinding(segment, _path1, _path2, monoCurves,\r\n\t\t\t\t\t\toperation);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn finishBoolean(CompoundPath, tracePaths(segments, operation),\r\n\t\t\t\tpath1, path2, true);\r\n\t}\r\n\r\n\tfunction computeOpenBoolean(path1, path2, operation) {\r\n\t\tif (!path2 || !path2._children && !path2._closed\r\n\t\t\t\t|| !/^(subtract|intersect)$/.test(operation))\r\n\t\t\treturn null;\r\n\t\tvar _path1 = preparePath(path1, false),\r\n\t\t\t_path2 = preparePath(path2, false),\r\n\t\t\tintersections = _path1.getIntersections(_path2, function(inter) {\r\n\t\t\t\treturn inter.isOverlap() || inter.isCrossing();\r\n\t\t\t}),\r\n\t\t\tsub = operation === 'subtract',\r\n\t\t\tpaths = [];\r\n\r\n\t\tfunction addPath(path) {\r\n\t\t\tif (_path2.contains(path.getPointAt(path.getLength() / 2)) ^ sub) {\r\n\t\t\t\tpaths.unshift(path);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var i = intersections.length - 1; i >= 0; i--) {\r\n\t\t\tvar path = intersections[i].split();\r\n\t\t\tif (path) {\r\n\t\t\t\tif (addPath(path))\r\n\t\t\t\t\tpath.getFirstSegment().setHandleIn(0, 0);\r\n\t\t\t\t_path1.getLastSegment().setHandleOut(0, 0);\r\n\t\t\t}\r\n\t\t}\r\n\t\taddPath(_path1);\r\n\t\treturn finishBoolean(Group, paths, path1, path2);\r\n\t}\r\n\r\n\tfunction linkIntersections(from, to) {\r\n\t\tvar prev = from;\r\n\t\twhile (prev) {\r\n\t\t\tif (prev === to)\r\n\t\t\t\treturn;\r\n\t\t\tprev = prev._prev;\r\n\t\t}\r\n\t\twhile (from._next && from._next !== to)\r\n\t\t\tfrom = from._next;\r\n\t\tif (!from._next) {\r\n\t\t\twhile (to._prev)\r\n\t\t\t\tto = to._prev;\r\n\t\t\tfrom._next = to;\r\n\t\t\tto._prev = from;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction divideLocations(locations) {\r\n\t\tvar tMin = 4e-7,\r\n\t\t\ttMax = 1 - tMin,\r\n\t\t\tnoHandles = false,\r\n\t\t\tclearSegments = [],\r\n\t\t\tprevCurve,\r\n\t\t\tprevT;\r\n\r\n\t\tfor (var i = locations.length - 1; i >= 0; i--) {\r\n\t\t\tvar loc = locations[i],\r\n\t\t\t\tcurve = loc._curve,\r\n\t\t\t\tt = loc._parameter,\r\n\t\t\t\torigT = t;\r\n\t\t\tif (curve !== prevCurve) {\r\n\t\t\t\tnoHandles = !curve.hasHandles();\r\n\t\t\t} else if (prevT > 0) {\r\n\t\t\t\tt /= prevT;\r\n\t\t\t}\r\n\t\t\tvar segment;\r\n\t\t\tif (t < tMin) {\r\n\t\t\t\tsegment = curve._segment1;\r\n\t\t\t} else if (t > tMax) {\r\n\t\t\t\tsegment = curve._segment2;\r\n\t\t\t} else {\r\n\t\t\t\tsegment = curve.divide(t, true, true)._segment1;\r\n\t\t\t\tif (noHandles)\r\n\t\t\t\t\tclearSegments.push(segment);\r\n\t\t\t}\r\n\t\t\tloc._setSegment(segment);\r\n\t\t\tvar inter = segment._intersection,\r\n\t\t\t\tdest = loc._intersection;\r\n\t\t\tif (inter) {\r\n\t\t\t\tlinkIntersections(inter, dest);\r\n\t\t\t\tvar other = inter;\r\n\t\t\t\twhile (other) {\r\n\t\t\t\t\tlinkIntersections(other._intersection, inter);\r\n\t\t\t\t\tother = other._next;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tsegment._intersection = dest;\r\n\t\t\t}\r\n\t\t\tprevCurve = curve;\r\n\t\t\tprevT = origT;\r\n\t\t}\r\n\t\tfor (var i = 0, l = clearSegments.length; i < l; i++) {\r\n\t\t\tclearSegments[i].clearHandles();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getWinding(point, curves, horizontal, testContains) {\r\n\t\tvar epsilon = 2e-7,\r\n\t\t\ttMin = 4e-7,\r\n\t\t\ttMax = 1 - tMin,\r\n\t\t\tpx = point.x,\r\n\t\t\tpy = point.y,\r\n\t\t\twindLeft = 0,\r\n\t\t\twindRight = 0,\r\n\t\t\troots = [],\r\n\t\t\tabs = Math.abs;\r\n\t\tif (horizontal) {\r\n\t\t\tvar yTop = -Infinity,\r\n\t\t\t\tyBottom = Infinity,\r\n\t\t\t\tyBefore = py - epsilon,\r\n\t\t\t\tyAfter = py + epsilon;\r\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\r\n\t\t\t\tvar values = curves[i].values;\r\n\t\t\t\tif (Curve.solveCubic(values, 0, px, roots, 0, 1) > 0) {\r\n\t\t\t\t\tfor (var j = roots.length - 1; j >= 0; j--) {\r\n\t\t\t\t\t\tvar y = Curve.getPoint(values, roots[j]).y;\r\n\t\t\t\t\t\tif (y < yBefore && y > yTop) {\r\n\t\t\t\t\t\t\tyTop = y;\r\n\t\t\t\t\t\t} else if (y > yAfter && y < yBottom) {\r\n\t\t\t\t\t\t\tyBottom = y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tyTop = (yTop + py) / 2;\r\n\t\t\tyBottom = (yBottom + py) / 2;\r\n\t\t\tif (yTop > -Infinity)\r\n\t\t\t\twindLeft = getWinding(new Point(px, yTop), curves, false,\r\n\t\t\t\t\t\ttestContains);\r\n\t\t\tif (yBottom < Infinity)\r\n\t\t\t\twindRight = getWinding(new Point(px, yBottom), curves, false,\r\n\t\t\t\t\t\ttestContains);\r\n\t\t} else {\r\n\t\t\tvar xBefore = px - epsilon,\r\n\t\t\t\txAfter = px + epsilon;\r\n\t\t\tvar startCounted = false,\r\n\t\t\t\tprevCurve,\r\n\t\t\t\tprevT;\r\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\r\n\t\t\t\tvar curve = curves[i],\r\n\t\t\t\t\tvalues = curve.values,\r\n\t\t\t\t\twinding = curve.winding;\r\n\t\t\t\tif (winding && (winding === 1\r\n\t\t\t\t\t\t&& py >= values[1] && py <= values[7]\r\n\t\t\t\t\t\t|| py >= values[7] && py <= values[1])\r\n\t\t\t\t\t&& Curve.solveCubic(values, 1, py, roots, 0, 1) === 1) {\r\n\t\t\t\t\tvar t = roots[0];\r\n\t\t\t\t\tif (!(\r\n\t\t\t\t\t\tt > tMax && startCounted && curve.next !== curves[i + 1]\r\n\t\t\t\t\t\t|| t < tMin && prevT > tMax\r\n\t\t\t\t\t\t\t&& curve.previous === prevCurve)) {\r\n\t\t\t\t\t\tvar x = Curve.getPoint(values, t).x,\r\n\t\t\t\t\t\t\tslope = Curve.getTangent(values, t).y,\r\n\t\t\t\t\t\t\tcounted = false;\r\n\t\t\t\t\t\tif (Numerical.isZero(slope) && !Curve.isStraight(values)\r\n\t\t\t\t\t\t\t\t|| t < tMin && slope * Curve.getTangent(\r\n\t\t\t\t\t\t\t\t\tcurve.previous.values, 1).y < 0\r\n\t\t\t\t\t\t\t\t|| t > tMax && slope * Curve.getTangent(\r\n\t\t\t\t\t\t\t\t\tcurve.next.values, 0).y < 0) {\r\n\t\t\t\t\t\t\tif (testContains && x >= xBefore && x <= xAfter) {\r\n\t\t\t\t\t\t\t\t++windLeft;\r\n\t\t\t\t\t\t\t\t++windRight;\r\n\t\t\t\t\t\t\t\tcounted = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (x <= xBefore) {\r\n\t\t\t\t\t\t\twindLeft += winding;\r\n\t\t\t\t\t\t\tcounted = true;\r\n\t\t\t\t\t\t} else if (x >= xAfter) {\r\n\t\t\t\t\t\t\twindRight += winding;\r\n\t\t\t\t\t\t\tcounted = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (curve.previous !== curves[i - 1])\r\n\t\t\t\t\t\t\tstartCounted = t < tMin && counted;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprevCurve = curve;\r\n\t\t\t\t\tprevT = t;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn Math.max(abs(windLeft), abs(windRight));\r\n\t}\r\n\r\n\tfunction propagateWinding(segment, path1, path2, monoCurves, operation) {\r\n\t\tvar epsilon = 2e-7,\r\n\t\t\tchain = [],\r\n\t\t\tstart = segment,\r\n\t\t\ttotalLength = 0,\r\n\t\t\twindingSum = 0;\r\n\t\tdo {\r\n\t\t\tvar curve = segment.getCurve(),\r\n\t\t\t\tlength = curve.getLength();\r\n\t\t\tchain.push({ segment: segment, curve: curve, length: length });\r\n\t\t\ttotalLength += length;\r\n\t\t\tsegment = segment.getNext();\r\n\t\t} while (segment && !segment._intersection && segment !== start);\r\n\t\tfor (var i = 0; i < 3; i++) {\r\n\t\t\tvar length = totalLength * (i + 1) / 4;\r\n\t\t\tfor (var k = 0, m = chain.length; k < m; k++) {\r\n\t\t\t\tvar node = chain[k],\r\n\t\t\t\t\tcurveLength = node.length;\r\n\t\t\t\tif (length <= curveLength) {\r\n\t\t\t\t\tif (length < epsilon || curveLength - length < epsilon)\r\n\t\t\t\t\t\tlength = curveLength / 2;\r\n\t\t\t\t\tvar curve = node.curve,\r\n\t\t\t\t\t\tpath = curve._path,\r\n\t\t\t\t\t\tparent = path._parent,\r\n\t\t\t\t\t\tpt = curve.getPointAt(length),\r\n\t\t\t\t\t\thor = curve.isHorizontal();\r\n\t\t\t\t\tif (parent instanceof CompoundPath)\r\n\t\t\t\t\t\tpath = parent;\r\n\t\t\t\t\twindingSum += operation === 'subtract' && path2\r\n\t\t\t\t\t\t&& (path === path1 && path2._getWinding(pt, hor)\r\n\t\t\t\t\t\t|| path === path2 && !path1._getWinding(pt, hor))\r\n\t\t\t\t\t\t? 0\r\n\t\t\t\t\t\t: getWinding(pt, monoCurves, hor);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tlength -= curveLength;\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar winding = Math.round(windingSum / 3);\r\n\t\tfor (var j = chain.length - 1; j >= 0; j--)\r\n\t\t\tchain[j].segment._winding = winding;\r\n\t}\r\n\r\n\tfunction tracePaths(segments, operation) {\r\n\t\tvar paths = [],\r\n\t\t\tstart,\r\n\t\t\totherStart,\r\n\t\t\toperator = operators[operation],\r\n\t\t\toverlapWinding = {\r\n\t\t\t\tunite: { 1: 2 },\r\n\t\t\t\tintersect: { 2: 1 }\r\n\t\t\t}[operation];\r\n\r\n\t\tfunction isValid(seg, adjusted) {\r\n\t\t\tif (seg._visited)\r\n\t\t\t\treturn false;\r\n\t\t\tif (!operator)\r\n\t\t\t\treturn true;\r\n\t\t\tvar winding = seg._winding,\r\n\t\t\t\tinter = seg._intersection;\r\n\t\t\tif (inter && adjusted && overlapWinding && inter.isOverlap())\r\n\t\t\t\twinding = overlapWinding[winding] || winding;\r\n\t\t\treturn operator(winding);\r\n\t\t}\r\n\r\n\t\tfunction isStart(seg) {\r\n\t\t\treturn seg === start || seg === otherStart;\r\n\t\t}\r\n\r\n\t\tfunction findBestIntersection(inter, strict) {\r\n\t\t\tif (!inter._next)\r\n\t\t\t\treturn inter;\r\n\t\t\twhile (inter) {\r\n\t\t\t\tvar seg = inter._segment,\r\n\t\t\t\t\tnextSeg = seg.getNext(),\r\n\t\t\t\t\tnextInter = nextSeg._intersection;\r\n\t\t\t\tif (isStart(nextSeg)\r\n\t\t\t\t\t|| !seg._visited && !nextSeg._visited\r\n\t\t\t\t\t&& (!operator\r\n\t\t\t\t\t\t|| (!strict || isValid(seg))\r\n\t\t\t\t\t\t&& (!(strict && nextInter && nextInter.isOverlap())\r\n\t\t\t\t\t\t\t&& isValid(nextSeg)\r\n\t\t\t\t\t\t\t|| !strict && nextInter\r\n\t\t\t\t\t\t\t&& isValid(nextInter._segment))\r\n\t\t\t\t\t))\r\n\t\t\t\t\treturn inter;\r\n\t\t\t\tinter = inter._next;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tfunction findStartSegment(inter, next) {\r\n\t\t\twhile (inter) {\r\n\t\t\t\tvar seg = inter._segment;\r\n\t\t\t\tif (isStart(seg))\r\n\t\t\t\t\treturn seg;\r\n\t\t\t\tinter = inter[next ? '_next' : '_prev'];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\r\n\t\t\tvar seg = segments[i],\r\n\t\t\t\tpath = null,\r\n\t\t\t\tfinished = false;\r\n\t\t\tif (!isValid(seg, true))\r\n\t\t\t\tcontinue;\r\n\t\t\tstart = otherStart = null;\r\n\t\t\twhile (!finished) {\r\n\t\t\t\tvar inter = seg._intersection,\r\n\t\t\t\t\thandleIn = path && seg._handleIn;\r\n\t\t\t\tinter = inter && (findBestIntersection(inter, true)\r\n\t\t\t\t\t\t|| findBestIntersection(inter, false)) || inter;\r\n\t\t\t\tvar other = inter && inter._segment;\r\n\t\t\t\tif (other && isValid(other))\r\n\t\t\t\t\tseg = other;\r\n\t\t\t\tif (seg._visited) {\r\n\t\t\t\t\tfinished = isStart(seg);\r\n\t\t\t\t\tif (!finished && inter) {\r\n\t\t\t\t\t\tvar found = findStartSegment(inter, true)\r\n\t\t\t\t\t\t\t|| findStartSegment(inter, false);\r\n\t\t\t\t\t\tif (found) {\r\n\t\t\t\t\t\t\tseg = found;\r\n\t\t\t\t\t\t\tfinished = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (!path) {\r\n\t\t\t\t\tpath = new Path(Item.NO_INSERT);\r\n\t\t\t\t\tstart = seg;\r\n\t\t\t\t\totherStart = other;\r\n\t\t\t\t}\r\n\t\t\t\tpath.add(new Segment(seg._point, handleIn, seg._handleOut));\r\n\t\t\t\tseg._visited = true;\r\n\t\t\t\tseg = seg.getNext();\r\n\t\t\t\tfinished = isStart(seg);\r\n\t\t\t}\r\n\t\t\tif (finished) {\r\n\t\t\t\tpath.firstSegment.setHandleIn(seg._handleIn);\r\n\t\t\t\tpath.setClosed(true);\r\n\t\t\t} else if (path) {\r\n\t\t\t\tconsole.error('Boolean operation resulted in open path',\r\n\t\t\t\t\t\t'segments =', path._segments.length,\r\n\t\t\t\t\t\t'length =', path.getLength());\r\n\t\t\t\tpath = null;\r\n\t\t\t}\r\n\t\t\tif (path && (path._segments.length > 8\r\n\t\t\t\t\t|| !Numerical.isZero(path.getArea()))) {\r\n\t\t\t\tpaths.push(path);\r\n\t\t\t\tpath = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn paths;\r\n\t}\r\n\r\n\treturn {\r\n\t\t_getWinding: function(point, horizontal, testContains) {\r\n\t\t\treturn getWinding(point, this._getMonoCurves(),\r\n\t\t\t\t\thorizontal, testContains);\r\n\t\t},\r\n\r\n\t\tunite: function(path) {\r\n\t\t\treturn computeBoolean(this, path, 'unite');\r\n\t\t},\r\n\r\n\t\tintersect: function(path) {\r\n\t\t\treturn computeBoolean(this, path, 'intersect');\r\n\t\t},\r\n\r\n\t\tsubtract: function(path) {\r\n\t\t\treturn computeBoolean(this, path, 'subtract');\r\n\t\t},\r\n\r\n\t\texclude: function(path) {\r\n\t\t\treturn computeBoolean(this, path, 'exclude');\r\n\t\t},\r\n\r\n\t\tdivide: function(path) {\r\n\t\t\treturn finishBoolean(Group,\r\n\t\t\t\t\t[this.subtract(path), this.intersect(path)],\r\n\t\t\t\t\tthis, path, true);\r\n\t\t},\r\n\r\n\t\tresolveCrossings: function() {\r\n\t\t\tvar crossings = this.getCrossings();\r\n\t\t\tif (!crossings.length)\r\n\t\t\t\treturn this;\r\n\t\t\tdivideLocations(CurveLocation.expand(crossings));\r\n\t\t\tvar paths = this._children || [this],\r\n\t\t\t\tsegments = [];\r\n\t\t\tfor (var i = 0, l = paths.length; i < l; i++) {\r\n\t\t\t\tsegments.push.apply(segments, paths[i]._segments);\r\n\t\t\t}\r\n\t\t\treturn finishBoolean(CompoundPath, tracePaths(segments),\r\n\t\t\t\t\tthis, null, false);\r\n\t\t}\r\n\t};\r\n});\r\n\r\nPath.inject({\r\n\t_getMonoCurves: function() {\r\n\t\tvar monoCurves = this._monoCurves,\r\n\t\t\tprevCurve;\r\n\r\n\t\tfunction insertCurve(v) {\r\n\t\t\tvar y0 = v[1],\r\n\t\t\t\ty1 = v[7],\r\n\t\t\t\tcurve = {\r\n\t\t\t\t\tvalues: v,\r\n\t\t\t\t\twinding: y0 === y1\r\n\t\t\t\t\t\t? 0\r\n\t\t\t\t\t\t: y0 > y1\r\n\t\t\t\t\t\t\t? -1\r\n\t\t\t\t\t\t\t: 1,\r\n\t\t\t\t\tprevious: prevCurve,\r\n\t\t\t\t\tnext: null\r\n\t\t\t\t};\r\n\t\t\tif (prevCurve)\r\n\t\t\t\tprevCurve.next = curve;\r\n\t\t\tmonoCurves.push(curve);\r\n\t\t\tprevCurve = curve;\r\n\t\t}\r\n\r\n\t\tfunction handleCurve(v) {\r\n\t\t\tif (Curve.getLength(v) === 0)\r\n\t\t\t\treturn;\r\n\t\t\tvar y0 = v[1],\r\n\t\t\t\ty1 = v[3],\r\n\t\t\t\ty2 = v[5],\r\n\t\t\t\ty3 = v[7];\r\n\t\t\tif (Curve.isStraight(v)) {\r\n\t\t\t\tinsertCurve(v);\r\n\t\t\t} else {\r\n\t\t\t\tvar a = 3 * (y1 - y2) - y0 + y3,\r\n\t\t\t\t\tb = 2 * (y0 + y2) - 4 * y1,\r\n\t\t\t\t\tc = y1 - y0,\r\n\t\t\t\t\ttMin = 4e-7,\r\n\t\t\t\t\ttMax = 1 - tMin,\r\n\t\t\t\t\troots = [],\r\n\t\t\t\t\tn = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);\r\n\t\t\t\tif (n === 0) {\r\n\t\t\t\t\tinsertCurve(v);\r\n\t\t\t\t} else {\r\n\t\t\t\t\troots.sort();\r\n\t\t\t\t\tvar t = roots[0],\r\n\t\t\t\t\t\tparts = Curve.subdivide(v, t);\r\n\t\t\t\t\tinsertCurve(parts[0]);\r\n\t\t\t\t\tif (n > 1) {\r\n\t\t\t\t\t\tt = (roots[1] - t) / (1 - t);\r\n\t\t\t\t\t\tparts = Curve.subdivide(parts[1], t);\r\n\t\t\t\t\t\tinsertCurve(parts[0]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinsertCurve(parts[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!monoCurves) {\r\n\t\t\tmonoCurves = this._monoCurves = [];\r\n\t\t\tvar curves = this.getCurves(),\r\n\t\t\t\tsegments = this._segments;\r\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++)\r\n\t\t\t\thandleCurve(curves[i].getValues());\r\n\t\t\tif (!this._closed && segments.length > 1) {\r\n\t\t\t\tvar p1 = segments[segments.length - 1]._point,\r\n\t\t\t\t\tp2 = segments[0]._point,\r\n\t\t\t\t\tp1x = p1._x, p1y = p1._y,\r\n\t\t\t\t\tp2x = p2._x, p2y = p2._y;\r\n\t\t\t\thandleCurve([p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y]);\r\n\t\t\t}\r\n\t\t\tif (monoCurves.length > 0) {\r\n\t\t\t\tvar first = monoCurves[0],\r\n\t\t\t\t\tlast = monoCurves[monoCurves.length - 1];\r\n\t\t\t\tfirst.previous = last;\r\n\t\t\t\tlast.next = first;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn monoCurves;\r\n\t},\r\n\r\n\tgetInteriorPoint: function() {\r\n\t\tvar bounds = this.getBounds(),\r\n\t\t\tpoint = bounds.getCenter(true);\r\n\t\tif (!this.contains(point)) {\r\n\t\t\tvar curves = this._getMonoCurves(),\r\n\t\t\t\troots = [],\r\n\t\t\t\ty = point.y,\r\n\t\t\t\txIntercepts = [];\r\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\r\n\t\t\t\tvar values = curves[i].values;\r\n\t\t\t\tif ((curves[i].winding === 1\r\n\t\t\t\t\t\t&& y >= values[1] && y <= values[7]\r\n\t\t\t\t\t\t|| y >= values[7] && y <= values[1])\r\n\t\t\t\t\t\t&& Curve.solveCubic(values, 1, y, roots, 0, 1) > 0) {\r\n\t\t\t\t\tfor (var j = roots.length - 1; j >= 0; j--)\r\n\t\t\t\t\t\txIntercepts.push(Curve.getPoint(values, roots[j]).x);\r\n\t\t\t\t}\r\n\t\t\t\tif (xIntercepts.length > 1)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tpoint.x = (xIntercepts[0] + xIntercepts[1]) / 2;\r\n\t\t}\r\n\t\treturn point;\r\n\t},\r\n\r\n\treorient: function() {\r\n\t\tthis.setClockwise(true);\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nCompoundPath.inject({\r\n\t_getMonoCurves: function() {\r\n\t\tvar children = this._children,\r\n\t\t\tmonoCurves = [];\r\n\t\tfor (var i = 0, l = children.length; i < l; i++)\r\n\t\t\tmonoCurves.push.apply(monoCurves, children[i]._getMonoCurves());\r\n\t\treturn monoCurves;\r\n\t},\r\n\r\n\treorient: function() {\r\n\t\tvar children = this.removeChildren().sort(function(a, b) {\r\n\t\t\treturn b.getBounds().getArea() - a.getBounds().getArea();\r\n\t\t});\r\n\t\tif (children.length > 0) {\r\n\t\t\tthis.addChildren(children);\r\n\t\t\tvar clockwise = children[0].isClockwise();\r\n\t\t\tfor (var i = 1, l = children.length; i < l; i++) {\r\n\t\t\t\tvar point = children[i].getInteriorPoint(),\r\n\t\t\t\t\tcounters = 0;\r\n\t\t\t\tfor (var j = i - 1; j >= 0; j--) {\r\n\t\t\t\t\tif (children[j].contains(point))\r\n\t\t\t\t\t\tcounters++;\r\n\t\t\t\t}\r\n\t\t\t\tchildren[i].setClockwise(counters % 2 === 0 && clockwise);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nvar PathIterator = Base.extend({\r\n\t_class: 'PathIterator',\r\n\r\n\tinitialize: function(path, maxRecursion, tolerance, matrix) {\r\n\t\tvar curves = [],\r\n\t\t\tparts = [],\r\n\t\t\tlength = 0,\r\n\t\t\tminDifference = 1 / (maxRecursion || 32),\r\n\t\t\tsegments = path._segments,\r\n\t\t\tsegment1 = segments[0],\r\n\t\t\tsegment2;\r\n\r\n\t\tfunction addCurve(segment1, segment2) {\r\n\t\t\tvar curve = Curve.getValues(segment1, segment2, matrix);\r\n\t\t\tcurves.push(curve);\r\n\t\t\tcomputeParts(curve, segment1._index, 0, 1);\r\n\t\t}\r\n\r\n\t\tfunction computeParts(curve, index, minT, maxT) {\r\n\t\t\tif ((maxT - minT) > minDifference\r\n\t\t\t\t\t&& !Curve.isFlatEnough(curve, tolerance || 0.25)) {\r\n\t\t\t\tvar split = Curve.subdivide(curve, 0.5),\r\n\t\t\t\t\thalfT = (minT + maxT) / 2;\r\n\t\t\t\tcomputeParts(split[0], index, minT, halfT);\r\n\t\t\t\tcomputeParts(split[1], index, halfT, maxT);\r\n\t\t\t} else {\r\n\t\t\t\tvar x = curve[6] - curve[0],\r\n\t\t\t\t\ty = curve[7] - curve[1],\r\n\t\t\t\t\tdist = Math.sqrt(x * x + y * y);\r\n\t\t\t\tif (dist > 1e-6) {\r\n\t\t\t\t\tlength += dist;\r\n\t\t\t\t\tparts.push({\r\n\t\t\t\t\t\toffset: length,\r\n\t\t\t\t\t\tvalue: maxT,\r\n\t\t\t\t\t\tindex: index\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var i = 1, l = segments.length; i < l; i++) {\r\n\t\t\tsegment2 = segments[i];\r\n\t\t\taddCurve(segment1, segment2);\r\n\t\t\tsegment1 = segment2;\r\n\t\t}\r\n\t\tif (path._closed)\r\n\t\t\taddCurve(segment2, segments[0]);\r\n\r\n\t\tthis.curves = curves;\r\n\t\tthis.parts = parts;\r\n\t\tthis.length = length;\r\n\t\tthis.index = 0;\r\n\t},\r\n\r\n\tgetParameterAt: function(offset) {\r\n\t\tvar i, j = this.index;\r\n\t\tfor (;;) {\r\n\t\t\ti = j;\r\n\t\t\tif (j == 0 || this.parts[--j].offset < offset)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tfor (var l = this.parts.length; i < l; i++) {\r\n\t\t\tvar part = this.parts[i];\r\n\t\t\tif (part.offset >= offset) {\r\n\t\t\t\tthis.index = i;\r\n\t\t\t\tvar prev = this.parts[i - 1];\r\n\t\t\t\tvar prevVal = prev && prev.index == part.index ? prev.value : 0,\r\n\t\t\t\t\tprevLen = prev ? prev.offset : 0;\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalue: prevVal + (part.value - prevVal)\r\n\t\t\t\t\t\t* (offset - prevLen) / (part.offset - prevLen),\r\n\t\t\t\t\tindex: part.index\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar part = this.parts[this.parts.length - 1];\r\n\t\treturn {\r\n\t\t\tvalue: 1,\r\n\t\t\tindex: part.index\r\n\t\t};\r\n\t},\r\n\r\n\tdrawPart: function(ctx, from, to) {\r\n\t\tfrom = this.getParameterAt(from);\r\n\t\tto = this.getParameterAt(to);\r\n\t\tfor (var i = from.index; i <= to.index; i++) {\r\n\t\t\tvar curve = Curve.getPart(this.curves[i],\r\n\t\t\t\t\ti == from.index ? from.value : 0,\r\n\t\t\t\t\ti == to.index ? to.value : 1);\r\n\t\t\tif (i == from.index)\r\n\t\t\t\tctx.moveTo(curve[0], curve[1]);\r\n\t\t\tctx.bezierCurveTo.apply(ctx, curve.slice(2));\r\n\t\t}\r\n\t}\r\n}, Base.each(Curve.evaluateMethods,\r\n\tfunction(name) {\r\n\t\tthis[name + 'At'] = function(offset, weighted) {\r\n\t\t\tvar param = this.getParameterAt(offset);\r\n\t\t\treturn Curve[name](this.curves[param.index], param.value, weighted);\r\n\t\t};\r\n\t}, {})\r\n);\r\n\r\nvar PathFitter = Base.extend({\r\n\tinitialize: function(path, error) {\r\n\t\tvar points = this.points = [],\r\n\t\t\tsegments = path._segments,\r\n\t\t\tprev;\r\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\r\n\t\t\tvar point = segments[i].point.clone();\r\n\t\t\tif (!prev || !prev.equals(point)) {\r\n\t\t\t\tpoints.push(point);\r\n\t\t\t\tprev = point;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (path._closed) {\r\n\t\t\tthis.closed = true;\r\n\t\t\tpoints.unshift(points[points.length - 1]);\r\n\t\t\tpoints.push(points[1]);\r\n\t\t}\r\n\r\n\t\tthis.error = error;\r\n\t},\r\n\r\n\tfit: function() {\r\n\t\tvar points = this.points,\r\n\t\t\tlength = points.length,\r\n\t\t\tsegments = this.segments = length > 0\r\n\t\t\t\t\t? [new Segment(points[0])] : [];\r\n\t\tif (length > 1)\r\n\t\t\tthis.fitCubic(0, length - 1,\r\n\t\t\t\tpoints[1].subtract(points[0]).normalize(),\r\n\t\t\t\tpoints[length - 2].subtract(points[length - 1]).normalize());\r\n\r\n\t\tif (this.closed) {\r\n\t\t\tsegments.shift();\r\n\t\t\tsegments.pop();\r\n\t\t}\r\n\r\n\t\treturn segments;\r\n\t},\r\n\r\n\tfitCubic: function(first, last, tan1, tan2) {\r\n\t\tif (last - first == 1) {\r\n\t\t\tvar pt1 = this.points[first],\r\n\t\t\t\tpt2 = this.points[last],\r\n\t\t\t\tdist = pt1.getDistance(pt2) / 3;\r\n\t\t\tthis.addCurve([pt1, pt1.add(tan1.normalize(dist)),\r\n\t\t\t\t\tpt2.add(tan2.normalize(dist)), pt2]);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar uPrime = this.chordLengthParameterize(first, last),\r\n\t\t\tmaxError = Math.max(this.error, this.error * this.error),\r\n\t\t\tsplit,\r\n\t\t\tparametersInOrder = true;\r\n\t\tfor (var i = 0; i <= 4; i++) {\r\n\t\t\tvar curve = this.generateBezier(first, last, uPrime, tan1, tan2);\r\n\t\t\tvar max = this.findMaxError(first, last, curve, uPrime);\r\n\t\t\tif (max.error < this.error && parametersInOrder) {\r\n\t\t\t\tthis.addCurve(curve);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tsplit = max.index;\r\n\t\t\tif (max.error >= maxError)\r\n\t\t\t\tbreak;\r\n\t\t\tparametersInOrder = this.reparameterize(first, last, uPrime, curve);\r\n\t\t\tmaxError = max.error;\r\n\t\t}\r\n\t\tvar V1 = this.points[split - 1].subtract(this.points[split]),\r\n\t\t\tV2 = this.points[split].subtract(this.points[split + 1]),\r\n\t\t\ttanCenter = V1.add(V2).divide(2).normalize();\r\n\t\tthis.fitCubic(first, split, tan1, tanCenter);\r\n\t\tthis.fitCubic(split, last, tanCenter.negate(), tan2);\r\n\t},\r\n\r\n\taddCurve: function(curve) {\r\n\t\tvar prev = this.segments[this.segments.length - 1];\r\n\t\tprev.setHandleOut(curve[1].subtract(curve[0]));\r\n\t\tthis.segments.push(\r\n\t\t\t\tnew Segment(curve[3], curve[2].subtract(curve[3])));\r\n\t},\r\n\r\n\tgenerateBezier: function(first, last, uPrime, tan1, tan2) {\r\n\t\tvar epsilon = 1e-12,\r\n\t\t\tpt1 = this.points[first],\r\n\t\t\tpt2 = this.points[last],\r\n\t\t\tC = [[0, 0], [0, 0]],\r\n\t\t\tX = [0, 0];\r\n\r\n\t\tfor (var i = 0, l = last - first + 1; i < l; i++) {\r\n\t\t\tvar u = uPrime[i],\r\n\t\t\t\tt = 1 - u,\r\n\t\t\t\tb = 3 * u * t,\r\n\t\t\t\tb0 = t * t * t,\r\n\t\t\t\tb1 = b * t,\r\n\t\t\t\tb2 = b * u,\r\n\t\t\t\tb3 = u * u * u,\r\n\t\t\t\ta1 = tan1.normalize(b1),\r\n\t\t\t\ta2 = tan2.normalize(b2),\r\n\t\t\t\ttmp = this.points[first + i]\r\n\t\t\t\t\t.subtract(pt1.multiply(b0 + b1))\r\n\t\t\t\t\t.subtract(pt2.multiply(b2 + b3));\r\n\t\t\tC[0][0] += a1.dot(a1);\r\n\t\t\tC[0][1] += a1.dot(a2);\r\n\t\t\tC[1][0] = C[0][1];\r\n\t\t\tC[1][1] += a2.dot(a2);\r\n\t\t\tX[0] += a1.dot(tmp);\r\n\t\t\tX[1] += a2.dot(tmp);\r\n\t\t}\r\n\r\n\t\tvar detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],\r\n\t\t\talpha1, alpha2;\r\n\t\tif (Math.abs(detC0C1) > epsilon) {\r\n\t\t\tvar detC0X\t= C[0][0] * X[1]\t- C[1][0] * X[0],\r\n\t\t\t\tdetXC1\t= X[0]\t  * C[1][1] - X[1]\t  * C[0][1];\r\n\t\t\talpha1 = detXC1 / detC0C1;\r\n\t\t\talpha2 = detC0X / detC0C1;\r\n\t\t} else {\r\n\t\t\tvar c0 = C[0][0] + C[0][1],\r\n\t\t\t\tc1 = C[1][0] + C[1][1];\r\n\t\t\tif (Math.abs(c0) > epsilon) {\r\n\t\t\t\talpha1 = alpha2 = X[0] / c0;\r\n\t\t\t} else if (Math.abs(c1) > epsilon) {\r\n\t\t\t\talpha1 = alpha2 = X[1] / c1;\r\n\t\t\t} else {\r\n\t\t\t\talpha1 = alpha2 = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar segLength = pt2.getDistance(pt1),\r\n\t\t\teps = epsilon * segLength,\r\n\t\t\thandle1,\r\n\t\t\thandle2;\r\n\t\tif (alpha1 < eps || alpha2 < eps) {\r\n\t\t\talpha1 = alpha2 = segLength / 3;\r\n\t\t} else {\r\n\t\t\tvar line = pt2.subtract(pt1);\r\n\t\t\thandle1 = tan1.normalize(alpha1);\r\n\t\t\thandle2 = tan2.normalize(alpha2);\r\n\t\t\tif (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {\r\n\t\t\t\talpha1 = alpha2 = segLength / 3;\r\n\t\t\t\thandle1 = handle2 = null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn [pt1, pt1.add(handle1 || tan1.normalize(alpha1)),\r\n\t\t\t\tpt2.add(handle2 || tan2.normalize(alpha2)), pt2];\r\n\t},\r\n\r\n\treparameterize: function(first, last, u, curve) {\r\n\t\tfor (var i = first; i <= last; i++) {\r\n\t\t\tu[i - first] = this.findRoot(curve, this.points[i], u[i - first]);\r\n\t\t}\r\n\t\tfor (var i = 1, l = u.length; i < l; i++) {\r\n\t\t\tif (u[i] <= u[i - 1])\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t},\r\n\r\n\tfindRoot: function(curve, point, u) {\r\n\t\tvar curve1 = [],\r\n\t\t\tcurve2 = [];\r\n\t\tfor (var i = 0; i <= 2; i++) {\r\n\t\t\tcurve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);\r\n\t\t}\r\n\t\tfor (var i = 0; i <= 1; i++) {\r\n\t\t\tcurve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);\r\n\t\t}\r\n\t\tvar pt = this.evaluate(3, curve, u),\r\n\t\t\tpt1 = this.evaluate(2, curve1, u),\r\n\t\t\tpt2 = this.evaluate(1, curve2, u),\r\n\t\t\tdiff = pt.subtract(point),\r\n\t\t\tdf = pt1.dot(pt1) + diff.dot(pt2);\r\n\t\tif (Math.abs(df) < 1e-6)\r\n\t\t\treturn u;\r\n\t\treturn u - diff.dot(pt1) / df;\r\n\t},\r\n\r\n\tevaluate: function(degree, curve, t) {\r\n\t\tvar tmp = curve.slice();\r\n\t\tfor (var i = 1; i <= degree; i++) {\r\n\t\t\tfor (var j = 0; j <= degree - i; j++) {\r\n\t\t\t\ttmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn tmp[0];\r\n\t},\r\n\r\n\tchordLengthParameterize: function(first, last) {\r\n\t\tvar u = [0];\r\n\t\tfor (var i = first + 1; i <= last; i++) {\r\n\t\t\tu[i - first] = u[i - first - 1]\r\n\t\t\t\t\t+ this.points[i].getDistance(this.points[i - 1]);\r\n\t\t}\r\n\t\tfor (var i = 1, m = last - first; i <= m; i++) {\r\n\t\t\tu[i] /= u[m];\r\n\t\t}\r\n\t\treturn u;\r\n\t},\r\n\r\n\tfindMaxError: function(first, last, curve, u) {\r\n\t\tvar index = Math.floor((last - first + 1) / 2),\r\n\t\t\tmaxDist = 0;\r\n\t\tfor (var i = first + 1; i < last; i++) {\r\n\t\t\tvar P = this.evaluate(3, curve, u[i - first]);\r\n\t\t\tvar v = P.subtract(this.points[i]);\r\n\t\t\tvar dist = v.x * v.x + v.y * v.y;\r\n\t\t\tif (dist >= maxDist) {\r\n\t\t\t\tmaxDist = dist;\r\n\t\t\t\tindex = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {\r\n\t\t\terror: maxDist,\r\n\t\t\tindex: index\r\n\t\t};\r\n\t}\r\n});\r\n\r\nvar TextItem = Item.extend({\r\n\t_class: 'TextItem',\r\n\t_boundsSelected: true,\r\n\t_applyMatrix: false,\r\n\t_canApplyMatrix: false,\r\n\t_serializeFields: {\r\n\t\tcontent: null\r\n\t},\r\n\t_boundsGetter: 'getBounds',\r\n\r\n\tinitialize: function TextItem(arg) {\r\n\t\tthis._content = '';\r\n\t\tthis._lines = [];\r\n\t\tvar hasProps = arg && Base.isPlainObject(arg)\r\n\t\t\t\t&& arg.x === undefined && arg.y === undefined;\r\n\t\tthis._initialize(hasProps && arg, !hasProps && Point.read(arguments));\r\n\t},\r\n\r\n\t_equals: function(item) {\r\n\t\treturn this._content === item._content;\r\n\t},\r\n\r\n\t_clone: function _clone(copy, insert, includeMatrix) {\r\n\t\tcopy.setContent(this._content);\r\n\t\treturn _clone.base.call(this, copy, insert, includeMatrix);\r\n\t},\r\n\r\n\tgetContent: function() {\r\n\t\treturn this._content;\r\n\t},\r\n\r\n\tsetContent: function(content) {\r\n\t\tthis._content = '' + content;\r\n\t\tthis._lines = this._content.split(/\\r\\n|\\n|\\r/mg);\r\n\t\tthis._changed(265);\r\n\t},\r\n\r\n\tisEmpty: function() {\r\n\t\treturn !this._content;\r\n\t},\r\n\r\n\tgetCharacterStyle: '#getStyle',\r\n\tsetCharacterStyle: '#setStyle',\r\n\r\n\tgetParagraphStyle: '#getStyle',\r\n\tsetParagraphStyle: '#setStyle'\r\n});\r\n\r\nvar PointText = TextItem.extend({\r\n\t_class: 'PointText',\r\n\r\n\tinitialize: function PointText() {\r\n\t\tTextItem.apply(this, arguments);\r\n\t},\r\n\r\n\tclone: function(insert) {\r\n\t\treturn this._clone(new PointText(Item.NO_INSERT), insert);\r\n\t},\r\n\r\n\tgetPoint: function() {\r\n\t\tvar point = this._matrix.getTranslation();\r\n\t\treturn new LinkedPoint(point.x, point.y, this, 'setPoint');\r\n\t},\r\n\r\n\tsetPoint: function() {\r\n\t\tvar point = Point.read(arguments);\r\n\t\tthis.translate(point.subtract(this._matrix.getTranslation()));\r\n\t},\r\n\r\n\t_draw: function(ctx) {\r\n\t\tif (!this._content)\r\n\t\t\treturn;\r\n\t\tthis._setStyles(ctx);\r\n\t\tvar style = this._style,\r\n\t\t\tlines = this._lines,\r\n\t\t\tleading = style.getLeading(),\r\n\t\t\tshadowColor = ctx.shadowColor;\r\n\t\tctx.font = style.getFontStyle();\r\n\t\tctx.textAlign = style.getJustification();\r\n\t\tfor (var i = 0, l = lines.length; i < l; i++) {\r\n\t\t\tctx.shadowColor = shadowColor;\r\n\t\t\tvar line = lines[i];\r\n\t\t\tif (style.hasFill()) {\r\n\t\t\t\tctx.fillText(line, 0, 0);\r\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\r\n\t\t\t}\r\n\t\t\tif (style.hasStroke())\r\n\t\t\t\tctx.strokeText(line, 0, 0);\r\n\t\t\tctx.translate(0, leading);\r\n\t\t}\r\n\t},\r\n\r\n\t_getBounds: function(getter, matrix) {\r\n\t\tvar style = this._style,\r\n\t\t\tlines = this._lines,\r\n\t\t\tnumLines = lines.length,\r\n\t\t\tjustification = style.getJustification(),\r\n\t\t\tleading = style.getLeading(),\r\n\t\t\twidth = this.getView().getTextWidth(style.getFontStyle(), lines),\r\n\t\t\tx = 0;\r\n\t\tif (justification !== 'left')\r\n\t\t\tx -= width / (justification === 'center' ? 2: 1);\r\n\t\tvar bounds = new Rectangle(x,\r\n\t\t\t\t\tnumLines ? - 0.75 * leading : 0,\r\n\t\t\t\t\twidth, numLines * leading);\r\n\t\treturn matrix ? matrix._transformBounds(bounds, bounds) : bounds;\r\n\t}\r\n});\r\n\r\nvar Color = Base.extend(new function() {\r\n\tvar types = {\r\n\t\tgray: ['gray'],\r\n\t\trgb: ['red', 'green', 'blue'],\r\n\t\thsb: ['hue', 'saturation', 'brightness'],\r\n\t\thsl: ['hue', 'saturation', 'lightness'],\r\n\t\tgradient: ['gradient', 'origin', 'destination', 'highlight']\r\n\t};\r\n\r\n\tvar componentParsers = {},\r\n\t\tcolorCache = {},\r\n\t\tcolorCtx;\r\n\r\n\tfunction fromCSS(string) {\r\n\t\tvar match = string.match(/^#(\\w{1,2})(\\w{1,2})(\\w{1,2})$/),\r\n\t\t\tcomponents;\r\n\t\tif (match) {\r\n\t\t\tcomponents = [0, 0, 0];\r\n\t\t\tfor (var i = 0; i < 3; i++) {\r\n\t\t\t\tvar value = match[i + 1];\r\n\t\t\t\tcomponents[i] = parseInt(value.length == 1\r\n\t\t\t\t\t\t? value + value : value, 16) / 255;\r\n\t\t\t}\r\n\t\t} else if (match = string.match(/^rgba?\\((.*)\\)$/)) {\r\n\t\t\tcomponents = match[1].split(',');\r\n\t\t\tfor (var i = 0, l = components.length; i < l; i++) {\r\n\t\t\t\tvar value = +components[i];\r\n\t\t\t\tcomponents[i] = i < 3 ? value / 255 : value;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar cached = colorCache[string];\r\n\t\t\tif (!cached) {\r\n\t\t\t\tif (!colorCtx) {\r\n\t\t\t\t\tcolorCtx = CanvasProvider.getContext(1, 1);\r\n\t\t\t\t\tcolorCtx.globalCompositeOperation = 'copy';\r\n\t\t\t\t}\r\n\t\t\t\tcolorCtx.fillStyle = 'rgba(0,0,0,0)';\r\n\t\t\t\tcolorCtx.fillStyle = string;\r\n\t\t\t\tcolorCtx.fillRect(0, 0, 1, 1);\r\n\t\t\t\tvar data = colorCtx.getImageData(0, 0, 1, 1).data;\r\n\t\t\t\tcached = colorCache[string] = [\r\n\t\t\t\t\tdata[0] / 255,\r\n\t\t\t\t\tdata[1] / 255,\r\n\t\t\t\t\tdata[2] / 255\r\n\t\t\t\t];\r\n\t\t\t}\r\n\t\t\tcomponents = cached.slice();\r\n\t\t}\r\n\t\treturn components;\r\n\t}\r\n\r\n\tvar hsbIndices = [\r\n\t\t[0, 3, 1],\r\n\t\t[2, 0, 1],\r\n\t\t[1, 0, 3],\r\n\t\t[1, 2, 0],\r\n\t\t[3, 1, 0],\r\n\t\t[0, 1, 2]\r\n\t];\r\n\r\n\tvar converters = {\r\n\t\t'rgb-hsb': function(r, g, b) {\r\n\t\t\tvar max = Math.max(r, g, b),\r\n\t\t\t\tmin = Math.min(r, g, b),\r\n\t\t\t\tdelta = max - min,\r\n\t\t\t\th = delta === 0 ? 0\r\n\t\t\t\t\t:\t( max == r ? (g - b) / delta + (g < b ? 6 : 0)\r\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\r\n\t\t\t\t\t\t:\t\t\t (r - g) / delta + 4) * 60;\r\n\t\t\treturn [h, max === 0 ? 0 : delta / max, max];\r\n\t\t},\r\n\r\n\t\t'hsb-rgb': function(h, s, b) {\r\n\t\t\th = (((h / 60) % 6) + 6) % 6;\r\n\t\t\tvar i = Math.floor(h),\r\n\t\t\t\tf = h - i,\r\n\t\t\t\ti = hsbIndices[i],\r\n\t\t\t\tv = [\r\n\t\t\t\t\tb,\r\n\t\t\t\t\tb * (1 - s),\r\n\t\t\t\t\tb * (1 - s * f),\r\n\t\t\t\t\tb * (1 - s * (1 - f))\r\n\t\t\t\t];\r\n\t\t\treturn [v[i[0]], v[i[1]], v[i[2]]];\r\n\t\t},\r\n\r\n\t\t'rgb-hsl': function(r, g, b) {\r\n\t\t\tvar max = Math.max(r, g, b),\r\n\t\t\t\tmin = Math.min(r, g, b),\r\n\t\t\t\tdelta = max - min,\r\n\t\t\t\tachromatic = delta === 0,\r\n\t\t\t\th = achromatic ? 0\r\n\t\t\t\t\t:\t( max == r ? (g - b) / delta + (g < b ? 6 : 0)\r\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\r\n\t\t\t\t\t\t:\t\t\t (r - g) / delta + 4) * 60,\r\n\t\t\t\tl = (max + min) / 2,\r\n\t\t\t\ts = achromatic ? 0 : l < 0.5\r\n\t\t\t\t\t\t? delta / (max + min)\r\n\t\t\t\t\t\t: delta / (2 - max - min);\r\n\t\t\treturn [h, s, l];\r\n\t\t},\r\n\r\n\t\t'hsl-rgb': function(h, s, l) {\r\n\t\t\th = (((h / 360) % 1) + 1) % 1;\r\n\t\t\tif (s === 0)\r\n\t\t\t\treturn [l, l, l];\r\n\t\t\tvar t3s = [ h + 1 / 3, h, h - 1 / 3 ],\r\n\t\t\t\tt2 = l < 0.5 ? l * (1 + s) : l + s - l * s,\r\n\t\t\t\tt1 = 2 * l - t2,\r\n\t\t\t\tc = [];\r\n\t\t\tfor (var i = 0; i < 3; i++) {\r\n\t\t\t\tvar t3 = t3s[i];\r\n\t\t\t\tif (t3 < 0) t3 += 1;\r\n\t\t\t\tif (t3 > 1) t3 -= 1;\r\n\t\t\t\tc[i] = 6 * t3 < 1\r\n\t\t\t\t\t? t1 + (t2 - t1) * 6 * t3\r\n\t\t\t\t\t: 2 * t3 < 1\r\n\t\t\t\t\t\t? t2\r\n\t\t\t\t\t\t: 3 * t3 < 2\r\n\t\t\t\t\t\t\t? t1 + (t2 - t1) * ((2 / 3) - t3) * 6\r\n\t\t\t\t\t\t\t: t1;\r\n\t\t\t}\r\n\t\t\treturn c;\r\n\t\t},\r\n\r\n\t\t'rgb-gray': function(r, g, b) {\r\n\t\t\treturn [r * 0.2989 + g * 0.587 + b * 0.114];\r\n\t\t},\r\n\r\n\t\t'gray-rgb': function(g) {\r\n\t\t\treturn [g, g, g];\r\n\t\t},\r\n\r\n\t\t'gray-hsb': function(g) {\r\n\t\t\treturn [0, 0, g];\r\n\t\t},\r\n\r\n\t\t'gray-hsl': function(g) {\r\n\t\t\treturn [0, 0, g];\r\n\t\t},\r\n\r\n\t\t'gradient-rgb': function() {\r\n\t\t\treturn [];\r\n\t\t},\r\n\r\n\t\t'rgb-gradient': function() {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t};\r\n\r\n\treturn Base.each(types, function(properties, type) {\r\n\t\tcomponentParsers[type] = [];\r\n\t\tBase.each(properties, function(name, index) {\r\n\t\t\tvar part = Base.capitalize(name),\r\n\t\t\t\thasOverlap = /^(hue|saturation)$/.test(name),\r\n\t\t\t\tparser = componentParsers[type][index] = name === 'gradient'\r\n\t\t\t\t\t? function(value) {\r\n\t\t\t\t\t\tvar current = this._components[0];\r\n\t\t\t\t\t\tvalue = Gradient.read(Array.isArray(value) ? value\r\n\t\t\t\t\t\t\t\t: arguments, 0, { readNull: true });\r\n\t\t\t\t\t\tif (current !== value) {\r\n\t\t\t\t\t\t\tif (current)\r\n\t\t\t\t\t\t\t\tcurrent._removeOwner(this);\r\n\t\t\t\t\t\t\tif (value)\r\n\t\t\t\t\t\t\t\tvalue._addOwner(this);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn value;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t: type === 'gradient'\r\n\t\t\t\t\t\t? function() {\r\n\t\t\t\t\t\t\treturn Point.read(arguments, 0, {\r\n\t\t\t\t\t\t\t\t\treadNull: name === 'highlight',\r\n\t\t\t\t\t\t\t\t\tclone: true\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t: function(value) {\r\n\t\t\t\t\t\t\treturn value == null || isNaN(value) ? 0 : value;\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\tthis['get' + part] = function() {\r\n\t\t\t\treturn this._type === type\r\n\t\t\t\t\t|| hasOverlap && /^hs[bl]$/.test(this._type)\r\n\t\t\t\t\t\t? this._components[index]\r\n\t\t\t\t\t\t: this._convert(type)[index];\r\n\t\t\t};\r\n\r\n\t\t\tthis['set' + part] = function(value) {\r\n\t\t\t\tif (this._type !== type\r\n\t\t\t\t\t\t&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {\r\n\t\t\t\t\tthis._components = this._convert(type);\r\n\t\t\t\t\tthis._properties = types[type];\r\n\t\t\t\t\tthis._type = type;\r\n\t\t\t\t}\r\n\t\t\t\tthis._components[index] = parser.call(this, value);\r\n\t\t\t\tthis._changed();\r\n\t\t\t};\r\n\t\t}, this);\r\n\t}, {\r\n\t\t_class: 'Color',\r\n\t\t_readIndex: true,\r\n\r\n\t\tinitialize: function Color(arg) {\r\n\t\t\tvar slice = Array.prototype.slice,\r\n\t\t\t\targs = arguments,\r\n\t\t\t\tread = 0,\r\n\t\t\t\ttype,\r\n\t\t\t\tcomponents,\r\n\t\t\t\talpha,\r\n\t\t\t\tvalues;\r\n\t\t\tif (Array.isArray(arg)) {\r\n\t\t\t\targs = arg;\r\n\t\t\t\targ = args[0];\r\n\t\t\t}\r\n\t\t\tvar argType = arg != null && typeof arg;\r\n\t\t\tif (argType === 'string' && arg in types) {\r\n\t\t\t\ttype = arg;\r\n\t\t\t\targ = args[1];\r\n\t\t\t\tif (Array.isArray(arg)) {\r\n\t\t\t\t\tcomponents = arg;\r\n\t\t\t\t\talpha = args[2];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (this.__read)\r\n\t\t\t\t\t\tread = 1;\r\n\t\t\t\t\targs = slice.call(args, 1);\r\n\t\t\t\t\targType = typeof arg;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!components) {\r\n\t\t\t\tvalues = argType === 'number'\r\n\t\t\t\t\t\t? args\r\n\t\t\t\t\t\t: argType === 'object' && arg.length != null\r\n\t\t\t\t\t\t\t? arg\r\n\t\t\t\t\t\t\t: null;\r\n\t\t\t\tif (values) {\r\n\t\t\t\t\tif (!type)\r\n\t\t\t\t\t\ttype = values.length >= 3\r\n\t\t\t\t\t\t\t\t? 'rgb'\r\n\t\t\t\t\t\t\t\t: 'gray';\r\n\t\t\t\t\tvar length = types[type].length;\r\n\t\t\t\t\talpha = values[length];\r\n\t\t\t\t\tif (this.__read)\r\n\t\t\t\t\t\tread += values === arguments\r\n\t\t\t\t\t\t\t? length + (alpha != null ? 1 : 0)\r\n\t\t\t\t\t\t\t: 1;\r\n\t\t\t\t\tif (values.length > length)\r\n\t\t\t\t\t\tvalues = slice.call(values, 0, length);\r\n\t\t\t\t} else if (argType === 'string') {\r\n\t\t\t\t\ttype = 'rgb';\r\n\t\t\t\t\tcomponents = fromCSS(arg);\r\n\t\t\t\t\tif (components.length === 4) {\r\n\t\t\t\t\t\talpha = components[3];\r\n\t\t\t\t\t\tcomponents.length--;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (argType === 'object') {\r\n\t\t\t\t\tif (arg.constructor === Color) {\r\n\t\t\t\t\t\ttype = arg._type;\r\n\t\t\t\t\t\tcomponents = arg._components.slice();\r\n\t\t\t\t\t\talpha = arg._alpha;\r\n\t\t\t\t\t\tif (type === 'gradient') {\r\n\t\t\t\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar point = components[i];\r\n\t\t\t\t\t\t\t\tif (point)\r\n\t\t\t\t\t\t\t\t\tcomponents[i] = point.clone();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (arg.constructor === Gradient) {\r\n\t\t\t\t\t\ttype = 'gradient';\r\n\t\t\t\t\t\tvalues = args;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttype = 'hue' in arg\r\n\t\t\t\t\t\t\t? 'lightness' in arg\r\n\t\t\t\t\t\t\t\t? 'hsl'\r\n\t\t\t\t\t\t\t\t: 'hsb'\r\n\t\t\t\t\t\t\t: 'gradient' in arg || 'stops' in arg\r\n\t\t\t\t\t\t\t\t\t|| 'radial' in arg\r\n\t\t\t\t\t\t\t\t? 'gradient'\r\n\t\t\t\t\t\t\t\t: 'gray' in arg\r\n\t\t\t\t\t\t\t\t\t? 'gray'\r\n\t\t\t\t\t\t\t\t\t: 'rgb';\r\n\t\t\t\t\t\tvar properties = types[type],\r\n\t\t\t\t\t\t\tparsers = componentParsers[type];\r\n\t\t\t\t\t\tthis._components = components = [];\r\n\t\t\t\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar value = arg[properties[i]];\r\n\t\t\t\t\t\t\tif (value == null && i === 0 && type === 'gradient'\r\n\t\t\t\t\t\t\t\t\t&& 'stops' in arg) {\r\n\t\t\t\t\t\t\t\tvalue = {\r\n\t\t\t\t\t\t\t\t\tstops: arg.stops,\r\n\t\t\t\t\t\t\t\t\tradial: arg.radial\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvalue = parsers[i].call(this, value);\r\n\t\t\t\t\t\t\tif (value != null)\r\n\t\t\t\t\t\t\t\tcomponents[i] = value;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\talpha = arg.alpha;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (this.__read && type)\r\n\t\t\t\t\tread = 1;\r\n\t\t\t}\r\n\t\t\tthis._type = type || 'rgb';\r\n\t\t\tthis._id = UID.get(Color);\r\n\t\t\tif (!components) {\r\n\t\t\t\tthis._components = components = [];\r\n\t\t\t\tvar parsers = componentParsers[this._type];\r\n\t\t\t\tfor (var i = 0, l = parsers.length; i < l; i++) {\r\n\t\t\t\t\tvar value = parsers[i].call(this, values && values[i]);\r\n\t\t\t\t\tif (value != null)\r\n\t\t\t\t\t\tcomponents[i] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis._components = components;\r\n\t\t\tthis._properties = types[this._type];\r\n\t\t\tthis._alpha = alpha;\r\n\t\t\tif (this.__read)\r\n\t\t\t\tthis.__read = read;\r\n\t\t},\r\n\r\n\t\t_serialize: function(options, dictionary) {\r\n\t\t\tvar components = this.getComponents();\r\n\t\t\treturn Base.serialize(\r\n\t\t\t\t\t/^(gray|rgb)$/.test(this._type)\r\n\t\t\t\t\t\t? components\r\n\t\t\t\t\t\t: [this._type].concat(components),\r\n\t\t\t\t\toptions, true, dictionary);\r\n\t\t},\r\n\r\n\t\t_changed: function() {\r\n\t\t\tthis._canvasStyle = null;\r\n\t\t\tif (this._owner)\r\n\t\t\t\tthis._owner._changed(65);\r\n\t\t},\r\n\r\n\t\t_convert: function(type) {\r\n\t\t\tvar converter;\r\n\t\t\treturn this._type === type\r\n\t\t\t\t\t? this._components.slice()\r\n\t\t\t\t\t: (converter = converters[this._type + '-' + type])\r\n\t\t\t\t\t\t? converter.apply(this, this._components)\r\n\t\t\t\t\t\t: converters['rgb-' + type].apply(this,\r\n\t\t\t\t\t\t\tconverters[this._type + '-rgb'].apply(this,\r\n\t\t\t\t\t\t\t\tthis._components));\r\n\t\t},\r\n\r\n\t\tconvert: function(type) {\r\n\t\t\treturn new Color(type, this._convert(type), this._alpha);\r\n\t\t},\r\n\r\n\t\tgetType: function() {\r\n\t\t\treturn this._type;\r\n\t\t},\r\n\r\n\t\tsetType: function(type) {\r\n\t\t\tthis._components = this._convert(type);\r\n\t\t\tthis._properties = types[type];\r\n\t\t\tthis._type = type;\r\n\t\t},\r\n\r\n\t\tgetComponents: function() {\r\n\t\t\tvar components = this._components.slice();\r\n\t\t\tif (this._alpha != null)\r\n\t\t\t\tcomponents.push(this._alpha);\r\n\t\t\treturn components;\r\n\t\t},\r\n\r\n\t\tgetAlpha: function() {\r\n\t\t\treturn this._alpha != null ? this._alpha : 1;\r\n\t\t},\r\n\r\n\t\tsetAlpha: function(alpha) {\r\n\t\t\tthis._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);\r\n\t\t\tthis._changed();\r\n\t\t},\r\n\r\n\t\thasAlpha: function() {\r\n\t\t\treturn this._alpha != null;\r\n\t\t},\r\n\r\n\t\tequals: function(color) {\r\n\t\t\tvar col = Base.isPlainValue(color, true)\r\n\t\t\t\t\t? Color.read(arguments)\r\n\t\t\t\t\t: color;\r\n\t\t\treturn col === this || col && this._class === col._class\r\n\t\t\t\t\t&& this._type === col._type\r\n\t\t\t\t\t&& this._alpha === col._alpha\r\n\t\t\t\t\t&& Base.equals(this._components, col._components)\r\n\t\t\t\t\t|| false;\r\n\t\t},\r\n\r\n\t\ttoString: function() {\r\n\t\t\tvar properties = this._properties,\r\n\t\t\t\tparts = [],\r\n\t\t\t\tisGradient = this._type === 'gradient',\r\n\t\t\t\tf = Formatter.instance;\r\n\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\r\n\t\t\t\tvar value = this._components[i];\r\n\t\t\t\tif (value != null)\r\n\t\t\t\t\tparts.push(properties[i] + ': '\r\n\t\t\t\t\t\t\t+ (isGradient ? value : f.number(value)));\r\n\t\t\t}\r\n\t\t\tif (this._alpha != null)\r\n\t\t\t\tparts.push('alpha: ' + f.number(this._alpha));\r\n\t\t\treturn '{ ' + parts.join(', ') + ' }';\r\n\t\t},\r\n\r\n\t\ttoCSS: function(hex) {\r\n\t\t\tvar components = this._convert('rgb'),\r\n\t\t\t\talpha = hex || this._alpha == null ? 1 : this._alpha;\r\n\t\t\tfunction convert(val) {\r\n\t\t\t\treturn Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);\r\n\t\t\t}\r\n\t\t\tcomponents = [\r\n\t\t\t\tconvert(components[0]),\r\n\t\t\t\tconvert(components[1]),\r\n\t\t\t\tconvert(components[2])\r\n\t\t\t];\r\n\t\t\tif (alpha < 1)\r\n\t\t\t\tcomponents.push(alpha < 0 ? 0 : alpha);\r\n\t\t\treturn hex\r\n\t\t\t\t\t? '#' + ((1 << 24) + (components[0] << 16)\r\n\t\t\t\t\t\t+ (components[1] << 8)\r\n\t\t\t\t\t\t+ components[2]).toString(16).slice(1)\r\n\t\t\t\t\t: (components.length == 4 ? 'rgba(' : 'rgb(')\r\n\t\t\t\t\t\t+ components.join(',') + ')';\r\n\t\t},\r\n\r\n\t\ttoCanvasStyle: function(ctx) {\r\n\t\t\tif (this._canvasStyle)\r\n\t\t\t\treturn this._canvasStyle;\r\n\t\t\tif (this._type !== 'gradient')\r\n\t\t\t\treturn this._canvasStyle = this.toCSS();\r\n\t\t\tvar components = this._components,\r\n\t\t\t\tgradient = components[0],\r\n\t\t\t\tstops = gradient._stops,\r\n\t\t\t\torigin = components[1],\r\n\t\t\t\tdestination = components[2],\r\n\t\t\t\tcanvasGradient;\r\n\t\t\tif (gradient._radial) {\r\n\t\t\t\tvar radius = destination.getDistance(origin),\r\n\t\t\t\t\thighlight = components[3];\r\n\t\t\t\tif (highlight) {\r\n\t\t\t\t\tvar vector = highlight.subtract(origin);\r\n\t\t\t\t\tif (vector.getLength() > radius)\r\n\t\t\t\t\t\thighlight = origin.add(vector.normalize(radius - 0.1));\r\n\t\t\t\t}\r\n\t\t\t\tvar start = highlight || origin;\r\n\t\t\t\tcanvasGradient = ctx.createRadialGradient(start.x, start.y,\r\n\t\t\t\t\t\t0, origin.x, origin.y, radius);\r\n\t\t\t} else {\r\n\t\t\t\tcanvasGradient = ctx.createLinearGradient(origin.x, origin.y,\r\n\t\t\t\t\t\tdestination.x, destination.y);\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\r\n\t\t\t\tvar stop = stops[i];\r\n\t\t\t\tcanvasGradient.addColorStop(stop._rampPoint,\r\n\t\t\t\t\t\tstop._color.toCanvasStyle());\r\n\t\t\t}\r\n\t\t\treturn this._canvasStyle = canvasGradient;\r\n\t\t},\r\n\r\n\t\ttransform: function(matrix) {\r\n\t\t\tif (this._type === 'gradient') {\r\n\t\t\t\tvar components = this._components;\r\n\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\r\n\t\t\t\t\tvar point = components[i];\r\n\t\t\t\t\tmatrix._transformPoint(point, point, true);\r\n\t\t\t\t}\r\n\t\t\t\tthis._changed();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tstatics: {\r\n\t\t\t_types: types,\r\n\r\n\t\t\trandom: function() {\r\n\t\t\t\tvar random = Math.random;\r\n\t\t\t\treturn new Color(random(), random(), random());\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n},\r\nnew function() {\r\n\tvar operators = {\r\n\t\tadd: function(a, b) {\r\n\t\t\treturn a + b;\r\n\t\t},\r\n\r\n\t\tsubtract: function(a, b) {\r\n\t\t\treturn a - b;\r\n\t\t},\r\n\r\n\t\tmultiply: function(a, b) {\r\n\t\t\treturn a * b;\r\n\t\t},\r\n\r\n\t\tdivide: function(a, b) {\r\n\t\t\treturn a / b;\r\n\t\t}\r\n\t};\r\n\r\n\treturn Base.each(operators, function(operator, name) {\r\n\t\tthis[name] = function(color) {\r\n\t\t\tcolor = Color.read(arguments);\r\n\t\t\tvar type = this._type,\r\n\t\t\t\tcomponents1 = this._components,\r\n\t\t\t\tcomponents2 = color._convert(type);\r\n\t\t\tfor (var i = 0, l = components1.length; i < l; i++)\r\n\t\t\t\tcomponents2[i] = operator(components1[i], components2[i]);\r\n\t\t\treturn new Color(type, components2,\r\n\t\t\t\t\tthis._alpha != null\r\n\t\t\t\t\t\t\t? operator(this._alpha, color.getAlpha())\r\n\t\t\t\t\t\t\t: null);\r\n\t\t};\r\n\t}, {\r\n\t});\r\n});\r\n\r\nvar Gradient = Base.extend({\r\n\t_class: 'Gradient',\r\n\r\n\tinitialize: function Gradient(stops, radial) {\r\n\t\tthis._id = UID.get();\r\n\t\tif (stops && this._set(stops))\r\n\t\t\tstops = radial = null;\r\n\t\tif (!this._stops)\r\n\t\t\tthis.setStops(stops || ['white', 'black']);\r\n\t\tif (this._radial == null)\r\n\t\t\tthis.setRadial(typeof radial === 'string' && radial === 'radial'\r\n\t\t\t\t\t|| radial || false);\r\n\t},\r\n\r\n\t_serialize: function(options, dictionary) {\r\n\t\treturn dictionary.add(this, function() {\r\n\t\t\treturn Base.serialize([this._stops, this._radial],\r\n\t\t\t\t\toptions, true, dictionary);\r\n\t\t});\r\n\t},\r\n\r\n\t_changed: function() {\r\n\t\tfor (var i = 0, l = this._owners && this._owners.length; i < l; i++)\r\n\t\t\tthis._owners[i]._changed();\r\n\t},\r\n\r\n\t_addOwner: function(color) {\r\n\t\tif (!this._owners)\r\n\t\t\tthis._owners = [];\r\n\t\tthis._owners.push(color);\r\n\t},\r\n\r\n\t_removeOwner: function(color) {\r\n\t\tvar index = this._owners ? this._owners.indexOf(color) : -1;\r\n\t\tif (index != -1) {\r\n\t\t\tthis._owners.splice(index, 1);\r\n\t\t\tif (this._owners.length === 0)\r\n\t\t\t\tthis._owners = undefined;\r\n\t\t}\r\n\t},\r\n\r\n\tclone: function() {\r\n\t\tvar stops = [];\r\n\t\tfor (var i = 0, l = this._stops.length; i < l; i++)\r\n\t\t\tstops[i] = this._stops[i].clone();\r\n\t\treturn new Gradient(stops, this._radial);\r\n\t},\r\n\r\n\tgetStops: function() {\r\n\t\treturn this._stops;\r\n\t},\r\n\r\n\tsetStops: function(stops) {\r\n\t\tif (this.stops) {\r\n\t\t\tfor (var i = 0, l = this._stops.length; i < l; i++)\r\n\t\t\t\tthis._stops[i]._owner = undefined;\r\n\t\t}\r\n\t\tif (stops.length < 2)\r\n\t\t\tthrow new Error(\r\n\t\t\t\t\t'Gradient stop list needs to contain at least two stops.');\r\n\t\tthis._stops = GradientStop.readAll(stops, 0, { clone: true });\r\n\t\tfor (var i = 0, l = this._stops.length; i < l; i++) {\r\n\t\t\tvar stop = this._stops[i];\r\n\t\t\tstop._owner = this;\r\n\t\t\tif (stop._defaultRamp)\r\n\t\t\t\tstop.setRampPoint(i / (l - 1));\r\n\t\t}\r\n\t\tthis._changed();\r\n\t},\r\n\r\n\tgetRadial: function() {\r\n\t\treturn this._radial;\r\n\t},\r\n\r\n\tsetRadial: function(radial) {\r\n\t\tthis._radial = radial;\r\n\t\tthis._changed();\r\n\t},\r\n\r\n\tequals: function(gradient) {\r\n\t\tif (gradient === this)\r\n\t\t\treturn true;\r\n\t\tif (gradient && this._class === gradient._class\r\n\t\t\t\t&& this._stops.length === gradient._stops.length) {\r\n\t\t\tfor (var i = 0, l = this._stops.length; i < l; i++) {\r\n\t\t\t\tif (!this._stops[i].equals(gradient._stops[i]))\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n});\r\n\r\nvar GradientStop = Base.extend({\r\n\t_class: 'GradientStop',\r\n\r\n\tinitialize: function GradientStop(arg0, arg1) {\r\n\t\tif (arg0) {\r\n\t\t\tvar color, rampPoint;\r\n\t\t\tif (arg1 === undefined && Array.isArray(arg0)) {\r\n\t\t\t\tcolor = arg0[0];\r\n\t\t\t\trampPoint = arg0[1];\r\n\t\t\t} else if (arg0.color) {\r\n\t\t\t\tcolor = arg0.color;\r\n\t\t\t\trampPoint = arg0.rampPoint;\r\n\t\t\t} else {\r\n\t\t\t\tcolor = arg0;\r\n\t\t\t\trampPoint = arg1;\r\n\t\t\t}\r\n\t\t\tthis.setColor(color);\r\n\t\t\tthis.setRampPoint(rampPoint);\r\n\t\t}\r\n\t},\r\n\r\n\tclone: function() {\r\n\t\treturn new GradientStop(this._color.clone(), this._rampPoint);\r\n\t},\r\n\r\n\t_serialize: function(options, dictionary) {\r\n\t\treturn Base.serialize([this._color, this._rampPoint], options, true,\r\n\t\t\t\tdictionary);\r\n\t},\r\n\r\n\t_changed: function() {\r\n\t\tif (this._owner)\r\n\t\t\tthis._owner._changed(65);\r\n\t},\r\n\r\n\tgetRampPoint: function() {\r\n\t\treturn this._rampPoint;\r\n\t},\r\n\r\n\tsetRampPoint: function(rampPoint) {\r\n\t\tthis._defaultRamp = rampPoint == null;\r\n\t\tthis._rampPoint = rampPoint || 0;\r\n\t\tthis._changed();\r\n\t},\r\n\r\n\tgetColor: function() {\r\n\t\treturn this._color;\r\n\t},\r\n\r\n\tsetColor: function(color) {\r\n\t\tthis._color = Color.read(arguments);\r\n\t\tif (this._color === color)\r\n\t\t\tthis._color = color.clone();\r\n\t\tthis._color._owner = this;\r\n\t\tthis._changed();\r\n\t},\r\n\r\n\tequals: function(stop) {\r\n\t\treturn stop === this || stop && this._class === stop._class\r\n\t\t\t\t&& this._color.equals(stop._color)\r\n\t\t\t\t&& this._rampPoint == stop._rampPoint\r\n\t\t\t\t|| false;\r\n\t}\r\n});\r\n\r\nvar Style = Base.extend(new function() {\r\n\tvar defaults = {\r\n\t\tfillColor: undefined,\r\n\t\tstrokeColor: undefined,\r\n\t\tstrokeWidth: 1,\r\n\t\tstrokeCap: 'butt',\r\n\t\tstrokeJoin: 'miter',\r\n\t\tstrokeScaling: true,\r\n\t\tmiterLimit: 10,\r\n\t\tdashOffset: 0,\r\n\t\tdashArray: [],\r\n\t\twindingRule: 'nonzero',\r\n\t\tshadowColor: undefined,\r\n\t\tshadowBlur: 0,\r\n\t\tshadowOffset: new Point(),\r\n\t\tselectedColor: undefined,\r\n\t\tfontFamily: 'sans-serif',\r\n\t\tfontWeight: 'normal',\r\n\t\tfontSize: 12,\r\n\t\tfont: 'sans-serif',\r\n\t\tleading: null,\r\n\t\tjustification: 'left'\r\n\t};\r\n\r\n\tvar flags = {\r\n\t\tstrokeWidth: 97,\r\n\t\tstrokeCap: 97,\r\n\t\tstrokeJoin: 97,\r\n\t\tstrokeScaling: 105,\r\n\t\tmiterLimit: 97,\r\n\t\tfontFamily: 9,\r\n\t\tfontWeight: 9,\r\n\t\tfontSize: 9,\r\n\t\tfont: 9,\r\n\t\tleading: 9,\r\n\t\tjustification: 9\r\n\t};\r\n\r\n\tvar item = { beans: true },\r\n\t\tfields = {\r\n\t\t\t_defaults: defaults,\r\n\t\t\t_textDefaults: new Base(defaults, {\r\n\t\t\t\tfillColor: new Color()\r\n\t\t\t}),\r\n\t\t\tbeans: true\r\n\t\t};\r\n\r\n\tBase.each(defaults, function(value, key) {\r\n\t\tvar isColor = /Color$/.test(key),\r\n\t\t\tisPoint = key === 'shadowOffset',\r\n\t\t\tpart = Base.capitalize(key),\r\n\t\t\tflag = flags[key],\r\n\t\t\tset = 'set' + part,\r\n\t\t\tget = 'get' + part;\r\n\r\n\t\tfields[set] = function(value) {\r\n\t\t\tvar owner = this._owner,\r\n\t\t\t\tchildren = owner && owner._children;\r\n\t\t\tif (children && children.length > 0\r\n\t\t\t\t\t&& !(owner instanceof CompoundPath)) {\r\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++)\r\n\t\t\t\t\tchildren[i]._style[set](value);\r\n\t\t\t} else {\r\n\t\t\t\tvar old = this._values[key];\r\n\t\t\t\tif (old !== value) {\r\n\t\t\t\t\tif (isColor) {\r\n\t\t\t\t\t\tif (old)\r\n\t\t\t\t\t\t\told._owner = undefined;\r\n\t\t\t\t\t\tif (value && value.constructor === Color) {\r\n\t\t\t\t\t\t\tif (value._owner)\r\n\t\t\t\t\t\t\t\tvalue = value.clone();\r\n\t\t\t\t\t\t\tvalue._owner = owner;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis._values[key] = value;\r\n\t\t\t\t\tif (owner)\r\n\t\t\t\t\t\towner._changed(flag || 65);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfields[get] = function(_dontMerge) {\r\n\t\t\tvar owner = this._owner,\r\n\t\t\t\tchildren = owner && owner._children,\r\n\t\t\t\tvalue;\r\n\t\t\tif (!children || children.length === 0 || _dontMerge\r\n\t\t\t\t\t|| owner instanceof CompoundPath) {\r\n\t\t\t\tvar value = this._values[key];\r\n\t\t\t\tif (value === undefined) {\r\n\t\t\t\t\tvalue = this._defaults[key];\r\n\t\t\t\t\tif (value && value.clone)\r\n\t\t\t\t\t\tvalue = value.clone();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar ctor = isColor ? Color : isPoint ? Point : null;\r\n\t\t\t\t\tif (ctor && !(value && value.constructor === ctor)) {\r\n\t\t\t\t\t\tthis._values[key] = value = ctor.read([value], 0,\r\n\t\t\t\t\t\t\t\t{ readNull: true, clone: true });\r\n\t\t\t\t\t\tif (value && isColor)\r\n\t\t\t\t\t\t\tvalue._owner = owner;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\r\n\t\t\t\tvar childValue = children[i]._style[get]();\r\n\t\t\t\tif (i === 0) {\r\n\t\t\t\t\tvalue = childValue;\r\n\t\t\t\t} else if (!Base.equals(value, childValue)) {\r\n\t\t\t\t\treturn undefined;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t};\r\n\r\n\t\titem[get] = function(_dontMerge) {\r\n\t\t\treturn this._style[get](_dontMerge);\r\n\t\t};\r\n\r\n\t\titem[set] = function(value) {\r\n\t\t\tthis._style[set](value);\r\n\t\t};\r\n\t});\r\n\r\n\tItem.inject(item);\r\n\treturn fields;\r\n}, {\r\n\t_class: 'Style',\r\n\r\n\tinitialize: function Style(style, _owner, _project) {\r\n\t\tthis._values = {};\r\n\t\tthis._owner = _owner;\r\n\t\tthis._project = _owner && _owner._project || _project || paper.project;\r\n\t\tif (_owner instanceof TextItem)\r\n\t\t\tthis._defaults = this._textDefaults;\r\n\t\tif (style)\r\n\t\t\tthis.set(style);\r\n\t},\r\n\r\n\tset: function(style) {\r\n\t\tvar isStyle = style instanceof Style,\r\n\t\t\tvalues = isStyle ? style._values : style;\r\n\t\tif (values) {\r\n\t\t\tfor (var key in values) {\r\n\t\t\t\tif (key in this._defaults) {\r\n\t\t\t\t\tvar value = values[key];\r\n\t\t\t\t\tthis[key] = value && isStyle && value.clone\r\n\t\t\t\t\t\t\t? value.clone() : value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tequals: function(style) {\r\n\t\treturn style === this || style && this._class === style._class\r\n\t\t\t\t&& Base.equals(this._values, style._values)\r\n\t\t\t\t|| false;\r\n\t},\r\n\r\n\thasFill: function() {\r\n\t\treturn !!this.getFillColor();\r\n\t},\r\n\r\n\thasStroke: function() {\r\n\t\treturn !!this.getStrokeColor() && this.getStrokeWidth() > 0;\r\n\t},\r\n\r\n\thasShadow: function() {\r\n\t\treturn !!this.getShadowColor() && this.getShadowBlur() > 0;\r\n\t},\r\n\r\n\tgetView: function() {\r\n\t\treturn this._project.getView();\r\n\t},\r\n\r\n\tgetFontStyle: function() {\r\n\t\tvar fontSize = this.getFontSize();\r\n\t\treturn this.getFontWeight()\r\n\t\t\t\t+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')\r\n\t\t\t\t+ this.getFontFamily();\r\n\t},\r\n\r\n\tgetFont: '#getFontFamily',\r\n\tsetFont: '#setFontFamily',\r\n\r\n\tgetLeading: function getLeading() {\r\n\t\tvar leading = getLeading.base.call(this),\r\n\t\t\tfontSize = this.getFontSize();\r\n\t\tif (/pt|em|%|px/.test(fontSize))\r\n\t\t\tfontSize = this.getView().getPixelSize(fontSize);\r\n\t\treturn leading != null ? leading : fontSize * 1.2;\r\n\t}\r\n\r\n});\r\n\r\nvar DomElement = new function() {\r\n\tfunction handlePrefix(el, name, set, value) {\r\n\t\tvar prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],\r\n\t\t\tsuffix = name[0].toUpperCase() + name.substring(1);\r\n\t\tfor (var i = 0; i < 6; i++) {\r\n\t\t\tvar prefix = prefixes[i],\r\n\t\t\t\tkey = prefix ? prefix + suffix : name;\r\n\t\t\tif (key in el) {\r\n\t\t\t\tif (set) {\r\n\t\t\t\t\tel[key] = value;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn el[key];\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tgetStyles: function(el) {\r\n\t\t\tvar doc = el && el.nodeType !== 9 ? el.ownerDocument : el,\r\n\t\t\t\tview = doc && doc.defaultView;\r\n\t\t\treturn view && view.getComputedStyle(el, '');\r\n\t\t},\r\n\r\n\t\tgetBounds: function(el, viewport) {\r\n\t\t\tvar doc = el.ownerDocument,\r\n\t\t\t\tbody = doc.body,\r\n\t\t\t\thtml = doc.documentElement,\r\n\t\t\t\trect;\r\n\t\t\ttry {\r\n\t\t\t\trect = el.getBoundingClientRect();\r\n\t\t\t} catch (e) {\r\n\t\t\t\trect = { left: 0, top: 0, width: 0, height: 0 };\r\n\t\t\t}\r\n\t\t\tvar x = rect.left - (html.clientLeft || body.clientLeft || 0),\r\n\t\t\t\ty = rect.top - (html.clientTop || body.clientTop || 0);\r\n\t\t\tif (!viewport) {\r\n\t\t\t\tvar view = doc.defaultView;\r\n\t\t\t\tx += view.pageXOffset || html.scrollLeft || body.scrollLeft;\r\n\t\t\t\ty += view.pageYOffset || html.scrollTop || body.scrollTop;\r\n\t\t\t}\r\n\t\t\treturn new Rectangle(x, y, rect.width, rect.height);\r\n\t\t},\r\n\r\n\t\tgetViewportBounds: function(el) {\r\n\t\t\tvar doc = el.ownerDocument,\r\n\t\t\t\tview = doc.defaultView,\r\n\t\t\t\thtml = doc.documentElement;\r\n\t\t\treturn new Rectangle(0, 0,\r\n\t\t\t\tview.innerWidth || html.clientWidth,\r\n\t\t\t\tview.innerHeight || html.clientHeight\r\n\t\t\t);\r\n\t\t},\r\n\r\n\t\tgetOffset: function(el, viewport) {\r\n\t\t\treturn DomElement.getBounds(el, viewport).getPoint();\r\n\t\t},\r\n\r\n\t\tgetSize: function(el) {\r\n\t\t\treturn DomElement.getBounds(el, true).getSize();\r\n\t\t},\r\n\r\n\t\tisInvisible: function(el) {\r\n\t\t\treturn DomElement.getSize(el).equals(new Size(0, 0));\r\n\t\t},\r\n\r\n\t\tisInView: function(el) {\r\n\t\t\treturn !DomElement.isInvisible(el)\r\n\t\t\t\t\t&& DomElement.getViewportBounds(el).intersects(\r\n\t\t\t\t\t\tDomElement.getBounds(el, true));\r\n\t\t},\r\n\r\n\t\tgetPrefixed: function(el, name) {\r\n\t\t\treturn handlePrefix(el, name);\r\n\t\t},\r\n\r\n\t\tsetPrefixed: function(el, name, value) {\r\n\t\t\tif (typeof name === 'object') {\r\n\t\t\t\tfor (var key in name)\r\n\t\t\t\t\thandlePrefix(el, key, true, name[key]);\r\n\t\t\t} else {\r\n\t\t\t\thandlePrefix(el, name, true, value);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n};\r\n\r\nvar DomEvent = {\r\n\tadd: function(el, events) {\r\n\t\tfor (var type in events) {\r\n\t\t\tvar func = events[type],\r\n\t\t\t\tparts = type.split(/[\\s,]+/g);\r\n\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\r\n\t\t\t\tel.addEventListener(parts[i], func, false);\r\n\t\t}\r\n\t},\r\n\r\n\tremove: function(el, events) {\r\n\t\tfor (var type in events) {\r\n\t\t\tvar func = events[type],\r\n\t\t\t\tparts = type.split(/[\\s,]+/g);\r\n\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\r\n\t\t\t\tel.removeEventListener(parts[i], func, false);\r\n\t\t}\r\n\t},\r\n\r\n\tgetPoint: function(event) {\r\n\t\tvar pos = event.targetTouches\r\n\t\t\t\t? event.targetTouches.length\r\n\t\t\t\t\t? event.targetTouches[0]\r\n\t\t\t\t\t: event.changedTouches[0]\r\n\t\t\t\t: event;\r\n\t\treturn new Point(\r\n\t\t\tpos.pageX || pos.clientX + document.documentElement.scrollLeft,\r\n\t\t\tpos.pageY || pos.clientY + document.documentElement.scrollTop\r\n\t\t);\r\n\t},\r\n\r\n\tgetTarget: function(event) {\r\n\t\treturn event.target || event.srcElement;\r\n\t},\r\n\r\n\tgetRelatedTarget: function(event) {\r\n\t\treturn event.relatedTarget || event.toElement;\r\n\t},\r\n\r\n\tgetOffset: function(event, target) {\r\n\t\treturn DomEvent.getPoint(event).subtract(DomElement.getOffset(\r\n\t\t\t\ttarget || DomEvent.getTarget(event)));\r\n\t},\r\n\r\n\tstop: function(event) {\r\n\t\tevent.stopPropagation();\r\n\t\tevent.preventDefault();\r\n\t}\r\n};\r\n\r\nDomEvent.requestAnimationFrame = new function() {\r\n\tvar nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),\r\n\t\trequested = false,\r\n\t\tcallbacks = [],\r\n\t\tfocused = true,\r\n\t\ttimer;\r\n\r\n\tDomEvent.add(window, {\r\n\t\tfocus: function() {\r\n\t\t\tfocused = true;\r\n\t\t},\r\n\t\tblur: function() {\r\n\t\t\tfocused = false;\r\n\t\t}\r\n\t});\r\n\r\n\tfunction handleCallbacks() {\r\n\t\tfor (var i = callbacks.length - 1; i >= 0; i--) {\r\n\t\t\tvar entry = callbacks[i],\r\n\t\t\t\tfunc = entry[0],\r\n\t\t\t\tel = entry[1];\r\n\t\t\tif (!el || (PaperScope.getAttribute(el, 'keepalive') == 'true'\r\n\t\t\t\t\t|| focused) && DomElement.isInView(el)) {\r\n\t\t\t\tcallbacks.splice(i, 1);\r\n\t\t\t\tfunc();\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (nativeRequest) {\r\n\t\t\tif (callbacks.length) {\r\n\t\t\t\tnativeRequest(handleCallbacks);\r\n\t\t\t} else {\r\n\t\t\t\trequested = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn function(callback, element) {\r\n\t\tcallbacks.push([callback, element]);\r\n\t\tif (nativeRequest) {\r\n\t\t\tif (!requested) {\r\n\t\t\t\tnativeRequest(handleCallbacks);\r\n\t\t\t\trequested = true;\r\n\t\t\t}\r\n\t\t} else if (!timer) {\r\n\t\t\ttimer = setInterval(handleCallbacks, 1000 / 60);\r\n\t\t}\r\n\t};\r\n};\r\n\r\nvar View = Base.extend(Emitter, {\r\n\t_class: 'View',\r\n\r\n\tinitialize: function View(project, element) {\r\n\t\tthis._project = project;\r\n\t\tthis._scope = project._scope;\r\n\t\tthis._element = element;\r\n\t\tvar size;\r\n\t\tif (!this._pixelRatio)\r\n\t\t\tthis._pixelRatio = window.devicePixelRatio || 1;\r\n\t\tthis._id = element.getAttribute('id');\r\n\t\tif (this._id == null)\r\n\t\t\telement.setAttribute('id', this._id = 'view-' + View._id++);\r\n\t\tDomEvent.add(element, this._viewEvents);\r\n\t\tvar none = 'none';\r\n\t\tDomElement.setPrefixed(element.style, {\r\n\t\t\tuserSelect: none,\r\n\t\t\ttouchAction: none,\r\n\t\t\ttouchCallout: none,\r\n\t\t\tcontentZooming: none,\r\n\t\t\tuserDrag: none,\r\n\t\t\ttapHighlightColor: 'rgba(0,0,0,0)'\r\n\t\t});\r\n\r\n\t\tfunction getSize(name) {\r\n\t\t\treturn element[name] || parseInt(element.getAttribute(name), 10);\r\n\t\t};\r\n\r\n\t\tfunction getCanvasSize() {\r\n\t\t\tvar size = DomElement.getSize(element);\r\n\t\t\treturn size.isNaN() || size.isZero()\r\n\t\t\t\t\t? new Size(getSize('width'), getSize('height'))\r\n\t\t\t\t\t: size;\r\n\t\t};\r\n\r\n\t\tif (PaperScope.hasAttribute(element, 'resize')) {\r\n\t\t\tvar that = this;\r\n\t\t\tDomEvent.add(window, this._windowEvents = {\r\n\t\t\t\tresize: function() {\r\n\t\t\t\t\tthat.setViewSize(getCanvasSize());\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\tthis._setViewSize(size = getCanvasSize());\r\n\t\tif (PaperScope.hasAttribute(element, 'stats')\r\n\t\t\t\t&& typeof Stats !== 'undefined') {\r\n\t\t\tthis._stats = new Stats();\r\n\t\t\tvar stats = this._stats.domElement,\r\n\t\t\t\tstyle = stats.style,\r\n\t\t\t\toffset = DomElement.getOffset(element);\r\n\t\t\tstyle.position = 'absolute';\r\n\t\t\tstyle.left = offset.x + 'px';\r\n\t\t\tstyle.top = offset.y + 'px';\r\n\t\t\tdocument.body.appendChild(stats);\r\n\t\t}\r\n\t\tView._views.push(this);\r\n\t\tView._viewsById[this._id] = this;\r\n\t\tthis._viewSize = size;\r\n\t\t(this._matrix = new Matrix())._owner = this;\r\n\t\tthis._zoom = 1;\r\n\t\tif (!View._focused)\r\n\t\t\tView._focused = this;\r\n\t\tthis._frameItems = {};\r\n\t\tthis._frameItemCount = 0;\r\n\t},\r\n\r\n\tremove: function() {\r\n\t\tif (!this._project)\r\n\t\t\treturn false;\r\n\t\tif (View._focused === this)\r\n\t\t\tView._focused = null;\r\n\t\tView._views.splice(View._views.indexOf(this), 1);\r\n\t\tdelete View._viewsById[this._id];\r\n\t\tif (this._project._view === this)\r\n\t\t\tthis._project._view = null;\r\n\t\tDomEvent.remove(this._element, this._viewEvents);\r\n\t\tDomEvent.remove(window, this._windowEvents);\r\n\t\tthis._element = this._project = null;\r\n\t\tthis.off('frame');\r\n\t\tthis._animate = false;\r\n\t\tthis._frameItems = {};\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_events: Base.each(['onResize', 'onMouseDown', 'onMouseUp', 'onMouseMove'],\r\n\t\tfunction(name) {\r\n\t\t\tthis[name] = {\r\n\t\t\t\tinstall: function(type) {\r\n\t\t\t\t\tthis._installEvent(type);\r\n\t\t\t\t},\r\n\r\n\t\t\t\tuninstall: function(type) {\r\n\t\t\t\t\tthis._uninstallEvent(type);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}, {\r\n\t\t\tonFrame: {\r\n\t\t\t\tinstall: function() {\r\n\t\t\t\t\tthis.play();\r\n\t\t\t\t},\r\n\r\n\t\t\t\tuninstall: function() {\r\n\t\t\t\t\tthis.pause();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t),\r\n\r\n\t_animate: false,\r\n\t_time: 0,\r\n\t_count: 0,\r\n\r\n\t_requestFrame: function() {\r\n\t\tvar that = this;\r\n\t\tDomEvent.requestAnimationFrame(function() {\r\n\t\t\tthat._requested = false;\r\n\t\t\tif (!that._animate)\r\n\t\t\t\treturn;\r\n\t\t\tthat._requestFrame();\r\n\t\t\tthat._handleFrame();\r\n\t\t}, this._element);\r\n\t\tthis._requested = true;\r\n\t},\r\n\r\n\t_handleFrame: function() {\r\n\t\tpaper = this._scope;\r\n\t\tvar now = Date.now() / 1000,\r\n\t\t\tdelta = this._before ? now - this._before : 0;\r\n\t\tthis._before = now;\r\n\t\tthis._handlingFrame = true;\r\n\t\tthis.emit('frame', new Base({\r\n\t\t\tdelta: delta,\r\n\t\t\ttime: this._time += delta,\r\n\t\t\tcount: this._count++\r\n\t\t}));\r\n\t\tif (this._stats)\r\n\t\t\tthis._stats.update();\r\n\t\tthis._handlingFrame = false;\r\n\t\tthis.update();\r\n\t},\r\n\r\n\t_animateItem: function(item, animate) {\r\n\t\tvar items = this._frameItems;\r\n\t\tif (animate) {\r\n\t\t\titems[item._id] = {\r\n\t\t\t\titem: item,\r\n\t\t\t\ttime: 0,\r\n\t\t\t\tcount: 0\r\n\t\t\t};\r\n\t\t\tif (++this._frameItemCount === 1)\r\n\t\t\t\tthis.on('frame', this._handleFrameItems);\r\n\t\t} else {\r\n\t\t\tdelete items[item._id];\r\n\t\t\tif (--this._frameItemCount === 0) {\r\n\t\t\t\tthis.off('frame', this._handleFrameItems);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_handleFrameItems: function(event) {\r\n\t\tfor (var i in this._frameItems) {\r\n\t\t\tvar entry = this._frameItems[i];\r\n\t\t\tentry.item.emit('frame', new Base(event, {\r\n\t\t\t\ttime: entry.time += event.delta,\r\n\t\t\t\tcount: entry.count++\r\n\t\t\t}));\r\n\t\t}\r\n\t},\r\n\r\n\t_update: function() {\r\n\t\tthis._project._needsUpdate = true;\r\n\t\tif (this._handlingFrame)\r\n\t\t\treturn;\r\n\t\tif (this._animate) {\r\n\t\t\tthis._handleFrame();\r\n\t\t} else {\r\n\t\t\tthis.update();\r\n\t\t}\r\n\t},\r\n\r\n\t_changed: function(flags) {\r\n\t\tif (flags & 1)\r\n\t\t\tthis._project._needsUpdate = true;\r\n\t},\r\n\r\n\t_transform: function(matrix) {\r\n\t\tthis._matrix.concatenate(matrix);\r\n\t\tthis._bounds = null;\r\n\t\tthis._update();\r\n\t},\r\n\r\n\tgetElement: function() {\r\n\t\treturn this._element;\r\n\t},\r\n\r\n\tgetPixelRatio: function() {\r\n\t\treturn this._pixelRatio;\r\n\t},\r\n\r\n\tgetResolution: function() {\r\n\t\treturn this._pixelRatio * 72;\r\n\t},\r\n\r\n\tgetViewSize: function() {\r\n\t\tvar size = this._viewSize;\r\n\t\treturn new LinkedSize(size.width, size.height, this, 'setViewSize');\r\n\t},\r\n\r\n\tsetViewSize: function() {\r\n\t\tvar size = Size.read(arguments),\r\n\t\t\tdelta = size.subtract(this._viewSize);\r\n\t\tif (delta.isZero())\r\n\t\t\treturn;\r\n\t\tthis._viewSize.set(size.width, size.height);\r\n\t\tthis._setViewSize(size);\r\n\t\tthis._bounds = null;\r\n\t\tthis.emit('resize', {\r\n\t\t\tsize: size,\r\n\t\t\tdelta: delta\r\n\t\t});\r\n\t\tthis._update();\r\n\t},\r\n\r\n\t_setViewSize: function(size) {\r\n\t\tvar element = this._element;\r\n\t\telement.width = size.width;\r\n\t\telement.height = size.height;\r\n\t},\r\n\r\n\tgetBounds: function() {\r\n\t\tif (!this._bounds)\r\n\t\t\tthis._bounds = this._matrix.inverted()._transformBounds(\r\n\t\t\t\t\tnew Rectangle(new Point(), this._viewSize));\r\n\t\treturn this._bounds;\r\n\t},\r\n\r\n\tgetSize: function() {\r\n\t\treturn this.getBounds().getSize();\r\n\t},\r\n\r\n\tgetCenter: function() {\r\n\t\treturn this.getBounds().getCenter();\r\n\t},\r\n\r\n\tsetCenter: function() {\r\n\t\tvar center = Point.read(arguments);\r\n\t\tthis.scrollBy(center.subtract(this.getCenter()));\r\n\t},\r\n\r\n\tgetZoom: function() {\r\n\t\treturn this._zoom;\r\n\t},\r\n\r\n\tsetZoom: function(zoom) {\r\n\t\tthis._transform(new Matrix().scale(zoom / this._zoom,\r\n\t\t\tthis.getCenter()));\r\n\t\tthis._zoom = zoom;\r\n\t},\r\n\r\n\tisVisible: function() {\r\n\t\treturn DomElement.isInView(this._element);\r\n\t},\r\n\r\n\tscrollBy: function() {\r\n\t\tthis._transform(new Matrix().translate(Point.read(arguments).negate()));\r\n\t},\r\n\r\n\tplay: function() {\r\n\t\tthis._animate = true;\r\n\t\tif (!this._requested)\r\n\t\t\tthis._requestFrame();\r\n\t},\r\n\r\n\tpause: function() {\r\n\t\tthis._animate = false;\r\n\t},\r\n\r\n\tdraw: function() {\r\n\t\tthis.update();\r\n\t},\r\n\r\n\tprojectToView: function() {\r\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\r\n\t},\r\n\r\n\tviewToProject: function() {\r\n\t\treturn this._matrix._inverseTransform(Point.read(arguments));\r\n\t}\r\n\r\n}, {\r\n\tstatics: {\r\n\t\t_views: [],\r\n\t\t_viewsById: {},\r\n\t\t_id: 0,\r\n\r\n\t\tcreate: function(project, element) {\r\n\t\t\tif (typeof element === 'string')\r\n\t\t\t\telement = document.getElementById(element);\r\n\t\t\treturn new CanvasView(project, element);\r\n\t\t}\r\n\t}\r\n},\r\nnew function() {\r\n\tvar tool,\r\n\t\tprevFocus,\r\n\t\ttempFocus,\r\n\t\tdragging = false;\r\n\r\n\tfunction getView(event) {\r\n\t\tvar target = DomEvent.getTarget(event);\r\n\t\treturn target.getAttribute && View._viewsById[target.getAttribute('id')];\r\n\t}\r\n\r\n\tfunction viewToProject(view, event) {\r\n\t\treturn view.viewToProject(DomEvent.getOffset(event, view._element));\r\n\t}\r\n\r\n\tfunction updateFocus() {\r\n\t\tif (!View._focused || !View._focused.isVisible()) {\r\n\t\t\tfor (var i = 0, l = View._views.length; i < l; i++) {\r\n\t\t\t\tvar view = View._views[i];\r\n\t\t\t\tif (view && view.isVisible()) {\r\n\t\t\t\t\tView._focused = tempFocus = view;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction handleMouseMove(view, point, event) {\r\n\t\tview._handleEvent('mousemove', point, event);\r\n\t\tvar tool = view._scope.tool;\r\n\t\tif (tool) {\r\n\t\t\ttool._handleEvent(dragging && tool.responds('mousedrag')\r\n\t\t\t\t\t? 'mousedrag' : 'mousemove', point, event);\r\n\t\t}\r\n\t\tview.update();\r\n\t\treturn tool;\r\n\t}\r\n\r\n\tvar navigator = window.navigator,\r\n\t\tmousedown, mousemove, mouseup;\r\n\tif (navigator.pointerEnabled || navigator.msPointerEnabled) {\r\n\t\tmousedown = 'pointerdown MSPointerDown';\r\n\t\tmousemove = 'pointermove MSPointerMove';\r\n\t\tmouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';\r\n\t} else {\r\n\t\tmousedown = 'touchstart';\r\n\t\tmousemove = 'touchmove';\r\n\t\tmouseup = 'touchend touchcancel';\r\n\t\tif (!('ontouchstart' in window && navigator.userAgent.match(\r\n\t\t\t\t/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {\r\n\t\t\tmousedown += ' mousedown';\r\n\t\t\tmousemove += ' mousemove';\r\n\t\t\tmouseup += ' mouseup';\r\n\t\t}\r\n\t}\r\n\r\n\tvar viewEvents = {\r\n\t\t'selectstart dragstart': function(event) {\r\n\t\t\tif (dragging)\r\n\t\t\t\tevent.preventDefault();\r\n\t\t}\r\n\t};\r\n\r\n\tvar docEvents = {\r\n\t\tmouseout: function(event) {\r\n\t\t\tvar view = View._focused,\r\n\t\t\t\ttarget = DomEvent.getRelatedTarget(event);\r\n\t\t\tif (view && (!target || target.nodeName === 'HTML'))\r\n\t\t\t\thandleMouseMove(view, viewToProject(view, event), event);\r\n\t\t},\r\n\r\n\t\tscroll: updateFocus\r\n\t};\r\n\r\n\tviewEvents[mousedown] = function(event) {\r\n\t\tvar view = View._focused = getView(event),\r\n\t\t\tpoint = viewToProject(view, event);\r\n\t\tdragging = true;\r\n\t\tview._handleEvent('mousedown', point, event);\r\n\t\tif (tool = view._scope.tool)\r\n\t\t\ttool._handleEvent('mousedown', point, event);\r\n\t\tview.update();\r\n\t};\r\n\r\n\tdocEvents[mousemove] = function(event) {\r\n\t\tvar view = View._focused;\r\n\t\tif (!dragging) {\r\n\t\t\tvar target = getView(event);\r\n\t\t\tif (target) {\r\n\t\t\t\tif (view !== target)\r\n\t\t\t\t\thandleMouseMove(view, viewToProject(view, event), event);\r\n\t\t\t\tprevFocus = view;\r\n\t\t\t\tview = View._focused = tempFocus = target;\r\n\t\t\t} else if (tempFocus && tempFocus === view) {\r\n\t\t\t\tview = View._focused = prevFocus;\r\n\t\t\t\tupdateFocus();\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (view) {\r\n\t\t\tvar point = viewToProject(view, event);\r\n\t\t\tif (dragging || view.getBounds().contains(point))\r\n\t\t\t\ttool = handleMouseMove(view, point, event);\r\n\t\t}\r\n\t};\r\n\r\n\tdocEvents[mouseup] = function(event) {\r\n\t\tvar view = View._focused;\r\n\t\tif (!view || !dragging)\r\n\t\t\treturn;\r\n\t\tvar point = viewToProject(view, event);\r\n\t\tdragging = false;\r\n\t\tview._handleEvent('mouseup', point, event);\r\n\t\tif (tool)\r\n\t\t\ttool._handleEvent('mouseup', point, event);\r\n\t\tview.update();\r\n\t};\r\n\r\n\tDomEvent.add(document, docEvents);\r\n\r\n\tDomEvent.add(window, {\r\n\t\tload: updateFocus\r\n\t});\r\n\r\n\tvar mouseFlags = {\r\n\t\tmousedown: {\r\n\t\t\tmousedown: 1,\r\n\t\t\tmousedrag: 1,\r\n\t\t\tclick: 1,\r\n\t\t\tdoubleclick: 1\r\n\t\t},\r\n\t\tmouseup: {\r\n\t\t\tmouseup: 1,\r\n\t\t\tmousedrag: 1,\r\n\t\t\tclick: 1,\r\n\t\t\tdoubleclick: 1\r\n\t\t},\r\n\t\tmousemove: {\r\n\t\t\tmousedrag: 1,\r\n\t\t\tmousemove: 1,\r\n\t\t\tmouseenter: 1,\r\n\t\t\tmouseleave: 1\r\n\t\t}\r\n\t};\r\n\r\n\treturn {\r\n\t\t_viewEvents: viewEvents,\r\n\r\n\t\t_handleEvent: function() {},\r\n\r\n\t\t_installEvent: function(type) {\r\n\t\t\tvar counters = this._eventCounters;\r\n\t\t\tif (counters) {\r\n\t\t\t\tfor (var key in mouseFlags) {\r\n\t\t\t\t\tcounters[key] = (counters[key] || 0)\r\n\t\t\t\t\t\t\t+ (mouseFlags[key][type] || 0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_uninstallEvent: function(type) {\r\n\t\t\tvar counters = this._eventCounters;\r\n\t\t\tif (counters) {\r\n\t\t\t\tfor (var key in mouseFlags)\r\n\t\t\t\t\tcounters[key] -= mouseFlags[key][type] || 0;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tstatics: {\r\n\t\t\tupdateFocus: updateFocus\r\n\t\t}\r\n\t};\r\n});\r\n\r\nvar CanvasView = View.extend({\r\n\t_class: 'CanvasView',\r\n\r\n\tinitialize: function CanvasView(project, canvas) {\r\n\t\tif (!(canvas instanceof HTMLCanvasElement)) {\r\n\t\t\tvar size = Size.read(arguments, 1);\r\n\t\t\tif (size.isZero())\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t'Cannot create CanvasView with the provided argument: '\r\n\t\t\t\t\t\t+ [].slice.call(arguments, 1));\r\n\t\t\tcanvas = CanvasProvider.getCanvas(size);\r\n\t\t}\r\n\t\tthis._context = canvas.getContext('2d');\r\n\t\tthis._eventCounters = {};\r\n\t\tthis._pixelRatio = 1;\r\n\t\tif (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {\r\n\t\t\tvar deviceRatio = window.devicePixelRatio || 1,\r\n\t\t\t\tbackingStoreRatio = DomElement.getPrefixed(this._context,\r\n\t\t\t\t\t\t'backingStorePixelRatio') || 1;\r\n\t\t\tthis._pixelRatio = deviceRatio / backingStoreRatio;\r\n\t\t}\r\n\t\tView.call(this, project, canvas);\r\n\t},\r\n\r\n\t_setViewSize: function(size) {\r\n\t\tvar element = this._element,\r\n\t\t\tpixelRatio = this._pixelRatio,\r\n\t\t\twidth = size.width,\r\n\t\t\theight = size.height;\r\n\t\telement.width = width * pixelRatio;\r\n\t\telement.height = height * pixelRatio;\r\n\t\tif (pixelRatio !== 1) {\r\n\t\t\tif (!PaperScope.hasAttribute(element, 'resize')) {\r\n\t\t\t\tvar style = element.style;\r\n\t\t\t\tstyle.width = width + 'px';\r\n\t\t\t\tstyle.height = height + 'px';\r\n\t\t\t}\r\n\t\t\tthis._context.scale(pixelRatio, pixelRatio);\r\n\t\t}\r\n\t},\r\n\r\n\tgetPixelSize: function(size) {\r\n\t\tvar browser = paper.browser,\r\n\t\t\tpixels;\r\n\t\tif (browser && browser.firefox) {\r\n\t\t\tvar parent = this._element.parentNode,\r\n\t\t\t\ttemp = document.createElement('div');\r\n\t\t\ttemp.style.fontSize = size;\r\n\t\t\tparent.appendChild(temp);\r\n\t\t\tpixels = parseFloat(DomElement.getStyles(temp).fontSize);\r\n\t\t\tparent.removeChild(temp);\r\n\t\t} else {\r\n\t\t\tvar ctx = this._context,\r\n\t\t\t\tprevFont = ctx.font;\r\n\t\t\tctx.font = size + ' serif';\r\n\t\t\tpixels = parseFloat(ctx.font);\r\n\t\t\tctx.font = prevFont;\r\n\t\t}\r\n\t\treturn pixels;\r\n\t},\r\n\r\n\tgetTextWidth: function(font, lines) {\r\n\t\tvar ctx = this._context,\r\n\t\t\tprevFont = ctx.font,\r\n\t\t\twidth = 0;\r\n\t\tctx.font = font;\r\n\t\tfor (var i = 0, l = lines.length; i < l; i++)\r\n\t\t\twidth = Math.max(width, ctx.measureText(lines[i]).width);\r\n\t\tctx.font = prevFont;\r\n\t\treturn width;\r\n\t},\r\n\r\n\tupdate: function(force) {\r\n\t\tvar project = this._project;\r\n\t\tif (!project || !force && !project._needsUpdate)\r\n\t\t\treturn false;\r\n\t\tvar ctx = this._context,\r\n\t\t\tsize = this._viewSize;\r\n\t\tctx.clearRect(0, 0, size.width + 1, size.height + 1);\r\n\t\tproject.draw(ctx, this._matrix, this._pixelRatio);\r\n\t\tproject._needsUpdate = false;\r\n\t\treturn true;\r\n\t}\r\n},\r\nnew function() {\r\n\tvar downPoint,\r\n\t\tlastPoint,\r\n\t\toverPoint,\r\n\t\tdownItem,\r\n\t\tlastItem,\r\n\t\toverItem,\r\n\t\tdragItem,\r\n\t\tdblClick,\r\n\t\tclickTime;\r\n\r\n\tfunction callEvent(view, type, event, point, target, lastPoint) {\r\n\t\tvar item = target,\r\n\t\t\tmouseEvent;\r\n\r\n\t\tfunction call(obj) {\r\n\t\t\tif (obj.responds(type)) {\r\n\t\t\t\tif (!mouseEvent) {\r\n\t\t\t\t\tmouseEvent = new MouseEvent(type, event, point, target,\r\n\t\t\t\t\t\t\tlastPoint ? point.subtract(lastPoint) : null);\r\n\t\t\t\t}\r\n\t\t\t\tif (obj.emit(type, mouseEvent) && mouseEvent.isStopped) {\r\n\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\twhile (item) {\r\n\t\t\tif (call(item))\r\n\t\t\t\treturn true;\r\n\t\t\titem = item.getParent();\r\n\t\t}\r\n\t\tif (call(view))\r\n\t\t\treturn true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn {\r\n\t\t_handleEvent: function(type, point, event) {\r\n\t\t\tif (!this._eventCounters[type])\r\n\t\t\t\treturn;\r\n\t\t\tvar project = this._project,\r\n\t\t\t\thit = project.hitTest(point, {\r\n\t\t\t\t\ttolerance: 0,\r\n\t\t\t\t\tfill: true,\r\n\t\t\t\t\tstroke: true\r\n\t\t\t\t}),\r\n\t\t\t\titem = hit && hit.item,\r\n\t\t\t\tstopped = false;\r\n\t\t\tswitch (type) {\r\n\t\t\tcase 'mousedown':\r\n\t\t\t\tstopped = callEvent(this, type, event, point, item);\r\n\t\t\t\tdblClick = lastItem == item && (Date.now() - clickTime < 300);\r\n\t\t\t\tdownItem = lastItem = item;\r\n\t\t\t\tdownPoint = lastPoint = overPoint = point;\r\n\t\t\t\tdragItem = !stopped && item;\r\n\t\t\t\twhile (dragItem && !dragItem.responds('mousedrag'))\r\n\t\t\t\t\tdragItem = dragItem._parent;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'mouseup':\r\n\t\t\t\tstopped = callEvent(this, type, event, point, item, downPoint);\r\n\t\t\t\tif (dragItem) {\r\n\t\t\t\t\tif (lastPoint && !lastPoint.equals(point))\r\n\t\t\t\t\t\tcallEvent(this, 'mousedrag', event, point, dragItem,\r\n\t\t\t\t\t\t\t\tlastPoint);\r\n\t\t\t\t\tif (item !== dragItem) {\r\n\t\t\t\t\t\toverPoint = point;\r\n\t\t\t\t\t\tcallEvent(this, 'mousemove', event, point, item,\r\n\t\t\t\t\t\t\t\toverPoint);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!stopped && item && item === downItem) {\r\n\t\t\t\t\tclickTime = Date.now();\r\n\t\t\t\t\tcallEvent(this, dblClick && downItem.responds('doubleclick')\r\n\t\t\t\t\t\t\t? 'doubleclick' : 'click', event, downPoint, item);\r\n\t\t\t\t\tdblClick = false;\r\n\t\t\t\t}\r\n\t\t\t\tdownItem = dragItem = null;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'mousemove':\r\n\t\t\t\tif (dragItem)\r\n\t\t\t\t\tstopped = callEvent(this, 'mousedrag', event, point,\r\n\t\t\t\t\t\t\tdragItem, lastPoint);\r\n\t\t\t\tif (!stopped) {\r\n\t\t\t\t\tif (item !== overItem)\r\n\t\t\t\t\t\toverPoint = point;\r\n\t\t\t\t\tstopped = callEvent(this, type, event, point, item,\r\n\t\t\t\t\t\t\toverPoint);\r\n\t\t\t\t}\r\n\t\t\t\tlastPoint = overPoint = point;\r\n\t\t\t\tif (item !== overItem) {\r\n\t\t\t\t\tcallEvent(this, 'mouseleave', event, point, overItem);\r\n\t\t\t\t\toverItem = item;\r\n\t\t\t\t\tcallEvent(this, 'mouseenter', event, point, item);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\treturn stopped;\r\n\t\t}\r\n\t};\r\n});\r\n\r\nvar Event = Base.extend({\r\n\t_class: 'Event',\r\n\r\n\tinitialize: function Event(event) {\r\n\t\tthis.event = event;\r\n\t},\r\n\r\n\tisPrevented: false,\r\n\tisStopped: false,\r\n\r\n\tpreventDefault: function() {\r\n\t\tthis.isPrevented = true;\r\n\t\tthis.event.preventDefault();\r\n\t},\r\n\r\n\tstopPropagation: function() {\r\n\t\tthis.isStopped = true;\r\n\t\tthis.event.stopPropagation();\r\n\t},\r\n\r\n\tstop: function() {\r\n\t\tthis.stopPropagation();\r\n\t\tthis.preventDefault();\r\n\t},\r\n\r\n\tgetModifiers: function() {\r\n\t\treturn Key.modifiers;\r\n\t}\r\n});\r\n\r\nvar KeyEvent = Event.extend({\r\n\t_class: 'KeyEvent',\r\n\r\n\tinitialize: function KeyEvent(down, key, character, event) {\r\n\t\tEvent.call(this, event);\r\n\t\tthis.type = down ? 'keydown' : 'keyup';\r\n\t\tthis.key = key;\r\n\t\tthis.character = character;\r\n\t},\r\n\r\n\ttoString: function() {\r\n\t\treturn \"{ type: '\" + this.type\r\n\t\t\t\t+ \"', key: '\" + this.key\r\n\t\t\t\t+ \"', character: '\" + this.character\r\n\t\t\t\t+ \"', modifiers: \" + this.getModifiers()\r\n\t\t\t\t+ \" }\";\r\n\t}\r\n});\r\n\r\nvar Key = new function() {\r\n\r\n\tvar specialKeys = {\r\n\t\t8: 'backspace',\r\n\t\t9: 'tab',\r\n\t\t13: 'enter',\r\n\t\t16: 'shift',\r\n\t\t17: 'control',\r\n\t\t18: 'option',\r\n\t\t19: 'pause',\r\n\t\t20: 'caps-lock',\r\n\t\t27: 'escape',\r\n\t\t32: 'space',\r\n\t\t35: 'end',\r\n\t\t36: 'home',\r\n\t\t37: 'left',\r\n\t\t38: 'up',\r\n\t\t39: 'right',\r\n\t\t40: 'down',\r\n\t\t46: 'delete',\r\n\t\t91: 'command',\r\n\t\t93: 'command',\r\n\t\t224: 'command'\r\n\t},\r\n\r\n\tspecialChars = {\r\n\t\t9: true,\r\n\t\t13: true,\r\n\t\t32: true\r\n\t},\r\n\r\n\tmodifiers = new Base({\r\n\t\tshift: false,\r\n\t\tcontrol: false,\r\n\t\toption: false,\r\n\t\tcommand: false,\r\n\t\tcapsLock: false,\r\n\t\tspace: false\r\n\t}),\r\n\r\n\tcharCodeMap = {},\r\n\tkeyMap = {},\r\n\tcommandFixMap,\r\n\tdownCode;\r\n\r\n\tfunction handleKey(down, keyCode, charCode, event) {\r\n\t\tvar character = charCode ? String.fromCharCode(charCode) : '',\r\n\t\t\tspecialKey = specialKeys[keyCode],\r\n\t\t\tkey = specialKey || character.toLowerCase(),\r\n\t\t\ttype = down ? 'keydown' : 'keyup',\r\n\t\t\tview = View._focused,\r\n\t\t\tscope = view && view.isVisible() && view._scope,\r\n\t\t\ttool = scope && scope.tool,\r\n\t\t\tname;\r\n\t\tkeyMap[key] = down;\r\n\t\tif (down) {\r\n\t\t\tcharCodeMap[keyCode] = charCode;\r\n\t\t} else {\r\n\t\t\tdelete charCodeMap[keyCode];\r\n\t\t}\r\n\t\tif (specialKey && (name = Base.camelize(specialKey)) in modifiers) {\r\n\t\t\tmodifiers[name] = down;\r\n\t\t\tvar browser = paper.browser;\r\n\t\t\tif (name === 'command' && browser && browser.mac) {\r\n\t\t\t\tif (down) {\r\n\t\t\t\t\tcommandFixMap = {};\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfor (var code in commandFixMap) {\r\n\t\t\t\t\t\tif (code in charCodeMap)\r\n\t\t\t\t\t\t\thandleKey(false, code, commandFixMap[code], event);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcommandFixMap = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (down && commandFixMap) {\r\n\t\t\tcommandFixMap[keyCode] = charCode;\r\n\t\t}\r\n\t\tif (tool && tool.responds(type)) {\r\n\t\t\tpaper = scope;\r\n\t\t\ttool.emit(type, new KeyEvent(down, key, character, event));\r\n\t\t\tif (view)\r\n\t\t\t\tview.update();\r\n\t\t}\r\n\t}\r\n\r\n\tDomEvent.add(document, {\r\n\t\tkeydown: function(event) {\r\n\t\t\tvar code = event.which || event.keyCode;\r\n\t\t\tif (code in specialKeys || modifiers.command) {\r\n\t\t\t\thandleKey(true, code,\r\n\t\t\t\t\t\tcode in specialChars || modifiers.command ? code : 0,\r\n\t\t\t\t\t\tevent);\r\n\t\t\t} else {\r\n\t\t\t\tdownCode = code;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tkeypress: function(event) {\r\n\t\t\tif (downCode != null) {\r\n\t\t\t\thandleKey(true, downCode, event.which || event.keyCode, event);\r\n\t\t\t\tdownCode = null;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tkeyup: function(event) {\r\n\t\t\tvar code = event.which || event.keyCode;\r\n\t\t\tif (code in charCodeMap)\r\n\t\t\t\thandleKey(false, code, charCodeMap[code], event);\r\n\t\t}\r\n\t});\r\n\r\n\tDomEvent.add(window, {\r\n\t\tblur: function(event) {\r\n\t\t\tfor (var code in charCodeMap)\r\n\t\t\t\thandleKey(false, code, charCodeMap[code], event);\r\n\t\t}\r\n\t});\r\n\r\n\treturn {\r\n\t\tmodifiers: modifiers,\r\n\r\n\t\tisDown: function(key) {\r\n\t\t\treturn !!keyMap[key];\r\n\t\t}\r\n\t};\r\n};\r\n\r\nvar MouseEvent = Event.extend({\r\n\t_class: 'MouseEvent',\r\n\r\n\tinitialize: function MouseEvent(type, event, point, target, delta) {\r\n\t\tEvent.call(this, event);\r\n\t\tthis.type = type;\r\n\t\tthis.point = point;\r\n\t\tthis.target = target;\r\n\t\tthis.delta = delta;\r\n\t},\r\n\r\n\ttoString: function() {\r\n\t\treturn \"{ type: '\" + this.type\r\n\t\t\t\t+ \"', point: \" + this.point\r\n\t\t\t\t+ ', target: ' + this.target\r\n\t\t\t\t+ (this.delta ? ', delta: ' + this.delta : '')\r\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\r\n\t\t\t\t+ ' }';\r\n\t}\r\n});\r\n\r\nvar ToolEvent = Event.extend({\r\n\t_class: 'ToolEvent',\r\n\t_item: null,\r\n\r\n\tinitialize: function ToolEvent(tool, type, event) {\r\n\t\tthis.tool = tool;\r\n\t\tthis.type = type;\r\n\t\tthis.event = event;\r\n\t},\r\n\r\n\t_choosePoint: function(point, toolPoint) {\r\n\t\treturn point ? point : toolPoint ? toolPoint.clone() : null;\r\n\t},\r\n\r\n\tgetPoint: function() {\r\n\t\treturn this._choosePoint(this._point, this.tool._point);\r\n\t},\r\n\r\n\tsetPoint: function(point) {\r\n\t\tthis._point = point;\r\n\t},\r\n\r\n\tgetLastPoint: function() {\r\n\t\treturn this._choosePoint(this._lastPoint, this.tool._lastPoint);\r\n\t},\r\n\r\n\tsetLastPoint: function(lastPoint) {\r\n\t\tthis._lastPoint = lastPoint;\r\n\t},\r\n\r\n\tgetDownPoint: function() {\r\n\t\treturn this._choosePoint(this._downPoint, this.tool._downPoint);\r\n\t},\r\n\r\n\tsetDownPoint: function(downPoint) {\r\n\t\tthis._downPoint = downPoint;\r\n\t},\r\n\r\n\tgetMiddlePoint: function() {\r\n\t\tif (!this._middlePoint && this.tool._lastPoint) {\r\n\t\t\treturn this.tool._point.add(this.tool._lastPoint).divide(2);\r\n\t\t}\r\n\t\treturn this._middlePoint;\r\n\t},\r\n\r\n\tsetMiddlePoint: function(middlePoint) {\r\n\t\tthis._middlePoint = middlePoint;\r\n\t},\r\n\r\n\tgetDelta: function() {\r\n\t\treturn !this._delta && this.tool._lastPoint\r\n\t\t\t\t? this.tool._point.subtract(this.tool._lastPoint)\r\n\t\t\t\t: this._delta;\r\n\t},\r\n\r\n\tsetDelta: function(delta) {\r\n\t\tthis._delta = delta;\r\n\t},\r\n\r\n\tgetCount: function() {\r\n\t\treturn /^mouse(down|up)$/.test(this.type)\r\n\t\t\t\t? this.tool._downCount\r\n\t\t\t\t: this.tool._count;\r\n\t},\r\n\r\n\tsetCount: function(count) {\r\n\t\tthis.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']\r\n\t\t\t= count;\r\n\t},\r\n\r\n\tgetItem: function() {\r\n\t\tif (!this._item) {\r\n\t\t\tvar result = this.tool._scope.project.hitTest(this.getPoint());\r\n\t\t\tif (result) {\r\n\t\t\t\tvar item = result.item,\r\n\t\t\t\t\tparent = item._parent;\r\n\t\t\t\twhile (/^(Group|CompoundPath)$/.test(parent._class)) {\r\n\t\t\t\t\titem = parent;\r\n\t\t\t\t\tparent = parent._parent;\r\n\t\t\t\t}\r\n\t\t\t\tthis._item = item;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this._item;\r\n\t},\r\n\r\n\tsetItem: function(item) {\r\n\t\tthis._item = item;\r\n\t},\r\n\r\n\ttoString: function() {\r\n\t\treturn '{ type: ' + this.type\r\n\t\t\t\t+ ', point: ' + this.getPoint()\r\n\t\t\t\t+ ', count: ' + this.getCount()\r\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\r\n\t\t\t\t+ ' }';\r\n\t}\r\n});\r\n\r\nvar Tool = PaperScopeItem.extend({\r\n\t_class: 'Tool',\r\n\t_list: 'tools',\r\n\t_reference: 'tool',\r\n\t_events: [ 'onActivate', 'onDeactivate', 'onEditOptions',\r\n\t\t\t'onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',\r\n\t\t\t'onKeyDown', 'onKeyUp' ],\r\n\r\n\tinitialize: function Tool(props) {\r\n\t\tPaperScopeItem.call(this);\r\n\t\tthis._firstMove = true;\r\n\t\tthis._count = 0;\r\n\t\tthis._downCount = 0;\r\n\t\tthis._set(props);\r\n\t},\r\n\r\n\tgetMinDistance: function() {\r\n\t\treturn this._minDistance;\r\n\t},\r\n\r\n\tsetMinDistance: function(minDistance) {\r\n\t\tthis._minDistance = minDistance;\r\n\t\tif (minDistance != null && this._maxDistance != null\r\n\t\t\t\t&& minDistance > this._maxDistance) {\r\n\t\t\tthis._maxDistance = minDistance;\r\n\t\t}\r\n\t},\r\n\r\n\tgetMaxDistance: function() {\r\n\t\treturn this._maxDistance;\r\n\t},\r\n\r\n\tsetMaxDistance: function(maxDistance) {\r\n\t\tthis._maxDistance = maxDistance;\r\n\t\tif (this._minDistance != null && maxDistance != null\r\n\t\t\t\t&& maxDistance < this._minDistance) {\r\n\t\t\tthis._minDistance = maxDistance;\r\n\t\t}\r\n\t},\r\n\r\n\tgetFixedDistance: function() {\r\n\t\treturn this._minDistance == this._maxDistance\r\n\t\t\t? this._minDistance : null;\r\n\t},\r\n\r\n\tsetFixedDistance: function(distance) {\r\n\t\tthis._minDistance = this._maxDistance = distance;\r\n\t},\r\n\r\n\t_updateEvent: function(type, point, minDistance, maxDistance, start,\r\n\t\t\tneedsChange, matchMaxDistance) {\r\n\t\tif (!start) {\r\n\t\t\tif (minDistance != null || maxDistance != null) {\r\n\t\t\t\tvar minDist = minDistance != null ? minDistance : 0,\r\n\t\t\t\t\tvector = point.subtract(this._point),\r\n\t\t\t\t\tdistance = vector.getLength();\r\n\t\t\t\tif (distance < minDist)\r\n\t\t\t\t\treturn false;\r\n\t\t\t\tif (maxDistance != null && maxDistance != 0) {\r\n\t\t\t\t\tif (distance > maxDistance) {\r\n\t\t\t\t\t\tpoint = this._point.add(vector.normalize(maxDistance));\r\n\t\t\t\t\t} else if (matchMaxDistance) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (needsChange && point.equals(this._point))\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\tthis._lastPoint = start && type == 'mousemove' ? point : this._point;\r\n\t\tthis._point = point;\r\n\t\tswitch (type) {\r\n\t\tcase 'mousedown':\r\n\t\t\tthis._lastPoint = this._downPoint;\r\n\t\t\tthis._downPoint = this._point;\r\n\t\t\tthis._downCount++;\r\n\t\t\tbreak;\r\n\t\tcase 'mouseup':\r\n\t\t\tthis._lastPoint = this._downPoint;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tthis._count = start ? 0 : this._count + 1;\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_fireEvent: function(type, event) {\r\n\t\tvar sets = paper.project._removeSets;\r\n\t\tif (sets) {\r\n\t\t\tif (type === 'mouseup')\r\n\t\t\t\tsets.mousedrag = null;\r\n\t\t\tvar set = sets[type];\r\n\t\t\tif (set) {\r\n\t\t\t\tfor (var id in set) {\r\n\t\t\t\t\tvar item = set[id];\r\n\t\t\t\t\tfor (var key in sets) {\r\n\t\t\t\t\t\tvar other = sets[key];\r\n\t\t\t\t\t\tif (other && other != set)\r\n\t\t\t\t\t\t\tdelete other[item._id];\r\n\t\t\t\t\t}\r\n\t\t\t\t\titem.remove();\r\n\t\t\t\t}\r\n\t\t\t\tsets[type] = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.responds(type)\r\n\t\t\t\t&& this.emit(type, new ToolEvent(this, type, event));\r\n\t},\r\n\r\n\t_handleEvent: function(type, point, event) {\r\n\t\tpaper = this._scope;\r\n\t\tvar called = false;\r\n\t\tswitch (type) {\r\n\t\tcase 'mousedown':\r\n\t\t\tthis._updateEvent(type, point, null, null, true, false, false);\r\n\t\t\tcalled = this._fireEvent(type, event);\r\n\t\t\tbreak;\r\n\t\tcase 'mousedrag':\r\n\t\t\tvar needsChange = false,\r\n\t\t\t\tmatchMaxDistance = false;\r\n\t\t\twhile (this._updateEvent(type, point, this.minDistance,\r\n\t\t\t\t\tthis.maxDistance, false, needsChange, matchMaxDistance)) {\r\n\t\t\t\tcalled = this._fireEvent(type, event) || called;\r\n\t\t\t\tneedsChange = true;\r\n\t\t\t\tmatchMaxDistance = true;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 'mouseup':\r\n\t\t\tif (!point.equals(this._point)\r\n\t\t\t\t\t&& this._updateEvent('mousedrag', point, this.minDistance,\r\n\t\t\t\t\t\t\tthis.maxDistance, false, false, false)) {\r\n\t\t\t\tcalled = this._fireEvent('mousedrag', event);\r\n\t\t\t}\r\n\t\t\tthis._updateEvent(type, point, null, this.maxDistance, false,\r\n\t\t\t\t\tfalse, false);\r\n\t\t\tcalled = this._fireEvent(type, event) || called;\r\n\t\t\tthis._updateEvent(type, point, null, null, true, false, false);\r\n\t\t\tthis._firstMove = true;\r\n\t\t\tbreak;\r\n\t\tcase 'mousemove':\r\n\t\t\twhile (this._updateEvent(type, point, this.minDistance,\r\n\t\t\t\t\tthis.maxDistance, this._firstMove, true, false)) {\r\n\t\t\t\tcalled = this._fireEvent(type, event) || called;\r\n\t\t\t\tthis._firstMove = false;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif (called)\r\n\t\t\tevent.preventDefault();\r\n\t\treturn called;\r\n\t}\r\n\r\n});\r\n\r\nvar Http = {\r\n\trequest: function(method, url, callback, async) {\r\n\t\tasync = (async === undefined) ? true : async;\r\n\t\tvar xhr = new (window.ActiveXObject || XMLHttpRequest)(\r\n\t\t\t\t\t'Microsoft.XMLHTTP');\r\n\t\txhr.open(method.toUpperCase(), url, async);\r\n\t\tif ('overrideMimeType' in xhr)\r\n\t\t\txhr.overrideMimeType('text/plain');\r\n\t\txhr.onreadystatechange = function() {\r\n\t\t\tif (xhr.readyState === 4) {\r\n\t\t\t\tvar status = xhr.status;\r\n\t\t\t\tif (status === 0 || status === 200) {\r\n\t\t\t\t\tcallback.call(xhr, xhr.responseText);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error('Could not load ' + url + ' (Error '\r\n\t\t\t\t\t\t\t+ status + ')');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn xhr.send(null);\r\n\t}\r\n};\r\n\r\nvar CanvasProvider = {\r\n\tcanvases: [],\r\n\r\n\tgetCanvas: function(width, height) {\r\n\t\tvar canvas,\r\n\t\t\tclear = true;\r\n\t\tif (typeof width === 'object') {\r\n\t\t\theight = width.height;\r\n\t\t\twidth = width.width;\r\n\t\t}\r\n\t\tif (this.canvases.length) {\r\n\t\t\tcanvas = this.canvases.pop();\r\n\t\t} else {\r\n\t\t\tcanvas = document.createElement('canvas');\r\n\t\t}\r\n\t\tvar ctx = canvas.getContext('2d');\r\n\t\tif (canvas.width === width && canvas.height === height) {\r\n\t\t\tif (clear)\r\n\t\t\t\tctx.clearRect(0, 0, width + 1, height + 1);\r\n\t\t} else {\r\n\t\t\tcanvas.width = width;\r\n\t\t\tcanvas.height = height;\r\n\t\t}\r\n\t\tctx.save();\r\n\t\treturn canvas;\r\n\t},\r\n\r\n\tgetContext: function(width, height) {\r\n\t\treturn this.getCanvas(width, height).getContext('2d');\r\n\t},\r\n\r\n\trelease: function(obj) {\r\n\t\tvar canvas = obj.canvas ? obj.canvas : obj;\r\n\t\tcanvas.getContext('2d').restore();\r\n\t\tthis.canvases.push(canvas);\r\n\t}\r\n};\r\n\r\nvar BlendMode = new function() {\r\n\tvar min = Math.min,\r\n\t\tmax = Math.max,\r\n\t\tabs = Math.abs,\r\n\t\tsr, sg, sb, sa,\r\n\t\tbr, bg, bb, ba,\r\n\t\tdr, dg, db;\r\n\r\n\tfunction getLum(r, g, b) {\r\n\t\treturn 0.2989 * r + 0.587 * g + 0.114 * b;\r\n\t}\r\n\r\n\tfunction setLum(r, g, b, l) {\r\n\t\tvar d = l - getLum(r, g, b);\r\n\t\tdr = r + d;\r\n\t\tdg = g + d;\r\n\t\tdb = b + d;\r\n\t\tvar l = getLum(dr, dg, db),\r\n\t\t\tmn = min(dr, dg, db),\r\n\t\t\tmx = max(dr, dg, db);\r\n\t\tif (mn < 0) {\r\n\t\t\tvar lmn = l - mn;\r\n\t\t\tdr = l + (dr - l) * l / lmn;\r\n\t\t\tdg = l + (dg - l) * l / lmn;\r\n\t\t\tdb = l + (db - l) * l / lmn;\r\n\t\t}\r\n\t\tif (mx > 255) {\r\n\t\t\tvar ln = 255 - l,\r\n\t\t\t\tmxl = mx - l;\r\n\t\t\tdr = l + (dr - l) * ln / mxl;\r\n\t\t\tdg = l + (dg - l) * ln / mxl;\r\n\t\t\tdb = l + (db - l) * ln / mxl;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getSat(r, g, b) {\r\n\t\treturn max(r, g, b) - min(r, g, b);\r\n\t}\r\n\r\n\tfunction setSat(r, g, b, s) {\r\n\t\tvar col = [r, g, b],\r\n\t\t\tmx = max(r, g, b),\r\n\t\t\tmn = min(r, g, b),\r\n\t\t\tmd;\r\n\t\tmn = mn === r ? 0 : mn === g ? 1 : 2;\r\n\t\tmx = mx === r ? 0 : mx === g ? 1 : 2;\r\n\t\tmd = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;\r\n\t\tif (col[mx] > col[mn]) {\r\n\t\t\tcol[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);\r\n\t\t\tcol[mx] = s;\r\n\t\t} else {\r\n\t\t\tcol[md] = col[mx] = 0;\r\n\t\t}\r\n\t\tcol[mn] = 0;\r\n\t\tdr = col[0];\r\n\t\tdg = col[1];\r\n\t\tdb = col[2];\r\n\t}\r\n\r\n\tvar modes = {\r\n\t\tmultiply: function() {\r\n\t\t\tdr = br * sr / 255;\r\n\t\t\tdg = bg * sg / 255;\r\n\t\t\tdb = bb * sb / 255;\r\n\t\t},\r\n\r\n\t\tscreen: function() {\r\n\t\t\tdr = br + sr - (br * sr / 255);\r\n\t\t\tdg = bg + sg - (bg * sg / 255);\r\n\t\t\tdb = bb + sb - (bb * sb / 255);\r\n\t\t},\r\n\r\n\t\toverlay: function() {\r\n\t\t\tdr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;\r\n\t\t\tdg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;\r\n\t\t\tdb = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;\r\n\t\t},\r\n\r\n\t\t'soft-light': function() {\r\n\t\t\tvar t = sr * br / 255;\r\n\t\t\tdr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;\r\n\t\t\tt = sg * bg / 255;\r\n\t\t\tdg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;\r\n\t\t\tt = sb * bb / 255;\r\n\t\t\tdb = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;\r\n\t\t},\r\n\r\n\t\t'hard-light': function() {\r\n\t\t\tdr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;\r\n\t\t\tdg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;\r\n\t\t\tdb = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;\r\n\t\t},\r\n\r\n\t\t'color-dodge': function() {\r\n\t\t\tdr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));\r\n\t\t\tdg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));\r\n\t\t\tdb = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));\r\n\t\t},\r\n\r\n\t\t'color-burn': function() {\r\n\t\t\tdr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);\r\n\t\t\tdg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);\r\n\t\t\tdb = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);\r\n\t\t},\r\n\r\n\t\tdarken: function() {\r\n\t\t\tdr = br < sr ? br : sr;\r\n\t\t\tdg = bg < sg ? bg : sg;\r\n\t\t\tdb = bb < sb ? bb : sb;\r\n\t\t},\r\n\r\n\t\tlighten: function() {\r\n\t\t\tdr = br > sr ? br : sr;\r\n\t\t\tdg = bg > sg ? bg : sg;\r\n\t\t\tdb = bb > sb ? bb : sb;\r\n\t\t},\r\n\r\n\t\tdifference: function() {\r\n\t\t\tdr = br - sr;\r\n\t\t\tif (dr < 0)\r\n\t\t\t\tdr = -dr;\r\n\t\t\tdg = bg - sg;\r\n\t\t\tif (dg < 0)\r\n\t\t\t\tdg = -dg;\r\n\t\t\tdb = bb - sb;\r\n\t\t\tif (db < 0)\r\n\t\t\t\tdb = -db;\r\n\t\t},\r\n\r\n\t\texclusion: function() {\r\n\t\t\tdr = br + sr * (255 - br - br) / 255;\r\n\t\t\tdg = bg + sg * (255 - bg - bg) / 255;\r\n\t\t\tdb = bb + sb * (255 - bb - bb) / 255;\r\n\t\t},\r\n\r\n\t\thue: function() {\r\n\t\t\tsetSat(sr, sg, sb, getSat(br, bg, bb));\r\n\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\r\n\t\t},\r\n\r\n\t\tsaturation: function() {\r\n\t\t\tsetSat(br, bg, bb, getSat(sr, sg, sb));\r\n\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\r\n\t\t},\r\n\r\n\t\tluminosity: function() {\r\n\t\t\tsetLum(br, bg, bb, getLum(sr, sg, sb));\r\n\t\t},\r\n\r\n\t\tcolor: function() {\r\n\t\t\tsetLum(sr, sg, sb, getLum(br, bg, bb));\r\n\t\t},\r\n\r\n\t\tadd: function() {\r\n\t\t\tdr = min(br + sr, 255);\r\n\t\t\tdg = min(bg + sg, 255);\r\n\t\t\tdb = min(bb + sb, 255);\r\n\t\t},\r\n\r\n\t\tsubtract: function() {\r\n\t\t\tdr = max(br - sr, 0);\r\n\t\t\tdg = max(bg - sg, 0);\r\n\t\t\tdb = max(bb - sb, 0);\r\n\t\t},\r\n\r\n\t\taverage: function() {\r\n\t\t\tdr = (br + sr) / 2;\r\n\t\t\tdg = (bg + sg) / 2;\r\n\t\t\tdb = (bb + sb) / 2;\r\n\t\t},\r\n\r\n\t\tnegation: function() {\r\n\t\t\tdr = 255 - abs(255 - sr - br);\r\n\t\t\tdg = 255 - abs(255 - sg - bg);\r\n\t\t\tdb = 255 - abs(255 - sb - bb);\r\n\t\t}\r\n\t};\r\n\r\n\tvar nativeModes = this.nativeModes = Base.each([\r\n\t\t'source-over', 'source-in', 'source-out', 'source-atop',\r\n\t\t'destination-over', 'destination-in', 'destination-out',\r\n\t\t'destination-atop', 'lighter', 'darker', 'copy', 'xor'\r\n\t], function(mode) {\r\n\t\tthis[mode] = true;\r\n\t}, {});\r\n\r\n\tvar ctx = CanvasProvider.getContext(1, 1);\r\n\tBase.each(modes, function(func, mode) {\r\n\t\tvar darken = mode === 'darken',\r\n\t\t\tok = false;\r\n\t\tctx.save();\r\n\t\ttry {\r\n\t\t\tctx.fillStyle = darken ? '#300' : '#a00';\r\n\t\t\tctx.fillRect(0, 0, 1, 1);\r\n\t\t\tctx.globalCompositeOperation = mode;\r\n\t\t\tif (ctx.globalCompositeOperation === mode) {\r\n\t\t\t\tctx.fillStyle = darken ? '#a00' : '#300';\r\n\t\t\t\tctx.fillRect(0, 0, 1, 1);\r\n\t\t\t\tok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;\r\n\t\t\t}\r\n\t\t} catch (e) {}\r\n\t\tctx.restore();\r\n\t\tnativeModes[mode] = ok;\r\n\t});\r\n\tCanvasProvider.release(ctx);\r\n\r\n\tthis.process = function(mode, srcContext, dstContext, alpha, offset) {\r\n\t\tvar srcCanvas = srcContext.canvas,\r\n\t\t\tnormal = mode === 'normal';\r\n\t\tif (normal || nativeModes[mode]) {\r\n\t\t\tdstContext.save();\r\n\t\t\tdstContext.setTransform(1, 0, 0, 1, 0, 0);\r\n\t\t\tdstContext.globalAlpha = alpha;\r\n\t\t\tif (!normal)\r\n\t\t\t\tdstContext.globalCompositeOperation = mode;\r\n\t\t\tdstContext.drawImage(srcCanvas, offset.x, offset.y);\r\n\t\t\tdstContext.restore();\r\n\t\t} else {\r\n\t\t\tvar process = modes[mode];\r\n\t\t\tif (!process)\r\n\t\t\t\treturn;\r\n\t\t\tvar dstData = dstContext.getImageData(offset.x, offset.y,\r\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height),\r\n\t\t\t\tdst = dstData.data,\r\n\t\t\t\tsrc = srcContext.getImageData(0, 0,\r\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height).data;\r\n\t\t\tfor (var i = 0, l = dst.length; i < l; i += 4) {\r\n\t\t\t\tsr = src[i];\r\n\t\t\t\tbr = dst[i];\r\n\t\t\t\tsg = src[i + 1];\r\n\t\t\t\tbg = dst[i + 1];\r\n\t\t\t\tsb = src[i + 2];\r\n\t\t\t\tbb = dst[i + 2];\r\n\t\t\t\tsa = src[i + 3];\r\n\t\t\t\tba = dst[i + 3];\r\n\t\t\t\tprocess();\r\n\t\t\t\tvar a1 = sa * alpha / 255,\r\n\t\t\t\t\ta2 = 1 - a1;\r\n\t\t\t\tdst[i] = a1 * dr + a2 * br;\r\n\t\t\t\tdst[i + 1] = a1 * dg + a2 * bg;\r\n\t\t\t\tdst[i + 2] = a1 * db + a2 * bb;\r\n\t\t\t\tdst[i + 3] = sa * alpha + a2 * ba;\r\n\t\t\t}\r\n\t\t\tdstContext.putImageData(dstData, offset.x, offset.y);\r\n\t\t}\r\n\t};\r\n};\r\n\r\nvar SVGStyles = Base.each({\r\n\tfillColor: ['fill', 'color'],\r\n\tstrokeColor: ['stroke', 'color'],\r\n\tstrokeWidth: ['stroke-width', 'number'],\r\n\tstrokeCap: ['stroke-linecap', 'string'],\r\n\tstrokeJoin: ['stroke-linejoin', 'string'],\r\n\tstrokeScaling: ['vector-effect', 'lookup', {\r\n\t\ttrue: 'none',\r\n\t\tfalse: 'non-scaling-stroke'\r\n\t}, function(item, value) {\r\n\t\treturn !value\r\n\t\t\t\t&& (item instanceof PathItem\r\n\t\t\t\t\t|| item instanceof Shape\r\n\t\t\t\t\t|| item instanceof TextItem);\r\n\t}],\r\n\tmiterLimit: ['stroke-miterlimit', 'number'],\r\n\tdashArray: ['stroke-dasharray', 'array'],\r\n\tdashOffset: ['stroke-dashoffset', 'number'],\r\n\tfontFamily: ['font-family', 'string'],\r\n\tfontWeight: ['font-weight', 'string'],\r\n\tfontSize: ['font-size', 'number'],\r\n\tjustification: ['text-anchor', 'lookup', {\r\n\t\tleft: 'start',\r\n\t\tcenter: 'middle',\r\n\t\tright: 'end'\r\n\t}],\r\n\topacity: ['opacity', 'number'],\r\n\tblendMode: ['mix-blend-mode', 'string']\r\n}, function(entry, key) {\r\n\tvar part = Base.capitalize(key),\r\n\t\tlookup = entry[2];\r\n\tthis[key] = {\r\n\t\ttype: entry[1],\r\n\t\tproperty: key,\r\n\t\tattribute: entry[0],\r\n\t\ttoSVG: lookup,\r\n\t\tfromSVG: lookup && Base.each(lookup, function(value, name) {\r\n\t\t\tthis[value] = name;\r\n\t\t}, {}),\r\n\t\texportFilter: entry[3],\r\n\t\tget: 'get' + part,\r\n\t\tset: 'set' + part\r\n\t};\r\n}, {});\r\n\r\nvar SVGNamespaces = {\r\n\thref: 'http://www.w3.org/1999/xlink',\r\n\txlink: 'http://www.w3.org/2000/xmlns'\r\n};\r\n\r\nnew function() {\r\n\tvar formatter;\r\n\r\n\tfunction setAttributes(node, attrs) {\r\n\t\tfor (var key in attrs) {\r\n\t\t\tvar val = attrs[key],\r\n\t\t\t\tnamespace = SVGNamespaces[key];\r\n\t\t\tif (typeof val === 'number')\r\n\t\t\t\tval = formatter.number(val);\r\n\t\t\tif (namespace) {\r\n\t\t\t\tnode.setAttributeNS(namespace, key, val);\r\n\t\t\t} else {\r\n\t\t\t\tnode.setAttribute(key, val);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn node;\r\n\t}\r\n\r\n\tfunction createElement(tag, attrs) {\r\n\t\treturn setAttributes(\r\n\t\t\tdocument.createElementNS('http://www.w3.org/2000/svg', tag), attrs);\r\n\t}\r\n\r\n\tfunction getTransform(matrix, coordinates, center) {\r\n\t\tvar attrs = new Base(),\r\n\t\t\ttrans = matrix.getTranslation();\r\n\t\tif (coordinates) {\r\n\t\t\tmatrix = matrix.shiftless();\r\n\t\t\tvar point = matrix._inverseTransform(trans);\r\n\t\t\tattrs[center ? 'cx' : 'x'] = point.x;\r\n\t\t\tattrs[center ? 'cy' : 'y'] = point.y;\r\n\t\t\ttrans = null;\r\n\t\t}\r\n\t\tif (!matrix.isIdentity()) {\r\n\t\t\tvar decomposed = matrix.decompose();\r\n\t\t\tif (decomposed && !decomposed.shearing) {\r\n\t\t\t\tvar parts = [],\r\n\t\t\t\t\tangle = decomposed.rotation,\r\n\t\t\t\t\tscale = decomposed.scaling;\r\n\t\t\t\tif (trans && !trans.isZero())\r\n\t\t\t\t\tparts.push('translate(' + formatter.point(trans) + ')');\r\n\t\t\t\tif (!Numerical.isZero(scale.x - 1)\r\n\t\t\t\t\t\t|| !Numerical.isZero(scale.y - 1))\r\n\t\t\t\t\tparts.push('scale(' + formatter.point(scale) +')');\r\n\t\t\t\tif (angle)\r\n\t\t\t\t\tparts.push('rotate(' + formatter.number(angle) + ')');\r\n\t\t\t\tattrs.transform = parts.join(' ');\r\n\t\t\t} else {\r\n\t\t\t\tattrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn attrs;\r\n\t}\r\n\r\n\tfunction exportGroup(item, options) {\r\n\t\tvar attrs = getTransform(item._matrix),\r\n\t\t\tchildren = item._children;\r\n\t\tvar node = createElement('g', attrs);\r\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\r\n\t\t\tvar child = children[i];\r\n\t\t\tvar childNode = exportSVG(child, options);\r\n\t\t\tif (childNode) {\r\n\t\t\t\tif (child.isClipMask()) {\r\n\t\t\t\t\tvar clip = createElement('clipPath');\r\n\t\t\t\t\tclip.appendChild(childNode);\r\n\t\t\t\t\tsetDefinition(child, clip, 'clip');\r\n\t\t\t\t\tsetAttributes(node, {\r\n\t\t\t\t\t\t'clip-path': 'url(#' + clip.id + ')'\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnode.appendChild(childNode);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn node;\r\n\t}\r\n\r\n\tfunction exportRaster(item, options) {\r\n\t\tvar attrs = getTransform(item._matrix, true),\r\n\t\t\tsize = item.getSize(),\r\n\t\t\timage = item.getImage();\r\n\t\tattrs.x -= size.width / 2;\r\n\t\tattrs.y -= size.height / 2;\r\n\t\tattrs.width = size.width;\r\n\t\tattrs.height = size.height;\r\n\t\tattrs.href = options.embedImages === false && image && image.src\r\n\t\t\t\t|| item.toDataURL();\r\n\t\treturn createElement('image', attrs);\r\n\t}\r\n\r\n\tfunction exportPath(item, options) {\r\n\t\tvar matchShapes = options.matchShapes;\r\n\t\tif (matchShapes) {\r\n\t\t\tvar shape = item.toShape(false);\r\n\t\t\tif (shape)\r\n\t\t\t\treturn exportShape(shape, options);\r\n\t\t}\r\n\t\tvar segments = item._segments,\r\n\t\t\ttype,\r\n\t\t\tattrs = getTransform(item._matrix);\r\n\t\tif (segments.length === 0)\r\n\t\t\treturn null;\r\n\t\tif (matchShapes && !item.hasHandles()) {\r\n\t\t\tif (segments.length >= 3) {\r\n\t\t\t\ttype = item._closed ? 'polygon' : 'polyline';\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var i = 0, l = segments.length; i < l; i++)\r\n\t\t\t\t\tparts.push(formatter.point(segments[i]._point));\r\n\t\t\t\tattrs.points = parts.join(' ');\r\n\t\t\t} else {\r\n\t\t\t\ttype = 'line';\r\n\t\t\t\tvar first = segments[0]._point,\r\n\t\t\t\t\tlast = segments[segments.length - 1]._point;\r\n\t\t\t\tattrs.set({\r\n\t\t\t\t\tx1: first.x,\r\n\t\t\t\t\ty1: first.y,\r\n\t\t\t\t\tx2: last.x,\r\n\t\t\t\t\ty2: last.y\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttype = 'path';\r\n\t\t\tattrs.d = item.getPathData(null, options.precision);\r\n\t\t}\r\n\t\treturn createElement(type, attrs);\r\n\t}\r\n\r\n\tfunction exportShape(item) {\r\n\t\tvar type = item._type,\r\n\t\t\tradius = item._radius,\r\n\t\t\tattrs = getTransform(item._matrix, true, type !== 'rectangle');\r\n\t\tif (type === 'rectangle') {\r\n\t\t\ttype = 'rect';\r\n\t\t\tvar size = item._size,\r\n\t\t\t\twidth = size.width,\r\n\t\t\t\theight = size.height;\r\n\t\t\tattrs.x -= width / 2;\r\n\t\t\tattrs.y -= height / 2;\r\n\t\t\tattrs.width = width;\r\n\t\t\tattrs.height = height;\r\n\t\t\tif (radius.isZero())\r\n\t\t\t\tradius = null;\r\n\t\t}\r\n\t\tif (radius) {\r\n\t\t\tif (type === 'circle') {\r\n\t\t\t\tattrs.r = radius;\r\n\t\t\t} else {\r\n\t\t\t\tattrs.rx = radius.width;\r\n\t\t\t\tattrs.ry = radius.height;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn createElement(type, attrs);\r\n\t}\r\n\r\n\tfunction exportCompoundPath(item, options) {\r\n\t\tvar attrs = getTransform(item._matrix);\r\n\t\tvar data = item.getPathData(null, options.precision);\r\n\t\tif (data)\r\n\t\t\tattrs.d = data;\r\n\t\treturn createElement('path', attrs);\r\n\t}\r\n\r\n\tfunction exportPlacedSymbol(item, options) {\r\n\t\tvar attrs = getTransform(item._matrix, true),\r\n\t\t\tsymbol = item.getSymbol(),\r\n\t\t\tsymbolNode = getDefinition(symbol, 'symbol'),\r\n\t\t\tdefinition = symbol.getDefinition(),\r\n\t\t\tbounds = definition.getBounds();\r\n\t\tif (!symbolNode) {\r\n\t\t\tsymbolNode = createElement('symbol', {\r\n\t\t\t\tviewBox: formatter.rectangle(bounds)\r\n\t\t\t});\r\n\t\t\tsymbolNode.appendChild(exportSVG(definition, options));\r\n\t\t\tsetDefinition(symbol, symbolNode, 'symbol');\r\n\t\t}\r\n\t\tattrs.href = '#' + symbolNode.id;\r\n\t\tattrs.x += bounds.x;\r\n\t\tattrs.y += bounds.y;\r\n\t\tattrs.width = formatter.number(bounds.width);\r\n\t\tattrs.height = formatter.number(bounds.height);\r\n\t\tattrs.overflow = 'visible';\r\n\t\treturn createElement('use', attrs);\r\n\t}\r\n\r\n\tfunction exportGradient(color) {\r\n\t\tvar gradientNode = getDefinition(color, 'color');\r\n\t\tif (!gradientNode) {\r\n\t\t\tvar gradient = color.getGradient(),\r\n\t\t\t\tradial = gradient._radial,\r\n\t\t\t\torigin = color.getOrigin().transform(),\r\n\t\t\t\tdestination = color.getDestination().transform(),\r\n\t\t\t\tattrs;\r\n\t\t\tif (radial) {\r\n\t\t\t\tattrs = {\r\n\t\t\t\t\tcx: origin.x,\r\n\t\t\t\t\tcy: origin.y,\r\n\t\t\t\t\tr: origin.getDistance(destination)\r\n\t\t\t\t};\r\n\t\t\t\tvar highlight = color.getHighlight();\r\n\t\t\t\tif (highlight) {\r\n\t\t\t\t\thighlight = highlight.transform();\r\n\t\t\t\t\tattrs.fx = highlight.x;\r\n\t\t\t\t\tattrs.fy = highlight.y;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tattrs = {\r\n\t\t\t\t\tx1: origin.x,\r\n\t\t\t\t\ty1: origin.y,\r\n\t\t\t\t\tx2: destination.x,\r\n\t\t\t\t\ty2: destination.y\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\tattrs.gradientUnits = 'userSpaceOnUse';\r\n\t\t\tgradientNode = createElement(\r\n\t\t\t\t\t(radial ? 'radial' : 'linear') + 'Gradient', attrs);\r\n\t\t\tvar stops = gradient._stops;\r\n\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\r\n\t\t\t\tvar stop = stops[i],\r\n\t\t\t\t\tstopColor = stop._color,\r\n\t\t\t\t\talpha = stopColor.getAlpha();\r\n\t\t\t\tattrs = {\r\n\t\t\t\t\toffset: stop._rampPoint,\r\n\t\t\t\t\t'stop-color': stopColor.toCSS(true)\r\n\t\t\t\t};\r\n\t\t\t\tif (alpha < 1)\r\n\t\t\t\t\tattrs['stop-opacity'] = alpha;\r\n\t\t\t\tgradientNode.appendChild(createElement('stop', attrs));\r\n\t\t\t}\r\n\t\t\tsetDefinition(color, gradientNode, 'color');\r\n\t\t}\r\n\t\treturn 'url(#' + gradientNode.id + ')';\r\n\t}\r\n\r\n\tfunction exportText(item) {\r\n\t\tvar node = createElement('text', getTransform(item._matrix, true));\r\n\t\tnode.textContent = item._content;\r\n\t\treturn node;\r\n\t}\r\n\r\n\tvar exporters = {\r\n\t\tGroup: exportGroup,\r\n\t\tLayer: exportGroup,\r\n\t\tRaster: exportRaster,\r\n\t\tPath: exportPath,\r\n\t\tShape: exportShape,\r\n\t\tCompoundPath: exportCompoundPath,\r\n\t\tPlacedSymbol: exportPlacedSymbol,\r\n\t\tPointText: exportText\r\n\t};\r\n\r\n\tfunction applyStyle(item, node, isRoot) {\r\n\t\tvar attrs = {},\r\n\t\t\tparent = !isRoot && item.getParent();\r\n\r\n\t\tif (item._name != null)\r\n\t\t\tattrs.id = item._name;\r\n\r\n\t\tBase.each(SVGStyles, function(entry) {\r\n\t\t\tvar get = entry.get,\r\n\t\t\t\ttype = entry.type,\r\n\t\t\t\tvalue = item[get]();\r\n\t\t\tif (entry.exportFilter\r\n\t\t\t\t\t? entry.exportFilter(item, value)\r\n\t\t\t\t\t: !parent || !Base.equals(parent[get](), value)) {\r\n\t\t\t\tif (type === 'color' && value != null) {\r\n\t\t\t\t\tvar alpha = value.getAlpha();\r\n\t\t\t\t\tif (alpha < 1)\r\n\t\t\t\t\t\tattrs[entry.attribute + '-opacity'] = alpha;\r\n\t\t\t\t}\r\n\t\t\t\tattrs[entry.attribute] = value == null\r\n\t\t\t\t\t? 'none'\r\n\t\t\t\t\t: type === 'number'\r\n\t\t\t\t\t\t? formatter.number(value)\r\n\t\t\t\t\t\t: type === 'color'\r\n\t\t\t\t\t\t\t? value.gradient\r\n\t\t\t\t\t\t\t\t? exportGradient(value, item)\r\n\t\t\t\t\t\t\t\t: value.toCSS(true)\r\n\t\t\t\t\t\t\t: type === 'array'\r\n\t\t\t\t\t\t\t\t? value.join(',')\r\n\t\t\t\t\t\t\t\t: type === 'lookup'\r\n\t\t\t\t\t\t\t\t\t? entry.toSVG[value]\r\n\t\t\t\t\t\t\t\t\t: value;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif (attrs.opacity === 1)\r\n\t\t\tdelete attrs.opacity;\r\n\r\n\t\tif (!item._visible)\r\n\t\t\tattrs.visibility = 'hidden';\r\n\r\n\t\treturn setAttributes(node, attrs);\r\n\t}\r\n\r\n\tvar definitions;\r\n\tfunction getDefinition(item, type) {\r\n\t\tif (!definitions)\r\n\t\t\tdefinitions = { ids: {}, svgs: {} };\r\n\t\treturn item && definitions.svgs[type + '-' + item._id];\r\n\t}\r\n\r\n\tfunction setDefinition(item, node, type) {\r\n\t\tif (!definitions)\r\n\t\t\tgetDefinition();\r\n\t\tvar id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;\r\n\t\tnode.id = type + '-' + id;\r\n\t\tdefinitions.svgs[type + '-' + item._id] = node;\r\n\t}\r\n\r\n\tfunction exportDefinitions(node, options) {\r\n\t\tvar svg = node,\r\n\t\t\tdefs = null;\r\n\t\tif (definitions) {\r\n\t\t\tsvg = node.nodeName.toLowerCase() === 'svg' && node;\r\n\t\t\tfor (var i in definitions.svgs) {\r\n\t\t\t\tif (!defs) {\r\n\t\t\t\t\tif (!svg) {\r\n\t\t\t\t\t\tsvg = createElement('svg');\r\n\t\t\t\t\t\tsvg.appendChild(node);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdefs = svg.insertBefore(createElement('defs'),\r\n\t\t\t\t\t\t\tsvg.firstChild);\r\n\t\t\t\t}\r\n\t\t\t\tdefs.appendChild(definitions.svgs[i]);\r\n\t\t\t}\r\n\t\t\tdefinitions = null;\r\n\t\t}\r\n\t\treturn options.asString\r\n\t\t\t\t? new XMLSerializer().serializeToString(svg)\r\n\t\t\t\t: svg;\r\n\t}\r\n\r\n\tfunction exportSVG(item, options, isRoot) {\r\n\t\tvar exporter = exporters[item._class],\r\n\t\t\tnode = exporter && exporter(item, options);\r\n\t\tif (node) {\r\n\t\t\tvar onExport = options.onExport;\r\n\t\t\tif (onExport)\r\n\t\t\t\tnode = onExport(item, node, options) || node;\r\n\t\t\tvar data = JSON.stringify(item._data);\r\n\t\t\tif (data && data !== '{}' && data !== 'null')\r\n\t\t\t\tnode.setAttribute('data-paper-data', data);\r\n\t\t}\r\n\t\treturn node && applyStyle(item, node, isRoot);\r\n\t}\r\n\r\n\tfunction setOptions(options) {\r\n\t\tif (!options)\r\n\t\t\toptions = {};\r\n\t\tformatter = new Formatter(options.precision);\r\n\t\treturn options;\r\n\t}\r\n\r\n\tItem.inject({\r\n\t\texportSVG: function(options) {\r\n\t\t\toptions = setOptions(options);\r\n\t\t\treturn exportDefinitions(exportSVG(this, options, true), options);\r\n\t\t}\r\n\t});\r\n\r\n\tProject.inject({\r\n\t\texportSVG: function(options) {\r\n\t\t\toptions = setOptions(options);\r\n\t\t\tvar layers = this.layers,\r\n\t\t\t\tview = this.getView(),\r\n\t\t\t\tsize = view.getViewSize(),\r\n\t\t\t\tnode = createElement('svg', {\r\n\t\t\t\t\tx: 0,\r\n\t\t\t\t\ty: 0,\r\n\t\t\t\t\twidth: size.width,\r\n\t\t\t\t\theight: size.height,\r\n\t\t\t\t\tversion: '1.1',\r\n\t\t\t\t\txmlns: 'http://www.w3.org/2000/svg',\r\n\t\t\t\t\t'xmlns:xlink': 'http://www.w3.org/1999/xlink'\r\n\t\t\t\t}),\r\n\t\t\t\tparent = node,\r\n\t\t\t\tmatrix = view._matrix;\r\n\t\t\tif (!matrix.isIdentity())\r\n\t\t\t\tparent = node.appendChild(\r\n\t\t\t\t\t\tcreateElement('g', getTransform(matrix)));\r\n\t\t\tfor (var i = 0, l = layers.length; i < l; i++)\r\n\t\t\t\tparent.appendChild(exportSVG(layers[i], options, true));\r\n\t\t\treturn exportDefinitions(node, options);\r\n\t\t}\r\n\t});\r\n};\r\n\r\nnew function() {\r\n\r\n\tfunction getValue(node, name, isString, allowNull) {\r\n\t\tvar namespace = SVGNamespaces[name],\r\n\t\t\tvalue = namespace\r\n\t\t\t\t? node.getAttributeNS(namespace, name)\r\n\t\t\t\t: node.getAttribute(name);\r\n\t\tif (value === 'null')\r\n\t\t\tvalue = null;\r\n\t\treturn value == null\r\n\t\t\t\t? allowNull\r\n\t\t\t\t\t? null\r\n\t\t\t\t\t: isString\r\n\t\t\t\t\t\t? ''\r\n\t\t\t\t\t\t: 0\r\n\t\t\t\t: isString\r\n\t\t\t\t\t? value\r\n\t\t\t\t\t: parseFloat(value);\r\n\t}\r\n\r\n\tfunction getPoint(node, x, y, allowNull) {\r\n\t\tx = getValue(node, x, false, allowNull);\r\n\t\ty = getValue(node, y, false, allowNull);\r\n\t\treturn allowNull && (x == null || y == null) ? null\r\n\t\t\t\t: new Point(x, y);\r\n\t}\r\n\r\n\tfunction getSize(node, w, h, allowNull) {\r\n\t\tw = getValue(node, w, false, allowNull);\r\n\t\th = getValue(node, h, false, allowNull);\r\n\t\treturn allowNull && (w == null || h == null) ? null\r\n\t\t\t\t: new Size(w, h);\r\n\t}\r\n\r\n\tfunction convertValue(value, type, lookup) {\r\n\t\treturn value === 'none'\r\n\t\t\t\t? null\r\n\t\t\t\t: type === 'number'\r\n\t\t\t\t\t? parseFloat(value)\r\n\t\t\t\t\t: type === 'array'\r\n\t\t\t\t\t\t? value ? value.split(/[\\s,]+/g).map(parseFloat) : []\r\n\t\t\t\t\t\t: type === 'color'\r\n\t\t\t\t\t\t\t? getDefinition(value) || value\r\n\t\t\t\t\t\t\t: type === 'lookup'\r\n\t\t\t\t\t\t\t\t? lookup[value]\r\n\t\t\t\t\t\t\t\t: value;\r\n\t}\r\n\r\n\tfunction importGroup(node, type, options, isRoot) {\r\n\t\tvar nodes = node.childNodes,\r\n\t\t\tisClip = type === 'clippath',\r\n\t\t\titem = new Group(),\r\n\t\t\tproject = item._project,\r\n\t\t\tcurrentStyle = project._currentStyle,\r\n\t\t\tchildren = [];\r\n\t\tif (!isClip) {\r\n\t\t\titem = applyAttributes(item, node, isRoot);\r\n\t\t\tproject._currentStyle = item._style.clone();\r\n\t\t}\r\n\t\tif (isRoot) {\r\n\t\t\tvar defs = node.querySelectorAll('defs');\r\n\t\t\tfor (var i = 0, l = defs.length; i < l; i++) {\r\n\t\t\t\timportSVG(defs[i], options, false);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\r\n\t\t\tvar childNode = nodes[i],\r\n\t\t\t\tchild;\r\n\t\t\tif (childNode.nodeType === 1\r\n\t\t\t\t\t&& childNode.nodeName.toLowerCase() !== 'defs'\r\n\t\t\t\t\t&& (child = importSVG(childNode, options, false))\r\n\t\t\t\t\t&& !(child instanceof Symbol))\r\n\t\t\t\tchildren.push(child);\r\n\t\t}\r\n\t\titem.addChildren(children);\r\n\t\tif (isClip)\r\n\t\t\titem = applyAttributes(item.reduce(), node, isRoot);\r\n\t\tproject._currentStyle = currentStyle;\r\n\t\tif (isClip || type === 'defs') {\r\n\t\t\titem.remove();\r\n\t\t\titem = null;\r\n\t\t}\r\n\t\treturn item;\r\n\t}\r\n\r\n\tfunction importPoly(node, type) {\r\n\t\tvar coords = node.getAttribute('points').match(\r\n\t\t\t\t\t/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g),\r\n\t\t\tpoints = [];\r\n\t\tfor (var i = 0, l = coords.length; i < l; i += 2)\r\n\t\t\tpoints.push(new Point(\r\n\t\t\t\t\tparseFloat(coords[i]),\r\n\t\t\t\t\tparseFloat(coords[i + 1])));\r\n\t\tvar path = new Path(points);\r\n\t\tif (type === 'polygon')\r\n\t\t\tpath.closePath();\r\n\t\treturn path;\r\n\t}\r\n\r\n\tfunction importPath(node) {\r\n\t\tvar data = node.getAttribute('d'),\r\n\t\t\tparam = { pathData: data };\r\n\t\treturn (data.match(/m/gi) || []).length > 1 || /z\\S+/i.test(data)\r\n\t\t\t\t? new CompoundPath(param)\r\n\t\t\t\t: new Path(param);\r\n\t}\r\n\r\n\tfunction importGradient(node, type) {\r\n\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\r\n\t\t\tisRadial = type === 'radialgradient',\r\n\t\t\tgradient;\r\n\t\tif (id) {\r\n\t\t\tgradient = definitions[id].getGradient();\r\n\t\t} else {\r\n\t\t\tvar nodes = node.childNodes,\r\n\t\t\t\tstops = [];\r\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\r\n\t\t\t\tvar child = nodes[i];\r\n\t\t\t\tif (child.nodeType === 1)\r\n\t\t\t\t\tstops.push(applyAttributes(new GradientStop(), child));\r\n\t\t\t}\r\n\t\t\tgradient = new Gradient(stops, isRadial);\r\n\t\t}\r\n\t\tvar origin, destination, highlight;\r\n\t\tif (isRadial) {\r\n\t\t\torigin = getPoint(node, 'cx', 'cy');\r\n\t\t\tdestination = origin.add(getValue(node, 'r'), 0);\r\n\t\t\thighlight = getPoint(node, 'fx', 'fy', true);\r\n\t\t} else {\r\n\t\t\torigin = getPoint(node, 'x1', 'y1');\r\n\t\t\tdestination = getPoint(node, 'x2', 'y2');\r\n\t\t}\r\n\t\tapplyAttributes(\r\n\t\t\tnew Color(gradient, origin, destination, highlight), node);\r\n\t\treturn null;\r\n\t}\r\n\r\n\tvar importers = {\r\n\t\t'#document': function (node, type, options, isRoot) {\r\n\t\t\tvar nodes = node.childNodes;\r\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\r\n\t\t\t\tvar child = nodes[i];\r\n\t\t\t\tif (child.nodeType === 1) {\r\n\t\t\t\t\tvar next = child.nextSibling;\r\n\t\t\t\t\tdocument.body.appendChild(child);\r\n\t\t\t\t\tvar item = importSVG(child, options, isRoot);\r\n\t\t\t\t\tif (next) {\r\n\t\t\t\t\t\tnode.insertBefore(child, next);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnode.appendChild(child);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn item;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tg: importGroup,\r\n\t\tsvg: importGroup,\r\n\t\tclippath: importGroup,\r\n\t\tpolygon: importPoly,\r\n\t\tpolyline: importPoly,\r\n\t\tpath: importPath,\r\n\t\tlineargradient: importGradient,\r\n\t\tradialgradient: importGradient,\r\n\r\n\t\timage: function (node) {\r\n\t\t\tvar raster = new Raster(getValue(node, 'href', true));\r\n\t\t\traster.on('load', function() {\r\n\t\t\t\tvar size = getSize(node, 'width', 'height');\r\n\t\t\t\tthis.setSize(size);\r\n\t\t\t\tvar center = this._matrix._transformPoint(\r\n\t\t\t\t\t\tgetPoint(node, 'x', 'y').add(size.divide(2)));\r\n\t\t\t\tthis.translate(center);\r\n\t\t\t});\r\n\t\t\treturn raster;\r\n\t\t},\r\n\r\n\t\tsymbol: function(node, type, options, isRoot) {\r\n\t\t\treturn new Symbol(importGroup(node, type, options, isRoot), true);\r\n\t\t},\r\n\r\n\t\tdefs: importGroup,\r\n\r\n\t\tuse: function(node) {\r\n\t\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\r\n\t\t\t\tdefinition = definitions[id],\r\n\t\t\t\tpoint = getPoint(node, 'x', 'y');\r\n\t\t\treturn definition\r\n\t\t\t\t\t? definition instanceof Symbol\r\n\t\t\t\t\t\t? definition.place(point)\r\n\t\t\t\t\t\t: definition.clone().translate(point)\r\n\t\t\t\t\t: null;\r\n\t\t},\r\n\r\n\t\tcircle: function(node) {\r\n\t\t\treturn new Shape.Circle(getPoint(node, 'cx', 'cy'),\r\n\t\t\t\t\tgetValue(node, 'r'));\r\n\t\t},\r\n\r\n\t\tellipse: function(node) {\r\n\t\t\treturn new Shape.Ellipse({\r\n\t\t\t\tcenter: getPoint(node, 'cx', 'cy'),\r\n\t\t\t\tradius: getSize(node, 'rx', 'ry')\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\trect: function(node) {\r\n\t\t\tvar point = getPoint(node, 'x', 'y'),\r\n\t\t\t\tsize = getSize(node, 'width', 'height'),\r\n\t\t\t\tradius = getSize(node, 'rx', 'ry');\r\n\t\t\treturn new Shape.Rectangle(new Rectangle(point, size), radius);\r\n\t\t},\r\n\r\n\t\tline: function(node) {\r\n\t\t\treturn new Path.Line(getPoint(node, 'x1', 'y1'),\r\n\t\t\t\t\tgetPoint(node, 'x2', 'y2'));\r\n\t\t},\r\n\r\n\t\ttext: function(node) {\r\n\t\t\tvar text = new PointText(getPoint(node, 'x', 'y')\r\n\t\t\t\t\t.add(getPoint(node, 'dx', 'dy')));\r\n\t\t\ttext.setContent(node.textContent.trim() || '');\r\n\t\t\treturn text;\r\n\t\t}\r\n\t};\r\n\r\n\tfunction applyTransform(item, value, name, node) {\r\n\t\tvar transforms = (node.getAttribute(name) || '').split(/\\)\\s*/g),\r\n\t\t\tmatrix = new Matrix();\r\n\t\tfor (var i = 0, l = transforms.length; i < l; i++) {\r\n\t\t\tvar transform = transforms[i];\r\n\t\t\tif (!transform)\r\n\t\t\t\tbreak;\r\n\t\t\tvar parts = transform.split(/\\(\\s*/),\r\n\t\t\t\tcommand = parts[0],\r\n\t\t\t\tv = parts[1].split(/[\\s,]+/g);\r\n\t\t\tfor (var j = 0, m = v.length; j < m; j++)\r\n\t\t\t\tv[j] = parseFloat(v[j]);\r\n\t\t\tswitch (command) {\r\n\t\t\tcase 'matrix':\r\n\t\t\t\tmatrix.concatenate(\r\n\t\t\t\t\t\tnew Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'rotate':\r\n\t\t\t\tmatrix.rotate(v[0], v[1], v[2]);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'translate':\r\n\t\t\t\tmatrix.translate(v[0], v[1]);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'scale':\r\n\t\t\t\tmatrix.scale(v);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'skewX':\r\n\t\t\t\tmatrix.skew(v[0], 0);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'skewY':\r\n\t\t\t\tmatrix.skew(0, v[0]);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\titem.transform(matrix);\r\n\t}\r\n\r\n\tfunction applyOpacity(item, value, name) {\r\n\t\tvar color = item[name === 'fill-opacity' ? 'getFillColor'\r\n\t\t\t\t: 'getStrokeColor']();\r\n\t\tif (color)\r\n\t\t\tcolor.setAlpha(parseFloat(value));\r\n\t}\r\n\r\n\tvar attributes = Base.set(Base.each(SVGStyles, function(entry) {\r\n\t\tthis[entry.attribute] = function(item, value) {\r\n\t\t\titem[entry.set](convertValue(value, entry.type, entry.fromSVG));\r\n\t\t\tif (entry.type === 'color' && item instanceof Shape) {\r\n\t\t\t\tvar color = item[entry.get]();\r\n\t\t\t\tif (color)\r\n\t\t\t\t\tcolor.transform(new Matrix().translate(\r\n\t\t\t\t\t\t\titem.getPosition(true).negate()));\r\n\t\t\t}\r\n\t\t};\r\n\t}, {}), {\r\n\t\tid: function(item, value) {\r\n\t\t\tdefinitions[value] = item;\r\n\t\t\tif (item.setName)\r\n\t\t\t\titem.setName(value);\r\n\t\t},\r\n\r\n\t\t'clip-path': function(item, value) {\r\n\t\t\tvar clip = getDefinition(value);\r\n\t\t\tif (clip) {\r\n\t\t\t\tclip = clip.clone();\r\n\t\t\t\tclip.setClipMask(true);\r\n\t\t\t\tif (item instanceof Group) {\r\n\t\t\t\t\titem.insertChild(0, clip);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn new Group(clip, item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgradientTransform: applyTransform,\r\n\t\ttransform: applyTransform,\r\n\r\n\t\t'fill-opacity': applyOpacity,\r\n\t\t'stroke-opacity': applyOpacity,\r\n\r\n\t\tvisibility: function(item, value) {\r\n\t\t\titem.setVisible(value === 'visible');\r\n\t\t},\r\n\r\n\t\tdisplay: function(item, value) {\r\n\t\t\titem.setVisible(value !== null);\r\n\t\t},\r\n\r\n\t\t'stop-color': function(item, value) {\r\n\t\t\tif (item.setColor)\r\n\t\t\t\titem.setColor(value);\r\n\t\t},\r\n\r\n\t\t'stop-opacity': function(item, value) {\r\n\t\t\tif (item._color)\r\n\t\t\t\titem._color.setAlpha(parseFloat(value));\r\n\t\t},\r\n\r\n\t\toffset: function(item, value) {\r\n\t\t\tvar percentage = value.match(/(.*)%$/);\r\n\t\t\titem.setRampPoint(percentage\r\n\t\t\t\t\t? percentage[1] / 100\r\n\t\t\t\t\t: parseFloat(value));\r\n\t\t},\r\n\r\n\t\tviewBox: function(item, value, name, node, styles) {\r\n\t\t\tvar rect = new Rectangle(convertValue(value, 'array')),\r\n\t\t\t\tsize = getSize(node, 'width', 'height', true);\r\n\t\t\tif (item instanceof Group) {\r\n\t\t\t\tvar scale = size ? rect.getSize().divide(size) : 1,\r\n\t\t\t\t\tmatrix = new Matrix().translate(rect.getPoint()).scale(scale);\r\n\t\t\t\titem.transform(matrix.inverted());\r\n\t\t\t} else if (item instanceof Symbol) {\r\n\t\t\t\tif (size)\r\n\t\t\t\t\trect.setSize(size);\r\n\t\t\t\tvar clip = getAttribute(node, 'overflow', styles) != 'visible',\r\n\t\t\t\t\tgroup = item._definition;\r\n\t\t\t\tif (clip && !rect.contains(group.getBounds())) {\r\n\t\t\t\t\tclip = new Shape.Rectangle(rect).transform(group._matrix);\r\n\t\t\t\t\tclip.setClipMask(true);\r\n\t\t\t\t\tgroup.addChild(clip);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\tfunction getAttribute(node, name, styles) {\r\n\t\tvar attr = node.attributes[name],\r\n\t\t\tvalue = attr && attr.value;\r\n\t\tif (!value) {\r\n\t\t\tvar style = Base.camelize(name);\r\n\t\t\tvalue = node.style[style];\r\n\t\t\tif (!value && styles.node[style] !== styles.parent[style])\r\n\t\t\t\tvalue = styles.node[style];\r\n\t\t}\r\n\t\treturn !value\r\n\t\t\t\t? undefined\r\n\t\t\t\t: value === 'none'\r\n\t\t\t\t\t? null\r\n\t\t\t\t\t: value;\r\n\t}\r\n\r\n\tfunction applyAttributes(item, node, isRoot) {\r\n\t\tvar styles = {\r\n\t\t\tnode: DomElement.getStyles(node) || {},\r\n\t\t\tparent: !isRoot && DomElement.getStyles(node.parentNode) || {}\r\n\t\t};\r\n\t\tBase.each(attributes, function(apply, name) {\r\n\t\t\tvar value = getAttribute(node, name, styles);\r\n\t\t\tif (value !== undefined)\r\n\t\t\t\titem = Base.pick(apply(item, value, name, node, styles), item);\r\n\t\t});\r\n\t\treturn item;\r\n\t}\r\n\r\n\tvar definitions = {};\r\n\tfunction getDefinition(value) {\r\n\t\tvar match = value && value.match(/\\((?:#|)([^)']+)/);\r\n\t\treturn match && definitions[match[1]];\r\n\t}\r\n\r\n\tfunction importSVG(source, options, isRoot) {\r\n\t\tif (!source)\r\n\t\t\treturn null;\r\n\t\tif (!options) {\r\n\t\t\toptions = {};\r\n\t\t} else if (typeof options === 'function') {\r\n\t\t\toptions = { onLoad: options };\r\n\t\t}\r\n\r\n\t\tvar node = source,\r\n\t\t\tscope = paper;\r\n\r\n\t\tfunction onLoadCallback(svg) {\r\n\t\t\tpaper = scope;\r\n\t\t\tvar item = importSVG(svg, options, isRoot),\r\n\t\t\t\tonLoad = options.onLoad,\r\n\t\t\t\tview = scope.project && scope.getView();\r\n\t\t\tif (onLoad)\r\n\t\t\t\tonLoad.call(this, item);\r\n\t\t\tview.update();\r\n\t\t}\r\n\r\n\t\tif (isRoot) {\r\n\t\t\tif (typeof source === 'string' && !/^.*</.test(source)) {\r\n\t\t\t\tnode = document.getElementById(source);\r\n\t\t\t\tif (node) {\r\n\t\t\t\t\tsource = null;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn Http.request('get', source, onLoadCallback);\r\n\t\t\t\t}\r\n\t\t\t} else if (typeof File !== 'undefined' && source instanceof File) {\r\n\t\t\t\tvar reader = new FileReader();\r\n\t\t\t\treader.onload = function() {\r\n\t\t\t\t\tonLoadCallback(reader.result);\r\n\t\t\t\t};\r\n\t\t\t\treturn reader.readAsText(source);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (typeof source === 'string')\r\n\t\t\tnode = new DOMParser().parseFromString(source, 'image/svg+xml');\r\n\t\tif (!node.nodeName)\r\n\t\t\tthrow new Error('Unsupported SVG source: ' + source);\r\n\t\tvar type = node.nodeName.toLowerCase(),\r\n\t\t\timporter = importers[type],\r\n\t\t\titem,\r\n\t\t\tdata = node.getAttribute && node.getAttribute('data-paper-data'),\r\n\t\t\tsettings = scope.settings,\r\n\t\t\tapplyMatrix = settings.applyMatrix;\r\n\t\tsettings.applyMatrix = false;\r\n\t\titem = importer && importer(node, type, options, isRoot) || null;\r\n\t\tsettings.applyMatrix = applyMatrix;\r\n\t\tif (item) {\r\n\t\t\tif (type !== '#document' && !(item instanceof Group))\r\n\t\t\t\titem = applyAttributes(item, node, isRoot);\r\n\t\t\tvar onImport = options.onImport;\r\n\t\t\tif (onImport)\r\n\t\t\t\titem = onImport(node, item, options) || item;\r\n\t\t\tif (options.expandShapes && item instanceof Shape) {\r\n\t\t\t\titem.remove();\r\n\t\t\t\titem = item.toPath();\r\n\t\t\t}\r\n\t\t\tif (data)\r\n\t\t\t\titem._data = JSON.parse(data);\r\n\t\t}\r\n\t\tif (isRoot) {\r\n\t\t\tdefinitions = {};\r\n\t\t\tif (item && Base.pick(options.applyMatrix, applyMatrix))\r\n\t\t\t\titem.matrix.apply(true, true);\r\n\t\t}\r\n\t\treturn item;\r\n\t}\r\n\r\n\tItem.inject({\r\n\t\timportSVG: function(node, options) {\r\n\t\t\treturn this.addChild(importSVG(node, options, true));\r\n\t\t}\r\n\t});\r\n\r\n\tProject.inject({\r\n\t\timportSVG: function(node, options) {\r\n\t\t\tthis.activate();\r\n\t\t\treturn importSVG(node, options, true);\r\n\t\t}\r\n\t});\r\n};\r\n\r\nBase.exports.PaperScript = (function() {\r\n\tvar exports, define,\r\n\t\tscope = this;\r\n!function(e,r){return\"object\"==typeof exports&&\"object\"==typeof module?r(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],r):(r(e.acorn||(e.acorn={})),void 0)}(this,function(e){\"use strict\";function r(e){fr=e||{};for(var r in mr)Object.prototype.hasOwnProperty.call(fr,r)||(fr[r]=mr[r]);hr=fr.sourceFile||null}function t(e,r){var t=vr(dr,e);r+=\" (\"+t.line+\":\"+t.column+\")\";var n=new SyntaxError(r);throw n.pos=e,n.loc=t,n.raisedAt=br,n}function n(e){function r(e){if(1==e.length)return t+=\"return str === \"+JSON.stringify(e[0])+\";\";t+=\"switch(str){\";for(var r=0;r<e.length;++r)t+=\"case \"+JSON.stringify(e[r])+\":\";t+=\"return true}return false;\"}e=e.split(\" \");var t=\"\",n=[];e:for(var a=0;a<e.length;++a){for(var o=0;o<n.length;++o)if(n[o][0].length==e[a].length){n[o].push(e[a]);continue e}n.push([e[a]])}if(n.length>3){n.sort(function(e,r){return r.length-e.length}),t+=\"switch(str.length){\";for(var a=0;a<n.length;++a){var i=n[a];t+=\"case \"+i[0].length+\":\",r(i)}t+=\"}\"}else r(e);return new Function(\"str\",t)}function a(){this.line=Ar,this.column=br-Sr}function o(){Ar=1,br=Sr=0,Er=!0,u()}function i(e,r){gr=br,fr.locations&&(kr=new a),wr=e,u(),Cr=r,Er=e.beforeExpr}function s(){var e=fr.onComment&&fr.locations&&new a,r=br,n=dr.indexOf(\"*/\",br+=2);if(-1===n&&t(br-2,\"Unterminated comment\"),br=n+2,fr.locations){Kt.lastIndex=r;for(var o;(o=Kt.exec(dr))&&o.index<br;)++Ar,Sr=o.index+o[0].length}fr.onComment&&fr.onComment(!0,dr.slice(r+2,n),r,br,e,fr.locations&&new a)}function c(){for(var e=br,r=fr.onComment&&fr.locations&&new a,t=dr.charCodeAt(br+=2);pr>br&&10!==t&&13!==t&&8232!==t&&8233!==t;)++br,t=dr.charCodeAt(br);fr.onComment&&fr.onComment(!1,dr.slice(e+2,br),e,br,r,fr.locations&&new a)}function u(){for(;pr>br;){var e=dr.charCodeAt(br);if(32===e)++br;else if(13===e){++br;var r=dr.charCodeAt(br);10===r&&++br,fr.locations&&(++Ar,Sr=br)}else if(10===e||8232===e||8233===e)++br,fr.locations&&(++Ar,Sr=br);else if(e>8&&14>e)++br;else if(47===e){var r=dr.charCodeAt(br+1);if(42===r)s();else{if(47!==r)break;c()}}else if(160===e)++br;else{if(!(e>=5760&&Jt.test(String.fromCharCode(e))))break;++br}}}function l(){var e=dr.charCodeAt(br+1);return e>=48&&57>=e?E(!0):(++br,i(xt))}function f(){var e=dr.charCodeAt(br+1);return Er?(++br,k()):61===e?x(Et,2):x(wt,1)}function d(){var e=dr.charCodeAt(br+1);return 61===e?x(Et,2):x(Dt,1)}function p(e){var r=dr.charCodeAt(br+1);return r===e?x(124===e?Lt:Ut,2):61===r?x(Et,2):x(124===e?Rt:Tt,1)}function h(){var e=dr.charCodeAt(br+1);return 61===e?x(Et,2):x(Vt,1)}function m(e){var r=dr.charCodeAt(br+1);return r===e?45==r&&62==dr.charCodeAt(br+2)&&Gt.test(dr.slice(Lr,br))?(br+=3,c(),u(),g()):x(St,2):61===r?x(Et,2):x(At,1)}function v(e){var r=dr.charCodeAt(br+1),t=1;return r===e?(t=62===e&&62===dr.charCodeAt(br+2)?3:2,61===dr.charCodeAt(br+t)?x(Et,t+1):x(jt,t)):33==r&&60==e&&45==dr.charCodeAt(br+2)&&45==dr.charCodeAt(br+3)?(br+=4,c(),u(),g()):(61===r&&(t=61===dr.charCodeAt(br+2)?3:2),x(Ot,t))}function b(e){var r=dr.charCodeAt(br+1);return 61===r?x(qt,61===dr.charCodeAt(br+2)?3:2):x(61===e?Ct:It,1)}function y(e){switch(e){case 46:return l();case 40:return++br,i(mt);case 41:return++br,i(vt);case 59:return++br,i(yt);case 44:return++br,i(bt);case 91:return++br,i(ft);case 93:return++br,i(dt);case 123:return++br,i(pt);case 125:return++br,i(ht);case 58:return++br,i(gt);case 63:return++br,i(kt);case 48:var r=dr.charCodeAt(br+1);if(120===r||88===r)return C();case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return E(!1);case 34:case 39:return A(e);case 47:return f(e);case 37:case 42:return d();case 124:case 38:return p(e);case 94:return h();case 43:case 45:return m(e);case 60:case 62:return v(e);case 61:case 33:return b(e);case 126:return x(It,1)}return!1}function g(e){if(e?br=yr+1:yr=br,fr.locations&&(xr=new a),e)return k();if(br>=pr)return i(Br);var r=dr.charCodeAt(br);if(Qt(r)||92===r)return L();var n=y(r);if(n===!1){var o=String.fromCharCode(r);if(\"\\\\\"===o||$t.test(o))return L();t(br,\"Unexpected character '\"+o+\"'\")}return n}function x(e,r){var t=dr.slice(br,br+r);br+=r,i(e,t)}function k(){for(var e,r,n=\"\",a=br;;){br>=pr&&t(a,\"Unterminated regular expression\");var o=dr.charAt(br);if(Gt.test(o)&&t(a,\"Unterminated regular expression\"),e)e=!1;else{if(\"[\"===o)r=!0;else if(\"]\"===o&&r)r=!1;else if(\"/\"===o&&!r)break;e=\"\\\\\"===o}++br}var n=dr.slice(a,br);++br;var s=I();return s&&!/^[gmsiy]*$/.test(s)&&t(a,\"Invalid regexp flag\"),i(jr,new RegExp(n,s))}function w(e,r){for(var t=br,n=0,a=0,o=null==r?1/0:r;o>a;++a){var i,s=dr.charCodeAt(br);if(i=s>=97?s-97+10:s>=65?s-65+10:s>=48&&57>=s?s-48:1/0,i>=e)break;++br,n=n*e+i}return br===t||null!=r&&br-t!==r?null:n}function C(){br+=2;var e=w(16);return null==e&&t(yr+2,\"Expected hexadecimal number\"),Qt(dr.charCodeAt(br))&&t(br,\"Identifier directly after number\"),i(Or,e)}function E(e){var r=br,n=!1,a=48===dr.charCodeAt(br);e||null!==w(10)||t(r,\"Invalid number\"),46===dr.charCodeAt(br)&&(++br,w(10),n=!0);var o=dr.charCodeAt(br);(69===o||101===o)&&(o=dr.charCodeAt(++br),(43===o||45===o)&&++br,null===w(10)&&t(r,\"Invalid number\"),n=!0),Qt(dr.charCodeAt(br))&&t(br,\"Identifier directly after number\");var s,c=dr.slice(r,br);return n?s=parseFloat(c):a&&1!==c.length?/[89]/.test(c)||Tr?t(r,\"Invalid number\"):s=parseInt(c,8):s=parseInt(c,10),i(Or,s)}function A(e){br++;for(var r=\"\";;){br>=pr&&t(yr,\"Unterminated string constant\");var n=dr.charCodeAt(br);if(n===e)return++br,i(Dr,r);if(92===n){n=dr.charCodeAt(++br);var a=/^[0-7]+/.exec(dr.slice(br,br+3));for(a&&(a=a[0]);a&&parseInt(a,8)>255;)a=a.slice(0,a.length-1);if(\"0\"===a&&(a=null),++br,a)Tr&&t(br-2,\"Octal literal in strict mode\"),r+=String.fromCharCode(parseInt(a,8)),br+=a.length-1;else switch(n){case 110:r+=\"\\n\";break;case 114:r+=\"\\r\";break;case 120:r+=String.fromCharCode(S(2));break;case 117:r+=String.fromCharCode(S(4));break;case 85:r+=String.fromCharCode(S(8));break;case 116:r+=\"\t\";break;case 98:r+=\"\\b\";break;case 118:r+=\"\x0B\";break;case 102:r+=\"\\f\";break;case 48:r+=\"\\0\";break;case 13:10===dr.charCodeAt(br)&&++br;case 10:fr.locations&&(Sr=br,++Ar);break;default:r+=String.fromCharCode(n)}}else(13===n||10===n||8232===n||8233===n)&&t(yr,\"Unterminated string constant\"),r+=String.fromCharCode(n),++br}}function S(e){var r=w(16,e);return null===r&&t(yr,\"Bad character escape sequence\"),r}function I(){Bt=!1;for(var e,r=!0,n=br;;){var a=dr.charCodeAt(br);if(Yt(a))Bt&&(e+=dr.charAt(br)),++br;else{if(92!==a)break;Bt||(e=dr.slice(n,br)),Bt=!0,117!=dr.charCodeAt(++br)&&t(br,\"Expecting Unicode escape sequence \\\\uXXXX\"),++br;var o=S(4),i=String.fromCharCode(o);i||t(br-1,\"Invalid Unicode escape\"),(r?Qt(o):Yt(o))||t(br-4,\"Invalid Unicode escape\"),e+=i}r=!1}return Bt?e:dr.slice(n,br)}function L(){var e=I(),r=Fr;return Bt||(Wt(e)?r=lt[e]:(fr.forbidReserved&&(3===fr.ecmaVersion?Mt:zt)(e)||Tr&&Xt(e))&&t(yr,\"The keyword '\"+e+\"' is reserved\")),i(r,e)}function U(){Ir=yr,Lr=gr,Ur=kr,g()}function R(e){if(Tr=e,br=Lr,fr.locations)for(;Sr>br;)Sr=dr.lastIndexOf(\"\\n\",Sr-2)+1,--Ar;u(),g()}function V(){this.type=null,this.start=yr,this.end=null}function T(){this.start=xr,this.end=null,null!==hr&&(this.source=hr)}function q(){var e=new V;return fr.locations&&(e.loc=new T),fr.ranges&&(e.range=[yr,0]),e}function O(e){var r=new V;return r.start=e.start,fr.locations&&(r.loc=new T,r.loc.start=e.loc.start),fr.ranges&&(r.range=[e.range[0],0]),r}function j(e,r){return e.type=r,e.end=Lr,fr.locations&&(e.loc.end=Ur),fr.ranges&&(e.range[1]=Lr),e}function D(e){return fr.ecmaVersion>=5&&\"ExpressionStatement\"===e.type&&\"Literal\"===e.expression.type&&\"use strict\"===e.expression.value}function F(e){return wr===e?(U(),!0):void 0}function B(){return!fr.strictSemicolons&&(wr===Br||wr===ht||Gt.test(dr.slice(Lr,yr)))}function M(){F(yt)||B()||X()}function z(e){wr===e?U():X()}function X(){t(yr,\"Unexpected token\")}function N(e){\"Identifier\"!==e.type&&\"MemberExpression\"!==e.type&&t(e.start,\"Assigning to rvalue\"),Tr&&\"Identifier\"===e.type&&Nt(e.name)&&t(e.start,\"Assigning to \"+e.name+\" in strict mode\")}function W(e){Ir=Lr=br,fr.locations&&(Ur=new a),Rr=Tr=null,Vr=[],g();var r=e||q(),t=!0;for(e||(r.body=[]);wr!==Br;){var n=J();r.body.push(n),t&&D(n)&&R(!0),t=!1}return j(r,\"Program\")}function J(){(wr===wt||wr===Et&&\"/=\"==Cr)&&g(!0);var e=wr,r=q();switch(e){case Mr:case Nr:U();var n=e===Mr;F(yt)||B()?r.label=null:wr!==Fr?X():(r.label=lr(),M());for(var a=0;a<Vr.length;++a){var o=Vr[a];if(null==r.label||o.name===r.label.name){if(null!=o.kind&&(n||\"loop\"===o.kind))break;if(r.label&&n)break}}return a===Vr.length&&t(r.start,\"Unsyntactic \"+e.keyword),j(r,n?\"BreakStatement\":\"ContinueStatement\");case Wr:return U(),M(),j(r,\"DebuggerStatement\");case Pr:return U(),Vr.push(Zt),r.body=J(),Vr.pop(),z(tt),r.test=P(),M(),j(r,\"DoWhileStatement\");case _r:if(U(),Vr.push(Zt),z(mt),wr===yt)return $(r,null);if(wr===rt){var i=q();return U(),G(i,!0),j(i,\"VariableDeclaration\"),1===i.declarations.length&&F(ut)?_(r,i):$(r,i)}var i=K(!1,!0);return F(ut)?(N(i),_(r,i)):$(r,i);case Gr:return U(),cr(r,!0);case Kr:return U(),r.test=P(),r.consequent=J(),r.alternate=F(Hr)?J():null,j(r,\"IfStatement\");case Qr:return Rr||t(yr,\"'return' outside of function\"),U(),F(yt)||B()?r.argument=null:(r.argument=K(),M()),j(r,\"ReturnStatement\");case Yr:U(),r.discriminant=P(),r.cases=[],z(pt),Vr.push(en);for(var s,c;wr!=ht;)if(wr===zr||wr===Jr){var u=wr===zr;s&&j(s,\"SwitchCase\"),r.cases.push(s=q()),s.consequent=[],U(),u?s.test=K():(c&&t(Ir,\"Multiple default clauses\"),c=!0,s.test=null),z(gt)}else s||X(),s.consequent.push(J());return s&&j(s,\"SwitchCase\"),U(),Vr.pop(),j(r,\"SwitchStatement\");case Zr:return U(),Gt.test(dr.slice(Lr,yr))&&t(Lr,\"Illegal newline after throw\"),r.argument=K(),M(),j(r,\"ThrowStatement\");case et:if(U(),r.block=H(),r.handler=null,wr===Xr){var l=q();U(),z(mt),l.param=lr(),Tr&&Nt(l.param.name)&&t(l.param.start,\"Binding \"+l.param.name+\" in strict mode\"),z(vt),l.guard=null,l.body=H(),r.handler=j(l,\"CatchClause\")}return r.guardedHandlers=qr,r.finalizer=F($r)?H():null,r.handler||r.finalizer||t(r.start,\"Missing catch or finally clause\"),j(r,\"TryStatement\");case rt:return U(),G(r),M(),j(r,\"VariableDeclaration\");case tt:return U(),r.test=P(),Vr.push(Zt),r.body=J(),Vr.pop(),j(r,\"WhileStatement\");case nt:return Tr&&t(yr,\"'with' in strict mode\"),U(),r.object=P(),r.body=J(),j(r,\"WithStatement\");case pt:return H();case yt:return U(),j(r,\"EmptyStatement\");default:var f=Cr,d=K();if(e===Fr&&\"Identifier\"===d.type&&F(gt)){for(var a=0;a<Vr.length;++a)Vr[a].name===f&&t(d.start,\"Label '\"+f+\"' is already declared\");var p=wr.isLoop?\"loop\":wr===Yr?\"switch\":null;return Vr.push({name:f,kind:p}),r.body=J(),Vr.pop(),r.label=d,j(r,\"LabeledStatement\")}return r.expression=d,M(),j(r,\"ExpressionStatement\")}}function P(){z(mt);var e=K();return z(vt),e}function H(e){var r,t=q(),n=!0,a=!1;for(t.body=[],z(pt);!F(ht);){var o=J();t.body.push(o),n&&e&&D(o)&&(r=a,R(a=!0)),n=!1}return a&&!r&&R(!1),j(t,\"BlockStatement\")}function $(e,r){return e.init=r,z(yt),e.test=wr===yt?null:K(),z(yt),e.update=wr===vt?null:K(),z(vt),e.body=J(),Vr.pop(),j(e,\"ForStatement\")}function _(e,r){return e.left=r,e.right=K(),z(vt),e.body=J(),Vr.pop(),j(e,\"ForInStatement\")}function G(e,r){for(e.declarations=[],e.kind=\"var\";;){var n=q();if(n.id=lr(),Tr&&Nt(n.id.name)&&t(n.id.start,\"Binding \"+n.id.name+\" in strict mode\"),n.init=F(Ct)?K(!0,r):null,e.declarations.push(j(n,\"VariableDeclarator\")),!F(bt))break}return e}function K(e,r){var t=Q(r);if(!e&&wr===bt){var n=O(t);for(n.expressions=[t];F(bt);)n.expressions.push(Q(r));return j(n,\"SequenceExpression\")}return t}function Q(e){var r=Y(e);if(wr.isAssign){var t=O(r);return t.operator=Cr,t.left=r,U(),t.right=Q(e),N(r),j(t,\"AssignmentExpression\")}return r}function Y(e){var r=Z(e);if(F(kt)){var t=O(r);return t.test=r,t.consequent=K(!0),z(gt),t.alternate=K(!0,e),j(t,\"ConditionalExpression\")}return r}function Z(e){return er(rr(),-1,e)}function er(e,r,t){var n=wr.binop;if(null!=n&&(!t||wr!==ut)&&n>r){var a=O(e);a.left=e,a.operator=Cr,U(),a.right=er(rr(),n,t);var o=j(a,/&&|\\|\\|/.test(a.operator)?\"LogicalExpression\":\"BinaryExpression\");return er(o,r,t)}return e}function rr(){if(wr.prefix){var e=q(),r=wr.isUpdate;return e.operator=Cr,e.prefix=!0,Er=!0,U(),e.argument=rr(),r?N(e.argument):Tr&&\"delete\"===e.operator&&\"Identifier\"===e.argument.type&&t(e.start,\"Deleting local variable in strict mode\"),j(e,r?\"UpdateExpression\":\"UnaryExpression\")}for(var n=tr();wr.postfix&&!B();){var e=O(n);e.operator=Cr,e.prefix=!1,e.argument=n,N(n),U(),n=j(e,\"UpdateExpression\")}return n}function tr(){return nr(ar())}function nr(e,r){if(F(xt)){var t=O(e);return t.object=e,t.property=lr(!0),t.computed=!1,nr(j(t,\"MemberExpression\"),r)}if(F(ft)){var t=O(e);return t.object=e,t.property=K(),t.computed=!0,z(dt),nr(j(t,\"MemberExpression\"),r)}if(!r&&F(mt)){var t=O(e);return t.callee=e,t.arguments=ur(vt,!1),nr(j(t,\"CallExpression\"),r)}return e}function ar(){switch(wr){case ot:var e=q();return U(),j(e,\"ThisExpression\");case Fr:return lr();case Or:case Dr:case jr:var e=q();return e.value=Cr,e.raw=dr.slice(yr,gr),U(),j(e,\"Literal\");case it:case st:case ct:var e=q();return e.value=wr.atomValue,e.raw=wr.keyword,U(),j(e,\"Literal\");case mt:var r=xr,t=yr;U();var n=K();return n.start=t,n.end=gr,fr.locations&&(n.loc.start=r,n.loc.end=kr),fr.ranges&&(n.range=[t,gr]),z(vt),n;case ft:var e=q();return U(),e.elements=ur(dt,!0,!0),j(e,\"ArrayExpression\");case pt:return ir();case Gr:var e=q();return U(),cr(e,!1);case at:return or();default:X()}}function or(){var e=q();return U(),e.callee=nr(ar(),!0),e.arguments=F(mt)?ur(vt,!1):qr,j(e,\"NewExpression\")}function ir(){var e=q(),r=!0,n=!1;for(e.properties=[],U();!F(ht);){if(r)r=!1;else if(z(bt),fr.allowTrailingCommas&&F(ht))break;var a,o={key:sr()},i=!1;if(F(gt)?(o.value=K(!0),a=o.kind=\"init\"):fr.ecmaVersion>=5&&\"Identifier\"===o.key.type&&(\"get\"===o.key.name||\"set\"===o.key.name)?(i=n=!0,a=o.kind=o.key.name,o.key=sr(),wr!==mt&&X(),o.value=cr(q(),!1)):X(),\"Identifier\"===o.key.type&&(Tr||n))for(var s=0;s<e.properties.length;++s){var c=e.properties[s];if(c.key.name===o.key.name){var u=a==c.kind||i&&\"init\"===c.kind||\"init\"===a&&(\"get\"===c.kind||\"set\"===c.kind);u&&!Tr&&\"init\"===a&&\"init\"===c.kind&&(u=!1),u&&t(o.key.start,\"Redefinition of property\")}}e.properties.push(o)}return j(e,\"ObjectExpression\")}function sr(){return wr===Or||wr===Dr?ar():lr(!0)}function cr(e,r){wr===Fr?e.id=lr():r?X():e.id=null,e.params=[];var n=!0;for(z(mt);!F(vt);)n?n=!1:z(bt),e.params.push(lr());var a=Rr,o=Vr;if(Rr=!0,Vr=[],e.body=H(!0),Rr=a,Vr=o,Tr||e.body.body.length&&D(e.body.body[0]))for(var i=e.id?-1:0;i<e.params.length;++i){var s=0>i?e.id:e.params[i];if((Xt(s.name)||Nt(s.name))&&t(s.start,\"Defining '\"+s.name+\"' in strict mode\"),i>=0)for(var c=0;i>c;++c)s.name===e.params[c].name&&t(s.start,\"Argument name clash in strict mode\")}return j(e,r?\"FunctionDeclaration\":\"FunctionExpression\")}function ur(e,r,t){for(var n=[],a=!0;!F(e);){if(a)a=!1;else if(z(bt),r&&fr.allowTrailingCommas&&F(e))break;t&&wr===bt?n.push(null):n.push(K(!0))}return n}function lr(e){var r=q();return r.name=wr===Fr?Cr:e&&!fr.forbidReserved&&wr.keyword||X(),Er=!1,U(),j(r,\"Identifier\")}e.version=\"0.4.0\";var fr,dr,pr,hr;e.parse=function(e,t){return dr=String(e),pr=dr.length,r(t),o(),W(fr.program)};var mr=e.defaultOptions={ecmaVersion:5,strictSemicolons:!1,allowTrailingCommas:!0,forbidReserved:!1,locations:!1,onComment:null,ranges:!1,program:null,sourceFile:null},vr=e.getLineInfo=function(e,r){for(var t=1,n=0;;){Kt.lastIndex=n;var a=Kt.exec(e);if(!(a&&a.index<r))break;++t,n=a.index+a[0].length}return{line:t,column:r-n}};e.tokenize=function(e,t){function n(e){return g(e),a.start=yr,a.end=gr,a.startLoc=xr,a.endLoc=kr,a.type=wr,a.value=Cr,a}dr=String(e),pr=dr.length,r(t),o();var a={};return n.jumpTo=function(e,r){if(br=e,fr.locations){Ar=1,Sr=Kt.lastIndex=0;for(var t;(t=Kt.exec(dr))&&t.index<e;)++Ar,Sr=t.index+t[0].length}Er=r,u()},n};var br,yr,gr,xr,kr,wr,Cr,Er,Ar,Sr,Ir,Lr,Ur,Rr,Vr,Tr,qr=[],Or={type:\"num\"},jr={type:\"regexp\"},Dr={type:\"string\"},Fr={type:\"name\"},Br={type:\"eof\"},Mr={keyword:\"break\"},zr={keyword:\"case\",beforeExpr:!0},Xr={keyword:\"catch\"},Nr={keyword:\"continue\"},Wr={keyword:\"debugger\"},Jr={keyword:\"default\"},Pr={keyword:\"do\",isLoop:!0},Hr={keyword:\"else\",beforeExpr:!0},$r={keyword:\"finally\"},_r={keyword:\"for\",isLoop:!0},Gr={keyword:\"function\"},Kr={keyword:\"if\"},Qr={keyword:\"return\",beforeExpr:!0},Yr={keyword:\"switch\"},Zr={keyword:\"throw\",beforeExpr:!0},et={keyword:\"try\"},rt={keyword:\"var\"},tt={keyword:\"while\",isLoop:!0},nt={keyword:\"with\"},at={keyword:\"new\",beforeExpr:!0},ot={keyword:\"this\"},it={keyword:\"null\",atomValue:null},st={keyword:\"true\",atomValue:!0},ct={keyword:\"false\",atomValue:!1},ut={keyword:\"in\",binop:7,beforeExpr:!0},lt={\"break\":Mr,\"case\":zr,\"catch\":Xr,\"continue\":Nr,\"debugger\":Wr,\"default\":Jr,\"do\":Pr,\"else\":Hr,\"finally\":$r,\"for\":_r,\"function\":Gr,\"if\":Kr,\"return\":Qr,\"switch\":Yr,\"throw\":Zr,\"try\":et,\"var\":rt,\"while\":tt,\"with\":nt,\"null\":it,\"true\":st,\"false\":ct,\"new\":at,\"in\":ut,\"instanceof\":{keyword:\"instanceof\",binop:7,beforeExpr:!0},\"this\":ot,\"typeof\":{keyword:\"typeof\",prefix:!0,beforeExpr:!0},\"void\":{keyword:\"void\",prefix:!0,beforeExpr:!0},\"delete\":{keyword:\"delete\",prefix:!0,beforeExpr:!0}},ft={type:\"[\",beforeExpr:!0},dt={type:\"]\"},pt={type:\"{\",beforeExpr:!0},ht={type:\"}\"},mt={type:\"(\",beforeExpr:!0},vt={type:\")\"},bt={type:\",\",beforeExpr:!0},yt={type:\";\",beforeExpr:!0},gt={type:\":\",beforeExpr:!0},xt={type:\".\"},kt={type:\"?\",beforeExpr:!0},wt={binop:10,beforeExpr:!0},Ct={isAssign:!0,beforeExpr:!0},Et={isAssign:!0,beforeExpr:!0},At={binop:9,prefix:!0,beforeExpr:!0},St={postfix:!0,prefix:!0,isUpdate:!0},It={prefix:!0,beforeExpr:!0},Lt={binop:1,beforeExpr:!0},Ut={binop:2,beforeExpr:!0},Rt={binop:3,beforeExpr:!0},Vt={binop:4,beforeExpr:!0},Tt={binop:5,beforeExpr:!0},qt={binop:6,beforeExpr:!0},Ot={binop:7,beforeExpr:!0},jt={binop:8,beforeExpr:!0},Dt={binop:10,beforeExpr:!0};e.tokTypes={bracketL:ft,bracketR:dt,braceL:pt,braceR:ht,parenL:mt,parenR:vt,comma:bt,semi:yt,colon:gt,dot:xt,question:kt,slash:wt,eq:Ct,name:Fr,eof:Br,num:Or,regexp:jr,string:Dr};for(var Ft in lt)e.tokTypes[\"_\"+Ft]=lt[Ft];var Bt,Mt=n(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\"),zt=n(\"class enum extends super const export import\"),Xt=n(\"implements interface let package private protected public static yield\"),Nt=n(\"eval arguments\"),Wt=n(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\"),Jt=/[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/,Pt=\"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\",Ht=\"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\",$t=new RegExp(\"[\"+Pt+\"]\"),_t=new RegExp(\"[\"+Pt+Ht+\"]\"),Gt=/[\\n\\r\\u2028\\u2029]/,Kt=/\\r\\n|[\\n\\r\\u2028\\u2029]/g,Qt=e.isIdentifierStart=function(e){return 65>e?36===e:91>e?!0:97>e?95===e:123>e?!0:e>=170&&$t.test(String.fromCharCode(e))},Yt=e.isIdentifierChar=function(e){return 48>e?36===e:58>e?!0:65>e?!1:91>e?!0:97>e?95===e:123>e?!0:e>=170&&_t.test(String.fromCharCode(e))},Zt={kind:\"loop\"},en={kind:\"switch\"}});\r\n\r\n\tvar binaryOperators = {\r\n\t\t'+': '__add',\r\n\t\t'-': '__subtract',\r\n\t\t'*': '__multiply',\r\n\t\t'/': '__divide',\r\n\t\t'%': '__modulo',\r\n\t\t'==': 'equals',\r\n\t\t'!=': 'equals'\r\n\t};\r\n\r\n\tvar unaryOperators = {\r\n\t\t'-': '__negate',\r\n\t\t'+': null\r\n\t};\r\n\r\n\tvar fields = Base.each(\r\n\t\t['add', 'subtract', 'multiply', 'divide', 'modulo', 'negate'],\r\n\t\tfunction(name) {\r\n\t\t\tthis['__' + name] = '#' + name;\r\n\t\t},\r\n\t\t{}\r\n\t);\r\n\tPoint.inject(fields);\r\n\tSize.inject(fields);\r\n\tColor.inject(fields);\r\n\r\n\tfunction __$__(left, operator, right) {\r\n\t\tvar handler = binaryOperators[operator];\r\n\t\tif (left && left[handler]) {\r\n\t\t\tvar res = left[handler](right);\r\n\t\t\treturn operator === '!=' ? !res : res;\r\n\t\t}\r\n\t\tswitch (operator) {\r\n\t\tcase '+': return left + right;\r\n\t\tcase '-': return left - right;\r\n\t\tcase '*': return left * right;\r\n\t\tcase '/': return left / right;\r\n\t\tcase '%': return left % right;\r\n\t\tcase '==': return left == right;\r\n\t\tcase '!=': return left != right;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction $__(operator, value) {\r\n\t\tvar handler = unaryOperators[operator];\r\n\t\tif (handler && value && value[handler])\r\n\t\t\treturn value[handler]();\r\n\t\tswitch (operator) {\r\n\t\tcase '+': return +value;\r\n\t\tcase '-': return -value;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction parse(code, options) {\r\n\t\treturn scope.acorn.parse(code, options);\r\n\t}\r\n\r\n\tfunction compile(code, url, options) {\r\n\t\tif (!code)\r\n\t\t\treturn '';\r\n\t\toptions = options || {};\r\n\t\turl = url || '';\r\n\r\n\t\tvar insertions = [];\r\n\r\n\t\tfunction getOffset(offset) {\r\n\t\t\tfor (var i = 0, l = insertions.length; i < l; i++) {\r\n\t\t\t\tvar insertion = insertions[i];\r\n\t\t\t\tif (insertion[0] >= offset)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\toffset += insertion[1];\r\n\t\t\t}\r\n\t\t\treturn offset;\r\n\t\t}\r\n\r\n\t\tfunction getCode(node) {\r\n\t\t\treturn code.substring(getOffset(node.range[0]),\r\n\t\t\t\t\tgetOffset(node.range[1]));\r\n\t\t}\r\n\r\n\t\tfunction getBetween(left, right) {\r\n\t\t\treturn code.substring(getOffset(left.range[1]),\r\n\t\t\t\t\tgetOffset(right.range[0]));\r\n\t\t}\r\n\r\n\t\tfunction replaceCode(node, str) {\r\n\t\t\tvar start = getOffset(node.range[0]),\r\n\t\t\t\tend = getOffset(node.range[1]),\r\n\t\t\t\tinsert = 0;\r\n\t\t\tfor (var i = insertions.length - 1; i >= 0; i--) {\r\n\t\t\t\tif (start > insertions[i][0]) {\r\n\t\t\t\t\tinsert = i + 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tinsertions.splice(insert, 0, [start, str.length - end + start]);\r\n\t\t\tcode = code.substring(0, start) + str + code.substring(end);\r\n\t\t}\r\n\r\n\t\tfunction walkAST(node, parent) {\r\n\t\t\tif (!node)\r\n\t\t\t\treturn;\r\n\t\t\tfor (var key in node) {\r\n\t\t\t\tif (key === 'range' || key === 'loc')\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tvar value = node[key];\r\n\t\t\t\tif (Array.isArray(value)) {\r\n\t\t\t\t\tfor (var i = 0, l = value.length; i < l; i++)\r\n\t\t\t\t\t\twalkAST(value[i], node);\r\n\t\t\t\t} else if (value && typeof value === 'object') {\r\n\t\t\t\t\twalkAST(value, node);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tswitch (node.type) {\r\n\t\t\tcase 'UnaryExpression':\r\n\t\t\t\tif (node.operator in unaryOperators\r\n\t\t\t\t\t\t&& node.argument.type !== 'Literal') {\r\n\t\t\t\t\tvar arg = getCode(node.argument);\r\n\t\t\t\t\treplaceCode(node, '$__(\"' + node.operator + '\", '\r\n\t\t\t\t\t\t\t+ arg + ')');\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'BinaryExpression':\r\n\t\t\t\tif (node.operator in binaryOperators\r\n\t\t\t\t\t\t&& node.left.type !== 'Literal') {\r\n\t\t\t\t\tvar left = getCode(node.left),\r\n\t\t\t\t\t\tright = getCode(node.right),\r\n\t\t\t\t\t\tbetween = getBetween(node.left, node.right),\r\n\t\t\t\t\t\toperator = node.operator;\r\n\t\t\t\t\treplaceCode(node, '__$__(' + left + ','\r\n\t\t\t\t\t\t\t+ between.replace(new RegExp('\\\\' + operator),\r\n\t\t\t\t\t\t\t\t'\"' + operator + '\"')\r\n\t\t\t\t\t\t\t+ ', ' + right + ')');\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'UpdateExpression':\r\n\t\t\tcase 'AssignmentExpression':\r\n\t\t\t\tvar parentType = parent && parent.type;\r\n\t\t\t\tif (!(\r\n\t\t\t\t\t\tparentType === 'ForStatement'\r\n\t\t\t\t\t\t|| parentType === 'BinaryExpression'\r\n\t\t\t\t\t\t\t&& /^[=!<>]/.test(parent.operator)\r\n\t\t\t\t\t\t|| parentType === 'MemberExpression' && parent.computed\r\n\t\t\t\t)) {\r\n\t\t\t\t\tif (node.type === 'UpdateExpression') {\r\n\t\t\t\t\t\tvar arg = getCode(node.argument),\r\n\t\t\t\t\t\t\texp = '__$__(' + arg + ', \"' + node.operator[0]\r\n\t\t\t\t\t\t\t\t\t+ '\", 1)',\r\n\t\t\t\t\t\t\tstr = arg + ' = ' + exp;\r\n\t\t\t\t\t\tif (!node.prefix\r\n\t\t\t\t\t\t\t\t&& (parentType === 'AssignmentExpression'\r\n\t\t\t\t\t\t\t\t\t|| parentType === 'VariableDeclarator')) {\r\n\t\t\t\t\t\t\tif (getCode(parent.left || parent.id) === arg)\r\n\t\t\t\t\t\t\t\tstr = exp;\r\n\t\t\t\t\t\t\tstr = arg + '; ' + str;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treplaceCode(node, str);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (/^.=$/.test(node.operator)\r\n\t\t\t\t\t\t\t\t&& node.left.type !== 'Literal') {\r\n\t\t\t\t\t\t\tvar left = getCode(node.left),\r\n\t\t\t\t\t\t\t\tright = getCode(node.right);\r\n\t\t\t\t\t\t\treplaceCode(node, left + ' = __$__(' + left + ', \"'\r\n\t\t\t\t\t\t\t\t\t+ node.operator[0] + '\", ' + right + ')');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar sourceMap = null,\r\n\t\t\tbrowser = paper.browser,\r\n\t\t\tversion = browser.versionNumber,\r\n\t\t\tlineBreaks = /\\r\\n|\\n|\\r/mg;\r\n\t\tif (browser.chrome && version >= 30\r\n\t\t\t\t|| browser.webkit && version >= 537.76\r\n\t\t\t\t|| browser.firefox && version >= 23) {\r\n\t\t\tvar offset = 0;\r\n\t\t\tif (window.location.href.indexOf(url) === 0) {\r\n\t\t\t\tvar html = document.getElementsByTagName('html')[0].innerHTML;\r\n\t\t\t\toffset = html.substr(0, html.indexOf(code) + 1).match(\r\n\t\t\t\t\t\tlineBreaks).length + 1;\r\n\t\t\t}\r\n\t\t\tvar mappings = ['AAAA'];\r\n\t\t\tmappings.length = (code.match(lineBreaks) || []).length + 1 + offset;\r\n\t\t\tsourceMap = {\r\n\t\t\t\tversion: 3,\r\n\t\t\t\tfile: url,\r\n\t\t\t\tnames:[],\r\n\t\t\t\tmappings: mappings.join(';AACA'),\r\n\t\t\t\tsourceRoot: '',\r\n\t\t\t\tsources: [url]\r\n\t\t\t};\r\n\t\t\tvar source = options.source || !url && code;\r\n\t\t\tif (source)\r\n\t\t\t\tsourceMap.sourcesContent = [source];\r\n\t\t}\r\n\t\twalkAST(parse(code, { ranges: true }));\r\n\t\tif (sourceMap) {\r\n\t\t\tcode = new Array(offset + 1).join('\\n') + code\r\n\t\t\t\t\t+ \"\\n//# sourceMappingURL=data:application/json;base64,\"\r\n\t\t\t\t\t+ (btoa(unescape(encodeURIComponent(\r\n\t\t\t\t\t\tJSON.stringify(sourceMap)))))\r\n\t\t\t\t\t+ \"\\n//# sourceURL=\" + (url || 'paperscript');\r\n\t\t}\r\n\t\treturn code;\r\n\t}\r\n\r\n\tfunction execute(code, scope, url, options) {\r\n\t\tpaper = scope;\r\n\t\tvar view = scope.getView(),\r\n\t\t\ttool = /\\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\\b/.test(code)\r\n\t\t\t\t\t? new Tool()\r\n\t\t\t\t\t: null,\r\n\t\t\ttoolHandlers = tool ? tool._events : [],\r\n\t\t\thandlers = ['onFrame', 'onResize'].concat(toolHandlers),\r\n\t\t\tparams = [],\r\n\t\t\targs = [],\r\n\t\t\tfunc;\r\n\t\tcode = compile(code, url, options);\r\n\t\tfunction expose(scope, hidden) {\r\n\t\t\tfor (var key in scope) {\r\n\t\t\t\tif ((hidden || !/^_/.test(key)) && new RegExp('([\\\\b\\\\s\\\\W]|^)'\r\n\t\t\t\t\t\t+ key.replace(/\\$/g, '\\\\$') + '\\\\b').test(code)) {\r\n\t\t\t\t\tparams.push(key);\r\n\t\t\t\t\targs.push(scope[key]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\texpose({ __$__: __$__, $__: $__, paper: scope, view: view, tool: tool },\r\n\t\t\t\ttrue);\r\n\t\texpose(scope);\r\n\t\thandlers = Base.each(handlers, function(key) {\r\n\t\t\tif (new RegExp('\\\\s+' + key + '\\\\b').test(code)) {\r\n\t\t\t\tparams.push(key);\r\n\t\t\t\tthis.push(key + ': ' + key);\r\n\t\t\t}\r\n\t\t}, []).join(', ');\r\n\t\tif (handlers)\r\n\t\t\tcode += '\\nreturn { ' + handlers + ' };';\r\n\t\tvar browser = paper.browser;\r\n\t\tif (browser.chrome || browser.firefox) {\r\n\t\t\tvar script = document.createElement('script'),\r\n\t\t\t\thead = document.head || document.getElementsByTagName('head')[0];\r\n\t\t\tif (browser.firefox)\r\n\t\t\t\tcode = '\\n' + code;\r\n\t\t\tscript.appendChild(document.createTextNode(\r\n\t\t\t\t'paper._execute = function(' + params + ') {' + code + '\\n}'\r\n\t\t\t));\r\n\t\t\thead.appendChild(script);\r\n\t\t\tfunc = paper._execute;\r\n\t\t\tdelete paper._execute;\r\n\t\t\thead.removeChild(script);\r\n\t\t} else {\r\n\t\t\tfunc = Function(params, code);\r\n\t\t}\r\n\t\tvar res = func.apply(scope, args) || {};\r\n\t\tBase.each(toolHandlers, function(key) {\r\n\t\t\tvar value = res[key];\r\n\t\t\tif (value)\r\n\t\t\t\ttool[key] = value;\r\n\t\t});\r\n\t\tif (view) {\r\n\t\t\tif (res.onResize)\r\n\t\t\t\tview.setOnResize(res.onResize);\r\n\t\t\tview.emit('resize', {\r\n\t\t\t\tsize: view.size,\r\n\t\t\t\tdelta: new Point()\r\n\t\t\t});\r\n\t\t\tif (res.onFrame)\r\n\t\t\t\tview.setOnFrame(res.onFrame);\r\n\t\t\tview.update();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction loadScript(script) {\r\n\t\tif (/^text\\/(?:x-|)paperscript$/.test(script.type)\r\n\t\t\t\t&& PaperScope.getAttribute(script, 'ignore') !== 'true') {\r\n\t\t\tvar canvasId = PaperScope.getAttribute(script, 'canvas'),\r\n\t\t\t\tcanvas = document.getElementById(canvasId),\r\n\t\t\t\tsrc = script.src || script.getAttribute('data-src'),\r\n\t\t\t\tasync = PaperScope.hasAttribute(script, 'async'),\r\n\t\t\t\tscopeAttribute = 'data-paper-scope';\r\n\t\t\tif (!canvas)\r\n\t\t\t\tthrow new Error('Unable to find canvas with id \"'\r\n\t\t\t\t\t\t+ canvasId + '\"');\r\n\t\t\tvar scope = PaperScope.get(canvas.getAttribute(scopeAttribute))\r\n\t\t\t\t\t\t|| new PaperScope().setup(canvas);\r\n\t\t\tcanvas.setAttribute(scopeAttribute, scope._id);\r\n\t\t\tif (src) {\r\n\t\t\t\tHttp.request('get', src, function(code) {\r\n\t\t\t\t\texecute(code, scope, src);\r\n\t\t\t\t}, async);\r\n\t\t\t} else {\r\n\t\t\t\texecute(script.innerHTML, scope, script.baseURI);\r\n\t\t\t}\r\n\t\t\tscript.setAttribute('data-paper-ignore', 'true');\r\n\t\t\treturn scope;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction loadAll() {\r\n\t\tBase.each(document.getElementsByTagName('script'), loadScript);\r\n\t}\r\n\r\n\tfunction load(script) {\r\n\t\treturn script ? loadScript(script) : loadAll();\r\n\t}\r\n\r\n\tif (document.readyState === 'complete') {\r\n\t\tsetTimeout(loadAll);\r\n\t} else {\r\n\t\tDomEvent.add(window, { load: loadAll });\r\n\t}\r\n\r\n\treturn {\r\n\t\tcompile: compile,\r\n\t\texecute: execute,\r\n\t\tload: load,\r\n\t\tparse: parse\r\n\t};\r\n\r\n}).call(this);\r\n\r\npaper = new (PaperScope.inject(Base.exports, {\r\n\tenumerable: true,\r\n\tBase: Base,\r\n\tNumerical: Numerical,\r\n\tKey: Key\r\n}))();\r\n\r\nif (typeof define === 'function' && define.amd) {\r\n\tdefine('paper', paper);\r\n} else if (typeof module === 'object' && module) {\r\n\tmodule.exports = paper;\r\n}\r\n\r\nreturn paper;\r\n};\r\n";
},681:function(t,n){t.exports='/*jslint vars: true, nomen: true, plusplus: true, continue:true, forin:true */\r\n/*global Node, BoundsNode */\r\n\r\n/*\r\n The MIT License\r\n\r\n Copyright (c) 2011 Mike Chambers\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the "Software"), to deal\r\n in the Software without restriction, including without limitation the rights\r\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n copies of the Software, and to permit persons to whom the Software is\r\n furnished to do so, subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n */\r\n\r\n\r\n/**\r\n * A QuadTree implementation in JavaScript, a 2d spatial subdivision algorithm.\r\n * @module QuadTree\r\n **/\r\n\r\n(function (window) {\r\n    "use strict";\r\n\r\n    /****************** QuadTree ****************/\r\n\r\n    /**\r\n     * QuadTree data structure.\r\n     * @class QuadTree\r\n     * @constructor\r\n     * @param {Object} An object representing the bounds of the top level of the QuadTree. The object\r\n     * should contain the following properties : x, y, width, height\r\n     * @param {Boolean} pointQuad Whether the QuadTree will contain points (true), or items with bounds\r\n     * (width / height)(false). Default value is false.\r\n     * @param {Number} maxDepth The maximum number of levels that the quadtree will create. Default is 4.\r\n     * @param {Number} maxChildren The maximum number of children that a node can contain before it is split into sub-nodes.\r\n     **/\r\n    function QuadTree(bounds, pointQuad, maxDepth, maxChildren) {\r\n        var node;\r\n        if (pointQuad) {\r\n\r\n            node = new Node(bounds, 0, maxDepth, maxChildren);\r\n        } else {\r\n            node = new BoundsNode(bounds, 0, maxDepth, maxChildren);\r\n        }\r\n\r\n        this.root = node;\r\n    }\r\n\r\n    /**\r\n     * The root node of the QuadTree which covers the entire area being segmented.\r\n     * @property root\r\n     * @type Node\r\n     **/\r\n    QuadTree.prototype.root = null;\r\n\r\n\r\n    /**\r\n     * Inserts an item into the QuadTree.\r\n     * @method insert\r\n     * @param {Object|Array} item The item or Array of items to be inserted into the QuadTree. The item should expose x, y\r\n     * properties that represents its position in 2D space.\r\n     **/\r\n    QuadTree.prototype.insert = function (item) {\r\n        if (item instanceof Array) {\r\n            var len = item.length;\r\n\r\n            var i;\r\n            for (i = 0; i < len; i++) {\r\n                this.root.insert(item[i]);\r\n            }\r\n        } else {\r\n            this.root.insert(item);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Clears all nodes and children from the QuadTree\r\n     * @method clear\r\n     **/\r\n    QuadTree.prototype.clear = function () {\r\n        this.root.clear();\r\n    };\r\n\r\n    /**\r\n     * Retrieves all items / points in the same node as the specified item / point. If the specified item\r\n     * overlaps the bounds of a node, then all children in both nodes will be returned.\r\n     * @method retrieve\r\n     * @param {Object} item An object representing a 2D coordinate point (with x, y properties), or a shape\r\n     * with dimensions (x, y, width, height) properties.\r\n     **/\r\n    QuadTree.prototype.retrieve = function (item) {\r\n        //get a copy of the array of items\r\n        var out = this.root.retrieve(item).slice(0);\r\n        return out;\r\n    };\r\n\r\n    /************** Node ********************/\r\n\r\n\r\n    function Node(bounds, depth, maxDepth, maxChildren) {\r\n        this._bounds = bounds;\r\n        this.children = [];\r\n        this.nodes = [];\r\n\r\n        if (maxChildren) {\r\n            this._maxChildren = maxChildren;\r\n        }\r\n\r\n        if (maxDepth) {\r\n            this._maxDepth = maxDepth;\r\n        }\r\n\r\n        if (depth) {\r\n            this._depth = depth;\r\n        }\r\n    }\r\n\r\n    //subnodes\r\n    Node.prototype.nodes = null;\r\n    Node.prototype._classConstructor = Node;\r\n\r\n    //children contained directly in the node\r\n    Node.prototype.children = null;\r\n    Node.prototype._bounds = null;\r\n\r\n    //read only\r\n    Node.prototype._depth = 0;\r\n\r\n    Node.prototype._maxChildren = 4;\r\n    Node.prototype._maxDepth = 4;\r\n\r\n    Node.TOP_LEFT = 0;\r\n    Node.TOP_RIGHT = 1;\r\n    Node.BOTTOM_LEFT = 2;\r\n    Node.BOTTOM_RIGHT = 3;\r\n\r\n\r\n    Node.prototype.insert = function (item) {\r\n        if (this.nodes.length) {\r\n            var index = this._findIndex(item);\r\n\r\n            this.nodes[index].insert(item);\r\n\r\n            return;\r\n        }\r\n\r\n        this.children.push(item);\r\n\r\n        var len = this.children.length;\r\n        if (!(this._depth >= this._maxDepth) &&\r\n            len > this._maxChildren) {\r\n\r\n            this.subdivide();\r\n\r\n            var i;\r\n            for (i = 0; i < len; i++) {\r\n                this.insert(this.children[i]);\r\n            }\r\n\r\n            this.children.length = 0;\r\n        }\r\n    };\r\n\r\n    Node.prototype.retrieve = function (item) {\r\n        if (this.nodes.length) {\r\n            var index = this._findIndex(item);\r\n\r\n            return this.nodes[index].retrieve(item);\r\n        }\r\n\r\n        return this.children;\r\n    };\r\n\r\n    Node.prototype._findIndex = function (item) {\r\n        var b = this._bounds;\r\n        var left = (item.x > b.x + b.width / 2) ? false : true;\r\n        var top = (item.y > b.y + b.height / 2) ? false : true;\r\n\r\n        //top left\r\n        var index = Node.TOP_LEFT;\r\n        if (left) {\r\n            //left side\r\n            if (!top) {\r\n                //bottom left\r\n                index = Node.BOTTOM_LEFT;\r\n            }\r\n        } else {\r\n            //right side\r\n            if (top) {\r\n                //top right\r\n                index = Node.TOP_RIGHT;\r\n            } else {\r\n                //bottom right\r\n                index = Node.BOTTOM_RIGHT;\r\n            }\r\n        }\r\n\r\n        return index;\r\n    };\r\n\r\n\r\n    Node.prototype.subdivide = function () {\r\n        var depth = this._depth + 1;\r\n\r\n        var bx = this._bounds.x;\r\n        var by = this._bounds.y;\r\n\r\n        //floor the values\r\n        var b_w_h = (this._bounds.width / 2); //todo: Math.floor?\r\n        var b_h_h = (this._bounds.height / 2);\r\n        var bx_b_w_h = bx + b_w_h;\r\n        var by_b_h_h = by + b_h_h;\r\n\r\n        //top left\r\n        this.nodes[Node.TOP_LEFT] = new this._classConstructor({\r\n                x: bx,\r\n                y: by,\r\n                width: b_w_h,\r\n                height: b_h_h\r\n            },\r\n            depth, this._maxDepth, this._maxChildren);\r\n\r\n        //top right\r\n        this.nodes[Node.TOP_RIGHT] = new this._classConstructor({\r\n                x: bx_b_w_h,\r\n                y: by,\r\n                width: b_w_h,\r\n                height: b_h_h\r\n            },\r\n            depth, this._maxDepth, this._maxChildren);\r\n\r\n        //bottom left\r\n        this.nodes[Node.BOTTOM_LEFT] = new this._classConstructor({\r\n                x: bx,\r\n                y: by_b_h_h,\r\n                width: b_w_h,\r\n                height: b_h_h\r\n            },\r\n            depth, this._maxDepth, this._maxChildren);\r\n\r\n\r\n        //bottom right\r\n        this.nodes[Node.BOTTOM_RIGHT] = new this._classConstructor({\r\n                x: bx_b_w_h,\r\n                y: by_b_h_h,\r\n                width: b_w_h,\r\n                height: b_h_h\r\n            },\r\n            depth, this._maxDepth, this._maxChildren);\r\n    };\r\n\r\n    Node.prototype.clear = function () {\r\n        this.children.length = 0;\r\n\r\n        var len = this.nodes.length;\r\n\r\n        var i;\r\n        for (i = 0; i < len; i++) {\r\n            this.nodes[i].clear();\r\n        }\r\n\r\n        this.nodes.length = 0;\r\n    };\r\n\r\n\r\n    /******************** BoundsQuadTree ****************/\r\n\r\n    function BoundsNode(bounds, depth, maxChildren, maxDepth) {\r\n        Node.call(this, bounds, depth, maxChildren, maxDepth);\r\n        this._stuckChildren = [];\r\n    }\r\n\r\n    BoundsNode.prototype = new Node();\r\n    BoundsNode.prototype._classConstructor = BoundsNode;\r\n    BoundsNode.prototype._stuckChildren = null;\r\n\r\n    //we use this to collect and conctenate items being retrieved. This way\r\n    //we dont have to continuously create new Array instances.\r\n    //Note, when returned from QuadTree.retrieve, we then copy the array\r\n    BoundsNode.prototype._out = [];\r\n\r\n    BoundsNode.prototype.insert = function (item) {\r\n        if (this.nodes.length) {\r\n            var index = this._findIndex(item);\r\n            var node = this.nodes[index];\r\n\r\n            //todo: make _bounds bounds\r\n            if (item.x >= node._bounds.x &&\r\n                item.x + item.width <= node._bounds.x + node._bounds.width &&\r\n                item.y >= node._bounds.y &&\r\n                item.y + item.height <= node._bounds.y + node._bounds.height) {\r\n\r\n                this.nodes[index].insert(item);\r\n\r\n            } else {\r\n                this._stuckChildren.push(item);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        this.children.push(item);\r\n\r\n        var len = this.children.length;\r\n\r\n        if (!(this._depth >= this._maxDepth) &&\r\n            len > this._maxChildren) {\r\n\r\n            this.subdivide();\r\n\r\n            var i;\r\n            for (i = 0; i < len; i++) {\r\n                this.insert(this.children[i]);\r\n            }\r\n\r\n            this.children.length = 0;\r\n        }\r\n    };\r\n\r\n    BoundsNode.prototype.getChildren = function () {\r\n        return this.children.concat(this._stuckChildren);\r\n    };\r\n\r\n    BoundsNode.prototype.retrieve = function (item) {\r\n        var out = this._out;\r\n        out.length = 0;\r\n        if (this.nodes.length) {\r\n            var index = this._findIndex(item);\r\n            var node = this.nodes[index];\r\n\r\n            if (item.x >= node._bounds.x &&\r\n                item.x + item.width <= node._bounds.x + node._bounds.width &&\r\n                item.y >= node._bounds.y &&\r\n                item.y + item.height <= node._bounds.y + node._bounds.height) {\r\n\r\n                out.push.apply(out, this.nodes[index].retrieve(item));\r\n            } else {\r\n                //Part of the item are overlapping multiple child nodes. For each of the overlapping nodes, return all containing objects.\r\n\r\n                if (item.x <= this.nodes[Node.TOP_RIGHT]._bounds.x) {\r\n                    if (item.y <= this.nodes[Node.BOTTOM_LEFT]._bounds.y) {\r\n                        out.push.apply(out, this.nodes[Node.TOP_LEFT].getAllContent());\r\n                    }\r\n\r\n                    if (item.y + item.height > this.nodes[Node.BOTTOM_LEFT]._bounds.y) {\r\n                        out.push.apply(out, this.nodes[Node.BOTTOM_LEFT].getAllContent());\r\n                    }\r\n                }\r\n\r\n                if (item.x + item.width > this.nodes[Node.TOP_RIGHT]._bounds.x) {//position+width bigger than middle x\r\n                    if (item.y <= this.nodes[Node.BOTTOM_RIGHT]._bounds.y) {\r\n                        out.push.apply(out, this.nodes[Node.TOP_RIGHT].getAllContent());\r\n                    }\r\n\r\n                    if (item.y + item.height > this.nodes[Node.BOTTOM_RIGHT]._bounds.y) {\r\n                        out.push.apply(out, this.nodes[Node.BOTTOM_RIGHT].getAllContent());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        out.push.apply(out, this._stuckChildren);\r\n        out.push.apply(out, this.children);\r\n\r\n        return out;\r\n    };\r\n\r\n    //Returns all contents of node.\r\n    BoundsNode.prototype.getAllContent = function () {\r\n        var out = this._out;\r\n        if (this.nodes.length) {\r\n\r\n            var i;\r\n            for (i = 0; i < this.nodes.length; i++) {\r\n                this.nodes[i].getAllContent();\r\n            }\r\n        }\r\n        out.push.apply(out, this._stuckChildren);\r\n        out.push.apply(out, this.children);\r\n        return out;\r\n    };\r\n\r\n    BoundsNode.prototype.clear = function () {\r\n\r\n        this._stuckChildren.length = 0;\r\n\r\n        //array\r\n        this.children.length = 0;\r\n\r\n        var len = this.nodes.length;\r\n\r\n        if (!len) {\r\n            return;\r\n        }\r\n\r\n        var i;\r\n        for (i = 0; i < len; i++) {\r\n            this.nodes[i].clear();\r\n        }\r\n\r\n        //array\r\n        this.nodes.length = 0;\r\n\r\n        //we could call the super clear function but for now, im just going to inline it\r\n        //call the hidden super.clear, and make sure its called with this = this instance\r\n        //Object.getPrototypeOf(BoundsNode.prototype).clear.call(this);\r\n    };\r\n\r\n    window.QuadTree = QuadTree;\r\n\r\n}(window));\r\n'},682:function(t,n){t.exports="/*!\r\n Author: Raymond Hill (rhill@raymondhill.net)\r\n File: rhill-voronoi-core.js\r\n Version: 0.96\r\n Date: May 26, 2011\r\n Description: This is my personal Javascript implementation of\r\n Steven Fortune's algorithm to compute Voronoi diagrams.\r\n\r\n Copyright (C) 2010,2011 Raymond Hill\r\n https://github.com/gorhill/Javascript-Voronoi\r\n\r\n Licensed under The MIT License\r\n http://en.wikipedia.org/wiki/MIT_License\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights\r\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n copies of the Software, and to permit persons to whom the Software is\r\n furnished to do so, subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n\r\n *****\r\n\r\n Portions of this software use, depend, or was inspired by the work of:\r\n\r\n \"Fortune's algorithm\" by Steven J. Fortune: For his clever\r\n algorithm to compute Voronoi diagrams.\r\n http://ect.bell-labs.com/who/sjf/\r\n\r\n \"The Liang-Barsky line clipping algorithm in a nutshell!\" by Daniel White,\r\n to efficiently clip a line within a rectangle.\r\n http://www.skytopia.com/project/articles/compsci/clipping.html\r\n\r\n \"rbtree\" by Franck Bui-Huu\r\n https://github.com/fbuihuu/libtree/blob/master/rb.c\r\n I ported to Javascript the C code of a Red-Black tree implementation by\r\n Franck Bui-Huu, and further altered the code for Javascript efficiency\r\n and to very specifically fit the purpose of holding the beachline (the key\r\n is a variable range rather than an unmutable data point), and unused\r\n code paths have been removed. Each node in the tree is actually a beach\r\n section on the beachline. Using a tree structure for the beachline remove\r\n the need to lookup the beach section in the array at removal time, as\r\n now a circle event can safely hold a reference to its associated\r\n beach section (thus findDeletionPoint() is no longer needed). This\r\n finally take care of nagging finite arithmetic precision issues arising\r\n at lookup time, such that epsilon could be brought down to 1e-9 (from 1e-4).\r\n rhill 2011-05-27: added a 'previous' and 'next' members which keeps track\r\n of previous and next nodes, and remove the need for Beachsection.getPrevious()\r\n and Beachsection.getNext().\r\n\r\n *****\r\n\r\n History:\r\n\r\n 0.96 (26 May 2011):\r\n Returned diagram.cells is now an array, whereas the index of a cell\r\n matches the index of its associated site in the array of sites passed\r\n to Voronoi.compute(). This allowed some gain in performance. The\r\n 'voronoiId' member is still used internally by the Voronoi object.\r\n The Voronoi.Cells object is no longer necessary and has been removed.\r\n\r\n 0.95 (19 May 2011):\r\n No longer using Javascript array to keep track of the beach sections of\r\n the beachline, now using Red-Black tree.\r\n\r\n The move to a binary tree was unavoidable, as I ran into finite precision\r\n arithmetic problems when I started to use sites with fractional values.\r\n The problem arose when the code had to find the arc associated with a\r\n triggered Fortune circle event: the collapsing arc was not always properly\r\n found due to finite precision arithmetic-related errors. Using a tree structure\r\n eliminate the need to look-up a beachsection in the array structure\r\n (findDeletionPoint()), and allowed to bring back epsilon down to 1e-9.\r\n\r\n 0.91(21 September 2010):\r\n Lower epsilon from 1e-5 to 1e-4, to fix problem reported at\r\n http://www.raymondhill.net/blog/?p=9#comment-1414\r\n\r\n 0.90 (21 September 2010):\r\n First version.\r\n\r\n *****\r\n\r\n Usage:\r\n\r\n var sites = [{x:300,y:300}, {x:100,y:100}, {x:200,y:500}, {x:250,y:450}, {x:600,y:150}];\r\n // xl, xr means x left, x right\r\n // yt, yb means y top, y bottom\r\n var bbox = {xl:0, xr:800, yt:0, yb:600};\r\n var voronoi = new Voronoi();\r\n // pass an object which exhibits xl, xr, yt, yb properties. The bounding\r\n // box will be used to connect unbound edges, and to close open cells\r\n result = voronoi.compute(sites, bbox);\r\n // render, further analyze, etc.\r\n\r\n Return value:\r\n An object with the following properties:\r\n\r\n result.edges = an array of unordered, unique Voronoi.Edge objects making up the Voronoi diagram.\r\n result.cells = an array of Voronoi.Cell object making up the Voronoi diagram. A Cell object\r\n might have an empty array of halfedges, meaning no Voronoi cell could be computed for a\r\n particular cell.\r\n result.execTime = the time it took to compute the Voronoi diagram, in milliseconds.\r\n\r\n Voronoi.Edge object:\r\n lSite: the Voronoi site object at the left of this Voronoi.Edge object.\r\n rSite: the Voronoi site object at the right of this Voronoi.Edge object (can be null).\r\n va: an object with an 'x' and a 'y' property defining the start point\r\n (relative to the Voronoi site on the left) of this Voronoi.Edge object.\r\n vb: an object with an 'x' and a 'y' property defining the end point\r\n (relative to Voronoi site on the left) of this Voronoi.Edge object.\r\n\r\n For edges which are used to close open cells (using the supplied bounding box), the\r\n rSite property will be null.\r\n\r\n Voronoi.Cell object:\r\n site: the Voronoi site object associated with the Voronoi cell.\r\n halfedges: an array of Voronoi.Halfedge objects, ordered counterclockwise, defining the\r\n polygon for this Voronoi cell.\r\n\r\n Voronoi.Halfedge object:\r\n site: the Voronoi site object owning this Voronoi.Halfedge object.\r\n edge: a reference to the unique Voronoi.Edge object underlying this Voronoi.Halfedge object.\r\n getStartpoint(): a method returning an object with an 'x' and a 'y' property for\r\n the start point of this halfedge. Keep in mind halfedges are always countercockwise.\r\n getEndpoint(): a method returning an object with an 'x' and a 'y' property for\r\n the end point of this halfedge. Keep in mind halfedges are always countercockwise.\r\n\r\n TODO: Identify opportunities for performance improvement.\r\n TODO: Let the user close the Voronoi cells, do not do it automatically. Not only let\r\n him close the cells, but also allow him to close more than once using a different\r\n bounding box for the same Voronoi diagram.\r\n */\r\n\r\n/*global Math */\r\n\r\nfunction Voronoi() {\r\n    this.edges = null;\r\n    this.cells = null;\r\n    this.beachsectionJunkyard = [];\r\n    this.circleEventJunkyard = [];\r\n}\r\n\r\nVoronoi.prototype.reset = function() {\r\n    if (!this.beachline) {\r\n        this.beachline = new this.RBTree();\r\n    }\r\n    // Move leftover beachsections to the beachsection junkyard.\r\n    if (this.beachline.root) {\r\n        var beachsection = this.beachline.getFirst(this.beachline.root);\r\n        while (beachsection) {\r\n            this.beachsectionJunkyard.push(beachsection); // mark for reuse\r\n            beachsection = beachsection.rbNext;\r\n        }\r\n    }\r\n    this.beachline.root = null;\r\n    if (!this.circleEvents) {\r\n        this.circleEvents = new this.RBTree();\r\n    }\r\n    this.circleEvents.root = this.firstCircleEvent = null;\r\n    this.edges = [];\r\n    this.cells = [];\r\n};\r\n\r\nVoronoi.prototype.sqrt = Math.sqrt;\r\nVoronoi.prototype.abs = Math.abs;\r\nVoronoi.prototype.EPSILON = 1e-9;\r\nVoronoi.prototype.equalWithEpsilon = function(a,b){return this.abs(a-b)<1e-9;};\r\nVoronoi.prototype.greaterThanWithEpsilon = function(a,b){return a-b>1e-9;};\r\nVoronoi.prototype.greaterThanOrEqualWithEpsilon = function(a,b){return b-a<1e-9;};\r\nVoronoi.prototype.lessThanWithEpsilon = function(a,b){return b-a>1e-9;};\r\nVoronoi.prototype.lessThanOrEqualWithEpsilon = function(a,b){return a-b<1e-9;};\r\n\r\n// ---------------------------------------------------------------------------\r\n// Red-Black tree code (based on C version of \"rbtree\" by Franck Bui-Huu\r\n// https://github.com/fbuihuu/libtree/blob/master/rb.c\r\n\r\nVoronoi.prototype.RBTree = function() {\r\n    this.root = null;\r\n};\r\n\r\nVoronoi.prototype.RBTree.prototype.rbInsertSuccessor = function(node, successor) {\r\n    var parent;\r\n    if (node) {\r\n        // >>> rhill 2011-05-27: Performance: cache previous/next nodes\r\n        successor.rbPrevious = node;\r\n        successor.rbNext = node.rbNext;\r\n        if (node.rbNext) {\r\n            node.rbNext.rbPrevious = successor;\r\n        }\r\n        node.rbNext = successor;\r\n        // <<<\r\n        if (node.rbRight) {\r\n            // in-place expansion of node.rbRight.getFirst();\r\n            node = node.rbRight;\r\n            while (node.rbLeft) {node = node.rbLeft;}\r\n            node.rbLeft = successor;\r\n        }\r\n        else {\r\n            node.rbRight = successor;\r\n        }\r\n        parent = node;\r\n    }\r\n    // rhill 2011-06-07: if node is null, successor must be inserted\r\n    // to the left-most part of the tree\r\n    else if (this.root) {\r\n        node = this.getFirst(this.root);\r\n        // >>> Performance: cache previous/next nodes\r\n        successor.rbPrevious = null;\r\n        successor.rbNext = node;\r\n        node.rbPrevious = successor;\r\n        // <<<\r\n        node.rbLeft = successor;\r\n        parent = node;\r\n    }\r\n    else {\r\n        // >>> Performance: cache previous/next nodes\r\n        successor.rbPrevious = successor.rbNext = null;\r\n        // <<<\r\n        this.root = successor;\r\n        parent = null;\r\n    }\r\n    successor.rbLeft = successor.rbRight = null;\r\n    successor.rbParent = parent;\r\n    successor.rbRed = true;\r\n    // Fixup the modified tree by recoloring nodes and performing\r\n    // rotations (2 at most) hence the red-black tree properties are\r\n    // preserved.\r\n    var grandpa, uncle;\r\n    node = successor;\r\n    while (parent && parent.rbRed) {\r\n        grandpa = parent.rbParent;\r\n        if (parent === grandpa.rbLeft) {\r\n            uncle = grandpa.rbRight;\r\n            if (uncle && uncle.rbRed) {\r\n                parent.rbRed = uncle.rbRed = false;\r\n                grandpa.rbRed = true;\r\n                node = grandpa;\r\n            }\r\n            else {\r\n                if (node === parent.rbRight) {\r\n                    this.rbRotateLeft(parent);\r\n                    node = parent;\r\n                    parent = node.rbParent;\r\n                }\r\n                parent.rbRed = false;\r\n                grandpa.rbRed = true;\r\n                this.rbRotateRight(grandpa);\r\n            }\r\n        }\r\n        else {\r\n            uncle = grandpa.rbLeft;\r\n            if (uncle && uncle.rbRed) {\r\n                parent.rbRed = uncle.rbRed = false;\r\n                grandpa.rbRed = true;\r\n                node = grandpa;\r\n            }\r\n            else {\r\n                if (node === parent.rbLeft) {\r\n                    this.rbRotateRight(parent);\r\n                    node = parent;\r\n                    parent = node.rbParent;\r\n                }\r\n                parent.rbRed = false;\r\n                grandpa.rbRed = true;\r\n                this.rbRotateLeft(grandpa);\r\n            }\r\n        }\r\n        parent = node.rbParent;\r\n    }\r\n    this.root.rbRed = false;\r\n};\r\n\r\nVoronoi.prototype.RBTree.prototype.rbRemoveNode = function(node) {\r\n    // >>> rhill 2011-05-27: Performance: cache previous/next nodes\r\n    if (node.rbNext) {\r\n        node.rbNext.rbPrevious = node.rbPrevious;\r\n    }\r\n    if (node.rbPrevious) {\r\n        node.rbPrevious.rbNext = node.rbNext;\r\n    }\r\n    node.rbNext = node.rbPrevious = null;\r\n    // <<<\r\n    var parent = node.rbParent,\r\n        left = node.rbLeft,\r\n        right = node.rbRight,\r\n        next;\r\n    if (!left) {\r\n        next = right;\r\n    }\r\n    else if (!right) {\r\n        next = left;\r\n    }\r\n    else {\r\n        next = this.getFirst(right);\r\n    }\r\n    if (parent) {\r\n        if (parent.rbLeft === node) {\r\n            parent.rbLeft = next;\r\n        }\r\n        else {\r\n            parent.rbRight = next;\r\n        }\r\n    }\r\n    else {\r\n        this.root = next;\r\n    }\r\n    // enforce red-black rules\r\n    var isRed;\r\n    if (left && right) {\r\n        isRed = next.rbRed;\r\n        next.rbRed = node.rbRed;\r\n        next.rbLeft = left;\r\n        left.rbParent = next;\r\n        if (next !== right) {\r\n            parent = next.rbParent;\r\n            next.rbParent = node.rbParent;\r\n            node = next.rbRight;\r\n            parent.rbLeft = node;\r\n            next.rbRight = right;\r\n            right.rbParent = next;\r\n        }\r\n        else {\r\n            next.rbParent = parent;\r\n            parent = next;\r\n            node = next.rbRight;\r\n        }\r\n    }\r\n    else {\r\n        isRed = node.rbRed;\r\n        node = next;\r\n    }\r\n    // 'node' is now the sole successor's child and 'parent' its\r\n    // new parent (since the successor can have been moved)\r\n    if (node) {\r\n        node.rbParent = parent;\r\n    }\r\n    // the 'easy' cases\r\n    if (isRed) {return;}\r\n    if (node && node.rbRed) {\r\n        node.rbRed = false;\r\n        return;\r\n    }\r\n    // the other cases\r\n    var sibling;\r\n    do {\r\n        if (node === this.root) {\r\n            break;\r\n        }\r\n        if (node === parent.rbLeft) {\r\n            sibling = parent.rbRight;\r\n            if (sibling.rbRed) {\r\n                sibling.rbRed = false;\r\n                parent.rbRed = true;\r\n                this.rbRotateLeft(parent);\r\n                sibling = parent.rbRight;\r\n            }\r\n            if ((sibling.rbLeft && sibling.rbLeft.rbRed) || (sibling.rbRight && sibling.rbRight.rbRed)) {\r\n                if (!sibling.rbRight || !sibling.rbRight.rbRed) {\r\n                    sibling.rbLeft.rbRed = false;\r\n                    sibling.rbRed = true;\r\n                    this.rbRotateRight(sibling);\r\n                    sibling = parent.rbRight;\r\n                }\r\n                sibling.rbRed = parent.rbRed;\r\n                parent.rbRed = sibling.rbRight.rbRed = false;\r\n                this.rbRotateLeft(parent);\r\n                node = this.root;\r\n                break;\r\n            }\r\n        }\r\n        else {\r\n            sibling = parent.rbLeft;\r\n            if (sibling.rbRed) {\r\n                sibling.rbRed = false;\r\n                parent.rbRed = true;\r\n                this.rbRotateRight(parent);\r\n                sibling = parent.rbLeft;\r\n            }\r\n            if ((sibling.rbLeft && sibling.rbLeft.rbRed) || (sibling.rbRight && sibling.rbRight.rbRed)) {\r\n                if (!sibling.rbLeft || !sibling.rbLeft.rbRed) {\r\n                    sibling.rbRight.rbRed = false;\r\n                    sibling.rbRed = true;\r\n                    this.rbRotateLeft(sibling);\r\n                    sibling = parent.rbLeft;\r\n                }\r\n                sibling.rbRed = parent.rbRed;\r\n                parent.rbRed = sibling.rbLeft.rbRed = false;\r\n                this.rbRotateRight(parent);\r\n                node = this.root;\r\n                break;\r\n            }\r\n        }\r\n        sibling.rbRed = true;\r\n        node = parent;\r\n        parent = parent.rbParent;\r\n    } while (!node.rbRed);\r\n    if (node) {node.rbRed = false;}\r\n};\r\n\r\nVoronoi.prototype.RBTree.prototype.rbRotateLeft = function(node) {\r\n    var p = node,\r\n        q = node.rbRight, // can't be null\r\n        parent = p.rbParent;\r\n    if (parent) {\r\n        if (parent.rbLeft === p) {\r\n            parent.rbLeft = q;\r\n        }\r\n        else {\r\n            parent.rbRight = q;\r\n        }\r\n    }\r\n    else {\r\n        this.root = q;\r\n    }\r\n    q.rbParent = parent;\r\n    p.rbParent = q;\r\n    p.rbRight = q.rbLeft;\r\n    if (p.rbRight) {\r\n        p.rbRight.rbParent = p;\r\n    }\r\n    q.rbLeft = p;\r\n};\r\n\r\nVoronoi.prototype.RBTree.prototype.rbRotateRight = function(node) {\r\n    var p = node,\r\n        q = node.rbLeft, // can't be null\r\n        parent = p.rbParent;\r\n    if (parent) {\r\n        if (parent.rbLeft === p) {\r\n            parent.rbLeft = q;\r\n        }\r\n        else {\r\n            parent.rbRight = q;\r\n        }\r\n    }\r\n    else {\r\n        this.root = q;\r\n    }\r\n    q.rbParent = parent;\r\n    p.rbParent = q;\r\n    p.rbLeft = q.rbRight;\r\n    if (p.rbLeft) {\r\n        p.rbLeft.rbParent = p;\r\n    }\r\n    q.rbRight = p;\r\n};\r\n\r\nVoronoi.prototype.RBTree.prototype.getFirst = function(node) {\r\n    while (node.rbLeft) {\r\n        node = node.rbLeft;\r\n    }\r\n    return node;\r\n};\r\n\r\nVoronoi.prototype.RBTree.prototype.getLast = function(node) {\r\n    while (node.rbRight) {\r\n        node = node.rbRight;\r\n    }\r\n    return node;\r\n};\r\n\r\n// ---------------------------------------------------------------------------\r\n// Cell methods\r\n\r\nVoronoi.prototype.Cell = function(site) {\r\n    this.site = site;\r\n    this.halfedges = [];\r\n};\r\n\r\nVoronoi.prototype.Cell.prototype.prepare = function() {\r\n    var halfedges = this.halfedges,\r\n        iHalfedge = halfedges.length,\r\n        edge;\r\n    // get rid of unused halfedges\r\n    // rhill 2011-05-27: Keep it simple, no point here in trying\r\n    // to be fancy: dangling edges are a typically a minority.\r\n    while (iHalfedge--) {\r\n        edge = halfedges[iHalfedge].edge;\r\n        if (!edge.vb || !edge.va) {\r\n            halfedges.splice(iHalfedge,1);\r\n        }\r\n    }\r\n    // rhill 2011-05-26: I tried to use a binary search at insertion\r\n    // time to keep the array sorted on-the-fly (in Cell.addHalfedge()).\r\n    // There was no real benefits in doing so, performance on\r\n    // Firefox 3.6 was improved marginally, while performance on\r\n    // Opera 11 was penalized marginally.\r\n    halfedges.sort(function(a,b){return b.angle-a.angle;});\r\n    return halfedges.length;\r\n};\r\n\r\n// Compute bounding box\r\n//\r\nVoronoi.prototype.Cell.prototype.getBbox = function() {\r\n    var halfedges = this.halfedges,\r\n        iHalfedge = halfedges.length,\r\n        xmin = Infinity,\r\n        ymin = Infinity,\r\n        xmax = -Infinity,\r\n        ymax = -Infinity,\r\n        v, vx, vy;\r\n    while (iHalfedge--) {\r\n        v = halfedges[iHalfedge].getStartpoint();\r\n        vx = v.x;\r\n        vy = v.y;\r\n        if (vx < xmin) {xmin = vx;}\r\n        if (vy < ymin) {ymin = vy;}\r\n        if (vx > xmax) {xmax = vx;}\r\n        if (vy > ymax) {ymax = vy;}\r\n        // we dont need to take into account end point,\r\n        // since each end point matches a start point\r\n    }\r\n    return {\r\n        x: xmin,\r\n        y: ymin,\r\n        width: xmax-xmin,\r\n        height: ymax-ymin\r\n    };\r\n};\r\n\r\n// Return whether a point is inside, on, or outside the cell:\r\n//   -1: point is outside the perimeter of the cell\r\n//    0: point is on the perimeter of the cell\r\n//    1: point is inside the perimeter of the cell\r\n//\r\nVoronoi.prototype.Cell.prototype.pointIntersection = function(x, y) {\r\n    // Check if point in polygon. Since all polygons of a Voronoi\r\n    // diagram are convex, then:\r\n    // http://paulbourke.net/geometry/polygonmesh/\r\n    // Solution 3 (2D):\r\n    //   \"If the polygon is convex then one can consider the polygon\r\n    //   \"as a 'path' from the first vertex. A point is on the interior\r\n    //   \"of this polygons if it is always on the same side of all the\r\n    //   \"line segments making up the path. ...\r\n    //   \"(y - y0) (x1 - x0) - (x - x0) (y1 - y0)\r\n    //   \"if it is less than 0 then P is to the right of the line segment,\r\n    //   \"if greater than 0 it is to the left, if equal to 0 then it lies\r\n    //   \"on the line segment\"\r\n    var halfedges = this.halfedges,\r\n        iHalfedge = halfedges.length,\r\n        halfedge,\r\n        p0, p1, r;\r\n    while (iHalfedge--) {\r\n        halfedge = halfedges[iHalfedge];\r\n        p0 = halfedge.getStartpoint();\r\n        p1 = halfedge.getEndpoint();\r\n        r = (y-p0.y)*(p1.x-p0.x)-(x-p0.x)*(p1.y-p0.y);\r\n        if (!r) {\r\n            return 0;\r\n        }\r\n        if (r > 0) {\r\n            return -1;\r\n        }\r\n    }\r\n    return 1;\r\n};\r\n\r\n\r\n// ---------------------------------------------------------------------------\r\n// Edge methods\r\n//\r\n\r\nVoronoi.prototype.Vertex = function(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n};\r\n\r\nVoronoi.prototype.Edge = function(lSite, rSite) {\r\n    this.lSite = lSite;\r\n    this.rSite = rSite;\r\n    this.va = this.vb = null;\r\n};\r\n\r\nVoronoi.prototype.Halfedge = function(edge, lSite, rSite) {\r\n    this.site = lSite;\r\n    this.edge = edge;\r\n    // 'angle' is a value to be used for properly sorting the\r\n    // halfsegments counterclockwise. By convention, we will\r\n    // use the angle of the line defined by the 'site to the left'\r\n    // to the 'site to the right'.\r\n    // However, border edges have no 'site to the right': thus we\r\n    // use the angle of line perpendicular to the halfsegment (the\r\n    // edge should have both end points defined in such case.)\r\n    if (rSite) {\r\n        this.angle = Math.atan2(rSite.y-lSite.y, rSite.x-lSite.x);\r\n    }\r\n    else {\r\n        var va = edge.va,\r\n            vb = edge.vb;\r\n        // rhill 2011-05-31: used to call getStartpoint()/getEndpoint(),\r\n        // but for performance purpose, these are expanded in place here.\r\n        this.angle = edge.lSite === lSite ? Math.atan2(vb.x-va.x, va.y-vb.y)\r\n            : Math.atan2(va.x-vb.x, vb.y-va.y);\r\n    }\r\n};\r\n\r\nVoronoi.prototype.Halfedge.prototype.getStartpoint = function() {\r\n    return this.edge.lSite === this.site ? this.edge.va : this.edge.vb;\r\n};\r\n\r\nVoronoi.prototype.Halfedge.prototype.getEndpoint = function() {\r\n    return this.edge.lSite === this.site ? this.edge.vb : this.edge.va;\r\n};\r\n\r\n// this create and add an edge to internal collection, and also create\r\n// two halfedges which are added to each site's counterclockwise array\r\n// of halfedges.\r\nVoronoi.prototype.createEdge = function(lSite, rSite, va, vb) {\r\n    var edge = new this.Edge(lSite, rSite);\r\n    this.edges.push(edge);\r\n    if (va) {\r\n        this.setEdgeStartpoint(edge, lSite, rSite, va);\r\n    }\r\n    if (vb) {\r\n        this.setEdgeEndpoint(edge, lSite, rSite, vb);\r\n    }\r\n    this.cells[lSite.voronoiId].halfedges.push(new this.Halfedge(edge, lSite, rSite));\r\n    this.cells[rSite.voronoiId].halfedges.push(new this.Halfedge(edge, rSite, lSite));\r\n    return edge;\r\n};\r\n\r\nVoronoi.prototype.createBorderEdge = function(lSite, va, vb) {\r\n    var edge = new this.Edge(lSite, null);\r\n    edge.va = va;\r\n    edge.vb = vb;\r\n    this.edges.push(edge);\r\n    return edge;\r\n};\r\n\r\nVoronoi.prototype.setEdgeStartpoint = function(edge, lSite, rSite, vertex) {\r\n    if (!edge.va && !edge.vb) {\r\n        edge.va = vertex;\r\n        edge.lSite = lSite;\r\n        edge.rSite = rSite;\r\n    }\r\n    else if (edge.lSite === rSite) {\r\n        edge.vb = vertex;\r\n    }\r\n    else {\r\n        edge.va = vertex;\r\n    }\r\n};\r\n\r\nVoronoi.prototype.setEdgeEndpoint = function(edge, lSite, rSite, vertex) {\r\n    this.setEdgeStartpoint(edge, rSite, lSite, vertex);\r\n};\r\n\r\n// ---------------------------------------------------------------------------\r\n// Beachline methods\r\n\r\n// rhill 2011-06-07: For some reasons, performance suffers significantly\r\n// when instanciating a literal object instead of an empty ctor\r\nVoronoi.prototype.Beachsection = function() {\r\n};\r\n\r\n// rhill 2011-06-02: A lot of Beachsection instanciations\r\n// occur during the computation of the Voronoi diagram,\r\n// somewhere between the number of sites and twice the\r\n// number of sites, while the number of Beachsections on the\r\n// beachline at any given time is comparatively low. For this\r\n// reason, we reuse already created Beachsections, in order\r\n// to avoid new memory allocation. This resulted in a measurable\r\n// performance gain.\r\nVoronoi.prototype.createBeachsection = function(site) {\r\n    var beachsection = this.beachsectionJunkyard.pop();\r\n    if (!beachsection) {\r\n        beachsection = new this.Beachsection();\r\n    }\r\n    beachsection.site = site;\r\n    return beachsection;\r\n};\r\n\r\n// calculate the left break point of a particular beach section,\r\n// given a particular sweep line\r\nVoronoi.prototype.leftBreakPoint = function(arc, directrix) {\r\n    // http://en.wikipedia.org/wiki/Parabola\r\n    // http://en.wikipedia.org/wiki/Quadratic_equation\r\n    // h1 = x1,\r\n    // k1 = (y1+directrix)/2,\r\n    // h2 = x2,\r\n    // k2 = (y2+directrix)/2,\r\n    // p1 = k1-directrix,\r\n    // a1 = 1/(4*p1),\r\n    // b1 = -h1/(2*p1),\r\n    // c1 = h1*h1/(4*p1)+k1,\r\n    // p2 = k2-directrix,\r\n    // a2 = 1/(4*p2),\r\n    // b2 = -h2/(2*p2),\r\n    // c2 = h2*h2/(4*p2)+k2,\r\n    // x = (-(b2-b1) + Math.sqrt((b2-b1)*(b2-b1) - 4*(a2-a1)*(c2-c1))) / (2*(a2-a1))\r\n    // When x1 become the x-origin:\r\n    // h1 = 0,\r\n    // k1 = (y1+directrix)/2,\r\n    // h2 = x2-x1,\r\n    // k2 = (y2+directrix)/2,\r\n    // p1 = k1-directrix,\r\n    // a1 = 1/(4*p1),\r\n    // b1 = 0,\r\n    // c1 = k1,\r\n    // p2 = k2-directrix,\r\n    // a2 = 1/(4*p2),\r\n    // b2 = -h2/(2*p2),\r\n    // c2 = h2*h2/(4*p2)+k2,\r\n    // x = (-b2 + Math.sqrt(b2*b2 - 4*(a2-a1)*(c2-k1))) / (2*(a2-a1)) + x1\r\n\r\n    // change code below at your own risk: care has been taken to\r\n    // reduce errors due to computers' finite arithmetic precision.\r\n    // Maybe can still be improved, will see if any more of this\r\n    // kind of errors pop up again.\r\n    var site = arc.site,\r\n        rfocx = site.x,\r\n        rfocy = site.y,\r\n        pby2 = rfocy-directrix;\r\n    // parabola in degenerate case where focus is on directrix\r\n    if (!pby2) {\r\n        return rfocx;\r\n    }\r\n    var lArc = arc.rbPrevious;\r\n    if (!lArc) {\r\n        return -Infinity;\r\n    }\r\n    site = lArc.site;\r\n    var lfocx = site.x,\r\n        lfocy = site.y,\r\n        plby2 = lfocy-directrix;\r\n    // parabola in degenerate case where focus is on directrix\r\n    if (!plby2) {\r\n        return lfocx;\r\n    }\r\n    var\thl = lfocx-rfocx,\r\n        aby2 = 1/pby2-1/plby2,\r\n        b = hl/plby2;\r\n    if (aby2) {\r\n        return (-b+this.sqrt(b*b-2*aby2*(hl*hl/(-2*plby2)-lfocy+plby2/2+rfocy-pby2/2)))/aby2+rfocx;\r\n    }\r\n    // both parabolas have same distance to directrix, thus break point is midway\r\n    return (rfocx+lfocx)/2;\r\n};\r\n\r\n// calculate the right break point of a particular beach section,\r\n// given a particular directrix\r\nVoronoi.prototype.rightBreakPoint = function(arc, directrix) {\r\n    var rArc = arc.rbNext;\r\n    if (rArc) {\r\n        return this.leftBreakPoint(rArc, directrix);\r\n    }\r\n    var site = arc.site;\r\n    return site.y === directrix ? site.x : Infinity;\r\n};\r\n\r\nVoronoi.prototype.detachBeachsection = function(beachsection) {\r\n    this.detachCircleEvent(beachsection); // detach potentially attached circle event\r\n    this.beachline.rbRemoveNode(beachsection); // remove from RB-tree\r\n    this.beachsectionJunkyard.push(beachsection); // mark for reuse\r\n};\r\n\r\nVoronoi.prototype.removeBeachsection = function(beachsection) {\r\n    var circle = beachsection.circleEvent,\r\n        x = circle.x,\r\n        y = circle.ycenter,\r\n        vertex = new this.Vertex(x, y),\r\n        previous = beachsection.rbPrevious,\r\n        next = beachsection.rbNext,\r\n        disappearingTransitions = [beachsection],\r\n        abs_fn = Math.abs;\r\n\r\n    // remove collapsed beachsection from beachline\r\n    this.detachBeachsection(beachsection);\r\n\r\n    // there could be more than one empty arc at the deletion point, this\r\n    // happens when more than two edges are linked by the same vertex,\r\n    // so we will collect all those edges by looking up both sides of\r\n    // the deletion point.\r\n    // by the way, there is *always* a predecessor/successor to any collapsed\r\n    // beach section, it's just impossible to have a collapsing first/last\r\n    // beach sections on the beachline, since they obviously are unconstrained\r\n    // on their left/right side.\r\n\r\n    // look left\r\n    var lArc = previous;\r\n    while (lArc.circleEvent && abs_fn(x-lArc.circleEvent.x)<1e-9 && abs_fn(y-lArc.circleEvent.ycenter)<1e-9) {\r\n        previous = lArc.rbPrevious;\r\n        disappearingTransitions.unshift(lArc);\r\n        this.detachBeachsection(lArc); // mark for reuse\r\n        lArc = previous;\r\n    }\r\n    // even though it is not disappearing, I will also add the beach section\r\n    // immediately to the left of the left-most collapsed beach section, for\r\n    // convenience, since we need to refer to it later as this beach section\r\n    // is the 'left' site of an edge for which a start point is set.\r\n    disappearingTransitions.unshift(lArc);\r\n    this.detachCircleEvent(lArc);\r\n\r\n    // look right\r\n    var rArc = next;\r\n    while (rArc.circleEvent && abs_fn(x-rArc.circleEvent.x)<1e-9 && abs_fn(y-rArc.circleEvent.ycenter)<1e-9) {\r\n        next = rArc.rbNext;\r\n        disappearingTransitions.push(rArc);\r\n        this.detachBeachsection(rArc); // mark for reuse\r\n        rArc = next;\r\n    }\r\n    // we also have to add the beach section immediately to the right of the\r\n    // right-most collapsed beach section, since there is also a disappearing\r\n    // transition representing an edge's start point on its left.\r\n    disappearingTransitions.push(rArc);\r\n    this.detachCircleEvent(rArc);\r\n\r\n    // walk through all the disappearing transitions between beach sections and\r\n    // set the start point of their (implied) edge.\r\n    var nArcs = disappearingTransitions.length,\r\n        iArc;\r\n    for (iArc=1; iArc<nArcs; iArc++) {\r\n        rArc = disappearingTransitions[iArc];\r\n        lArc = disappearingTransitions[iArc-1];\r\n        this.setEdgeStartpoint(rArc.edge, lArc.site, rArc.site, vertex);\r\n    }\r\n\r\n    // create a new edge as we have now a new transition between\r\n    // two beach sections which were previously not adjacent.\r\n    // since this edge appears as a new vertex is defined, the vertex\r\n    // actually define an end point of the edge (relative to the site\r\n    // on the left)\r\n    lArc = disappearingTransitions[0];\r\n    rArc = disappearingTransitions[nArcs-1];\r\n    rArc.edge = this.createEdge(lArc.site, rArc.site, undefined, vertex);\r\n\r\n    // create circle events if any for beach sections left in the beachline\r\n    // adjacent to collapsed sections\r\n    this.attachCircleEvent(lArc);\r\n    this.attachCircleEvent(rArc);\r\n};\r\n\r\nVoronoi.prototype.addBeachsection = function(site) {\r\n    var x = site.x,\r\n        directrix = site.y;\r\n\r\n    // find the left and right beach sections which will surround the newly\r\n    // created beach section.\r\n    // rhill 2011-06-01: This loop is one of the most often executed,\r\n    // hence we expand in-place the comparison-against-epsilon calls.\r\n    var lArc, rArc,\r\n        dxl, dxr,\r\n        node = this.beachline.root;\r\n\r\n    while (node) {\r\n        dxl = this.leftBreakPoint(node,directrix)-x;\r\n        // x lessThanWithEpsilon xl => falls somewhere before the left edge of the beachsection\r\n        if (dxl > 1e-9) {\r\n            // this case should never happen\r\n            // if (!node.rbLeft) {\r\n            //\trArc = node.rbLeft;\r\n            //\tbreak;\r\n            //\t}\r\n            node = node.rbLeft;\r\n        }\r\n        else {\r\n            dxr = x-this.rightBreakPoint(node,directrix);\r\n            // x greaterThanWithEpsilon xr => falls somewhere after the right edge of the beachsection\r\n            if (dxr > 1e-9) {\r\n                if (!node.rbRight) {\r\n                    lArc = node;\r\n                    break;\r\n                }\r\n                node = node.rbRight;\r\n            }\r\n            else {\r\n                // x equalWithEpsilon xl => falls exactly on the left edge of the beachsection\r\n                if (dxl > -1e-9) {\r\n                    lArc = node.rbPrevious;\r\n                    rArc = node;\r\n                }\r\n                // x equalWithEpsilon xr => falls exactly on the right edge of the beachsection\r\n                else if (dxr > -1e-9) {\r\n                    lArc = node;\r\n                    rArc = node.rbNext;\r\n                }\r\n                // falls exactly somewhere in the middle of the beachsection\r\n                else {\r\n                    lArc = rArc = node;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    // at this point, keep in mind that lArc and/or rArc could be\r\n    // undefined or null.\r\n\r\n    // create a new beach section object for the site and add it to RB-tree\r\n    var newArc = this.createBeachsection(site);\r\n    this.beachline.rbInsertSuccessor(lArc, newArc);\r\n\r\n    // cases:\r\n    //\r\n\r\n    // [null,null]\r\n    // least likely case: new beach section is the first beach section on the\r\n    // beachline.\r\n    // This case means:\r\n    //   no new transition appears\r\n    //   no collapsing beach section\r\n    //   new beachsection become root of the RB-tree\r\n    if (!lArc && !rArc) {\r\n        return;\r\n    }\r\n\r\n    // [lArc,rArc] where lArc == rArc\r\n    // most likely case: new beach section split an existing beach\r\n    // section.\r\n    // This case means:\r\n    //   one new transition appears\r\n    //   the left and right beach section might be collapsing as a result\r\n    //   two new nodes added to the RB-tree\r\n    if (lArc === rArc) {\r\n        // invalidate circle event of split beach section\r\n        this.detachCircleEvent(lArc);\r\n\r\n        // split the beach section into two separate beach sections\r\n        rArc = this.createBeachsection(lArc.site);\r\n        this.beachline.rbInsertSuccessor(newArc, rArc);\r\n\r\n        // since we have a new transition between two beach sections,\r\n        // a new edge is born\r\n        newArc.edge = rArc.edge = this.createEdge(lArc.site, newArc.site);\r\n\r\n        // check whether the left and right beach sections are collapsing\r\n        // and if so create circle events, to be notified when the point of\r\n        // collapse is reached.\r\n        this.attachCircleEvent(lArc);\r\n        this.attachCircleEvent(rArc);\r\n        return;\r\n    }\r\n\r\n    // [lArc,null]\r\n    // even less likely case: new beach section is the *last* beach section\r\n    // on the beachline -- this can happen *only* if *all* the previous beach\r\n    // sections currently on the beachline share the same y value as\r\n    // the new beach section.\r\n    // This case means:\r\n    //   one new transition appears\r\n    //   no collapsing beach section as a result\r\n    //   new beach section become right-most node of the RB-tree\r\n    if (lArc && !rArc) {\r\n        newArc.edge = this.createEdge(lArc.site,newArc.site);\r\n        return;\r\n    }\r\n\r\n    // [null,rArc]\r\n    // impossible case: because sites are strictly processed from top to bottom,\r\n    // and left to right, which guarantees that there will always be a beach section\r\n    // on the left -- except of course when there are no beach section at all on\r\n    // the beach line, which case was handled above.\r\n    // rhill 2011-06-02: No point testing in non-debug version\r\n    //if (!lArc && rArc) {\r\n    //\tthrow \"Voronoi.addBeachsection(): What is this I don't even\";\r\n    //\t}\r\n\r\n    // [lArc,rArc] where lArc != rArc\r\n    // somewhat less likely case: new beach section falls *exactly* in between two\r\n    // existing beach sections\r\n    // This case means:\r\n    //   one transition disappears\r\n    //   two new transitions appear\r\n    //   the left and right beach section might be collapsing as a result\r\n    //   only one new node added to the RB-tree\r\n    if (lArc !== rArc) {\r\n        // invalidate circle events of left and right sites\r\n        this.detachCircleEvent(lArc);\r\n        this.detachCircleEvent(rArc);\r\n\r\n        // an existing transition disappears, meaning a vertex is defined at\r\n        // the disappearance point.\r\n        // since the disappearance is caused by the new beachsection, the\r\n        // vertex is at the center of the circumscribed circle of the left,\r\n        // new and right beachsections.\r\n        // http://mathforum.org/library/drmath/view/55002.html\r\n        // Except that I bring the origin at A to simplify\r\n        // calculation\r\n        var lSite = lArc.site,\r\n            ax = lSite.x,\r\n            ay = lSite.y,\r\n            bx=site.x-ax,\r\n            by=site.y-ay,\r\n            rSite = rArc.site,\r\n            cx=rSite.x-ax,\r\n            cy=rSite.y-ay,\r\n            d=2*(bx*cy-by*cx),\r\n            hb=bx*bx+by*by,\r\n            hc=cx*cx+cy*cy,\r\n            vertex = new this.Vertex((cy*hb-by*hc)/d+ax, (bx*hc-cx*hb)/d+ay);\r\n\r\n        // one transition disappear\r\n        this.setEdgeStartpoint(rArc.edge, lSite, rSite, vertex);\r\n\r\n        // two new transitions appear at the new vertex location\r\n        newArc.edge = this.createEdge(lSite, site, undefined, vertex);\r\n        rArc.edge = this.createEdge(site, rSite, undefined, vertex);\r\n\r\n        // check whether the left and right beach sections are collapsing\r\n        // and if so create circle events, to handle the point of collapse.\r\n        this.attachCircleEvent(lArc);\r\n        this.attachCircleEvent(rArc);\r\n        return;\r\n    }\r\n};\r\n\r\n// ---------------------------------------------------------------------------\r\n// Circle event methods\r\n\r\n// rhill 2011-06-07: For some reasons, performance suffers significantly\r\n// when instanciating a literal object instead of an empty ctor\r\nVoronoi.prototype.CircleEvent = function() {\r\n};\r\n\r\nVoronoi.prototype.attachCircleEvent = function(arc) {\r\n    var lArc = arc.rbPrevious,\r\n        rArc = arc.rbNext;\r\n    if (!lArc || !rArc) {return;} // does that ever happen?\r\n    var lSite = lArc.site,\r\n        cSite = arc.site,\r\n        rSite = rArc.site;\r\n\r\n    // If site of left beachsection is same as site of\r\n    // right beachsection, there can't be convergence\r\n    if (lSite===rSite) {return;}\r\n\r\n    // Find the circumscribed circle for the three sites associated\r\n    // with the beachsection triplet.\r\n    // rhill 2011-05-26: It is more efficient to calculate in-place\r\n    // rather than getting the resulting circumscribed circle from an\r\n    // object returned by calling Voronoi.circumcircle()\r\n    // http://mathforum.org/library/drmath/view/55002.html\r\n    // Except that I bring the origin at cSite to simplify calculations.\r\n    // The bottom-most part of the circumcircle is our Fortune 'circle\r\n    // event', and its center is a vertex potentially part of the final\r\n    // Voronoi diagram.\r\n    var bx = cSite.x,\r\n        by = cSite.y,\r\n        ax = lSite.x-bx,\r\n        ay = lSite.y-by,\r\n        cx = rSite.x-bx,\r\n        cy = rSite.y-by;\r\n\r\n    // If points l->c->r are clockwise, then center beach section does not\r\n    // collapse, hence it can't end up as a vertex (we reuse 'd' here, which\r\n    // sign is reverse of the orientation, hence we reverse the test.\r\n    // http://en.wikipedia.org/wiki/Curve_orientation#Orientation_of_a_simple_polygon\r\n    // rhill 2011-05-21: Nasty finite precision error which caused circumcircle() to\r\n    // return infinites: 1e-12 seems to fix the problem.\r\n    var d = 2*(ax*cy-ay*cx);\r\n    if (d >= -2e-12){return;}\r\n\r\n    var\tha = ax*ax+ay*ay,\r\n        hc = cx*cx+cy*cy,\r\n        x = (cy*ha-ay*hc)/d,\r\n        y = (ax*hc-cx*ha)/d,\r\n        ycenter = y+by;\r\n\r\n    // Important: ybottom should always be under or at sweep, so no need\r\n    // to waste CPU cycles by checking\r\n\r\n    // recycle circle event object if possible\r\n    var circleEvent = this.circleEventJunkyard.pop();\r\n    if (!circleEvent) {\r\n        circleEvent = new this.CircleEvent();\r\n    }\r\n    circleEvent.arc = arc;\r\n    circleEvent.site = cSite;\r\n    circleEvent.x = x+bx;\r\n    circleEvent.y = ycenter+this.sqrt(x*x+y*y); // y bottom\r\n    circleEvent.ycenter = ycenter;\r\n    arc.circleEvent = circleEvent;\r\n\r\n    // find insertion point in RB-tree: circle events are ordered from\r\n    // smallest to largest\r\n    var predecessor = null,\r\n        node = this.circleEvents.root;\r\n    while (node) {\r\n        if (circleEvent.y < node.y || (circleEvent.y === node.y && circleEvent.x <= node.x)) {\r\n            if (node.rbLeft) {\r\n                node = node.rbLeft;\r\n            }\r\n            else {\r\n                predecessor = node.rbPrevious;\r\n                break;\r\n            }\r\n        }\r\n        else {\r\n            if (node.rbRight) {\r\n                node = node.rbRight;\r\n            }\r\n            else {\r\n                predecessor = node;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    this.circleEvents.rbInsertSuccessor(predecessor, circleEvent);\r\n    if (!predecessor) {\r\n        this.firstCircleEvent = circleEvent;\r\n    }\r\n};\r\n\r\nVoronoi.prototype.detachCircleEvent = function(arc) {\r\n    var circle = arc.circleEvent;\r\n    if (circle) {\r\n        if (!circle.rbPrevious) {\r\n            this.firstCircleEvent = circle.rbNext;\r\n        }\r\n        this.circleEvents.rbRemoveNode(circle); // remove from RB-tree\r\n        this.circleEventJunkyard.push(circle);\r\n        arc.circleEvent = null;\r\n    }\r\n};\r\n\r\n// ---------------------------------------------------------------------------\r\n// Diagram completion methods\r\n\r\n// connect dangling edges (not if a cursory test tells us\r\n// it is not going to be visible.\r\n// return value:\r\n//   false: the dangling endpoint couldn't be connected\r\n//   true: the dangling endpoint could be connected\r\nVoronoi.prototype.connectEdge = function(edge, bbox) {\r\n    // skip if end point already connected\r\n    var vb = edge.vb;\r\n    if (!!vb) {return true;}\r\n\r\n    // make local copy for performance purpose\r\n    var va = edge.va,\r\n        xl = bbox.xl,\r\n        xr = bbox.xr,\r\n        yt = bbox.yt,\r\n        yb = bbox.yb,\r\n        lSite = edge.lSite,\r\n        rSite = edge.rSite,\r\n        lx = lSite.x,\r\n        ly = lSite.y,\r\n        rx = rSite.x,\r\n        ry = rSite.y,\r\n        fx = (lx+rx)/2,\r\n        fy = (ly+ry)/2,\r\n        fm, fb;\r\n\r\n    // get the line equation of the bisector if line is not vertical\r\n    if (ry !== ly) {\r\n        fm = (lx-rx)/(ry-ly);\r\n        fb = fy-fm*fx;\r\n    }\r\n\r\n    // remember, direction of line (relative to left site):\r\n    // upward: left.x < right.x\r\n    // downward: left.x > right.x\r\n    // horizontal: left.x == right.x\r\n    // upward: left.x < right.x\r\n    // rightward: left.y < right.y\r\n    // leftward: left.y > right.y\r\n    // vertical: left.y == right.y\r\n\r\n    // depending on the direction, find the best side of the\r\n    // bounding box to use to determine a reasonable start point\r\n\r\n    // special case: vertical line\r\n    if (fm === undefined) {\r\n        // doesn't intersect with viewport\r\n        if (fx < xl || fx >= xr) {return false;}\r\n        // downward\r\n        if (lx > rx) {\r\n            if (!va) {\r\n                va = new this.Vertex(fx, yt);\r\n            }\r\n            else if (va.y >= yb) {\r\n                return false;\r\n            }\r\n            vb = new this.Vertex(fx, yb);\r\n        }\r\n        // upward\r\n        else {\r\n            if (!va) {\r\n                va = new this.Vertex(fx, yb);\r\n            }\r\n            else if (va.y < yt) {\r\n                return false;\r\n            }\r\n            vb = new this.Vertex(fx, yt);\r\n        }\r\n    }\r\n    // closer to vertical than horizontal, connect start point to the\r\n    // top or bottom side of the bounding box\r\n    else if (fm < -1 || fm > 1) {\r\n        // downward\r\n        if (lx > rx) {\r\n            if (!va) {\r\n                va = new this.Vertex((yt-fb)/fm, yt);\r\n            }\r\n            else if (va.y >= yb) {\r\n                return false;\r\n            }\r\n            vb = new this.Vertex((yb-fb)/fm, yb);\r\n        }\r\n        // upward\r\n        else {\r\n            if (!va) {\r\n                va = new this.Vertex((yb-fb)/fm, yb);\r\n            }\r\n            else if (va.y < yt) {\r\n                return false;\r\n            }\r\n            vb = new this.Vertex((yt-fb)/fm, yt);\r\n        }\r\n    }\r\n    // closer to horizontal than vertical, connect start point to the\r\n    // left or right side of the bounding box\r\n    else {\r\n        // rightward\r\n        if (ly < ry) {\r\n            if (!va) {\r\n                va = new this.Vertex(xl, fm*xl+fb);\r\n            }\r\n            else if (va.x >= xr) {\r\n                return false;\r\n            }\r\n            vb = new this.Vertex(xr, fm*xr+fb);\r\n        }\r\n        // leftward\r\n        else {\r\n            if (!va) {\r\n                va = new this.Vertex(xr, fm*xr+fb);\r\n            }\r\n            else if (va.x < xl) {\r\n                return false;\r\n            }\r\n            vb = new this.Vertex(xl, fm*xl+fb);\r\n        }\r\n    }\r\n    edge.va = va;\r\n    edge.vb = vb;\r\n    return true;\r\n};\r\n\r\n// line-clipping code taken from:\r\n//   Liang-Barsky function by Daniel White\r\n//   http://www.skytopia.com/project/articles/compsci/clipping.html\r\n// Thanks!\r\n// A bit modified to minimize code paths\r\nVoronoi.prototype.clipEdge = function(edge, bbox) {\r\n    var ax = edge.va.x,\r\n        ay = edge.va.y,\r\n        bx = edge.vb.x,\r\n        by = edge.vb.y,\r\n        t0 = 0,\r\n        t1 = 1,\r\n        dx = bx-ax,\r\n        dy = by-ay;\r\n    // left\r\n    var q = ax-bbox.xl;\r\n    if (dx===0 && q<0) {return false;}\r\n    var r = -q/dx;\r\n    if (dx<0) {\r\n        if (r<t0) {return false;}\r\n        else if (r<t1) {t1=r;}\r\n    }\r\n    else if (dx>0) {\r\n        if (r>t1) {return false;}\r\n        else if (r>t0) {t0=r;}\r\n    }\r\n    // right\r\n    q = bbox.xr-ax;\r\n    if (dx===0 && q<0) {return false;}\r\n    r = q/dx;\r\n    if (dx<0) {\r\n        if (r>t1) {return false;}\r\n        else if (r>t0) {t0=r;}\r\n    }\r\n    else if (dx>0) {\r\n        if (r<t0) {return false;}\r\n        else if (r<t1) {t1=r;}\r\n    }\r\n    // top\r\n    q = ay-bbox.yt;\r\n    if (dy===0 && q<0) {return false;}\r\n    r = -q/dy;\r\n    if (dy<0) {\r\n        if (r<t0) {return false;}\r\n        else if (r<t1) {t1=r;}\r\n    }\r\n    else if (dy>0) {\r\n        if (r>t1) {return false;}\r\n        else if (r>t0) {t0=r;}\r\n    }\r\n    // bottom\r\n    q = bbox.yb-ay;\r\n    if (dy===0 && q<0) {return false;}\r\n    r = q/dy;\r\n    if (dy<0) {\r\n        if (r>t1) {return false;}\r\n        else if (r>t0) {t0=r;}\r\n    }\r\n    else if (dy>0) {\r\n        if (r<t0) {return false;}\r\n        else if (r<t1) {t1=r;}\r\n    }\r\n\r\n    // if we reach this point, Voronoi edge is within bbox\r\n\r\n    // if t0 > 0, va needs to change\r\n    // rhill 2011-06-03: we need to create a new vertex rather\r\n    // than modifying the existing one, since the existing\r\n    // one is likely shared with at least another edge\r\n    if (t0 > 0) {\r\n        edge.va = new this.Vertex(ax+t0*dx, ay+t0*dy);\r\n    }\r\n\r\n    // if t1 < 1, vb needs to change\r\n    // rhill 2011-06-03: we need to create a new vertex rather\r\n    // than modifying the existing one, since the existing\r\n    // one is likely shared with at least another edge\r\n    if (t1 < 1) {\r\n        edge.vb = new this.Vertex(ax+t1*dx, ay+t1*dy);\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\n// Connect/cut edges at bounding box\r\nVoronoi.prototype.clipEdges = function(bbox) {\r\n    // connect all dangling edges to bounding box\r\n    // or get rid of them if it can't be done\r\n    var edges = this.edges,\r\n        iEdge = edges.length,\r\n        edge,\r\n        abs_fn = Math.abs;\r\n\r\n    // iterate backward so we can splice safely\r\n    while (iEdge--) {\r\n        edge = edges[iEdge];\r\n        // edge is removed if:\r\n        //   it is wholly outside the bounding box\r\n        //   it is actually a point rather than a line\r\n        if (!this.connectEdge(edge, bbox) || !this.clipEdge(edge, bbox) || (abs_fn(edge.va.x-edge.vb.x)<1e-9 && abs_fn(edge.va.y-edge.vb.y)<1e-9)) {\r\n            edge.va = edge.vb = null;\r\n            edges.splice(iEdge,1);\r\n        }\r\n    }\r\n};\r\n\r\n// Close the cells.\r\n// The cells are bound by the supplied bounding box.\r\n// Each cell refers to its associated site, and a list\r\n// of halfedges ordered counterclockwise.\r\nVoronoi.prototype.closeCells = function(bbox) {\r\n    // prune, order halfedges, then add missing ones\r\n    // required to close cells\r\n    var xl = bbox.xl,\r\n        xr = bbox.xr,\r\n        yt = bbox.yt,\r\n        yb = bbox.yb,\r\n        cells = this.cells,\r\n        iCell = cells.length,\r\n        cell,\r\n        iLeft, iRight,\r\n        halfedges, nHalfedges,\r\n        edge,\r\n        startpoint, endpoint,\r\n        va, vb,\r\n        abs_fn = Math.abs;\r\n\r\n    while (iCell--) {\r\n        cell = cells[iCell];\r\n        // trim non fully-defined halfedges and sort them counterclockwise\r\n        if (!cell.prepare()) {\r\n            continue;\r\n        }\r\n        // close open cells\r\n        // step 1: find first 'unclosed' point, if any.\r\n        // an 'unclosed' point will be the end point of a halfedge which\r\n        // does not match the start point of the following halfedge\r\n        halfedges = cell.halfedges;\r\n        nHalfedges = halfedges.length;\r\n        // special case: only one site, in which case, the viewport is the cell\r\n        // ...\r\n        // all other cases\r\n        iLeft = 0;\r\n        while (iLeft < nHalfedges) {\r\n            iRight = (iLeft+1) % nHalfedges;\r\n            endpoint = halfedges[iLeft].getEndpoint();\r\n            startpoint = halfedges[iRight].getStartpoint();\r\n            // if end point is not equal to start point, we need to add the missing\r\n            // halfedge(s) to close the cell\r\n            if (abs_fn(endpoint.x-startpoint.x)>=1e-9 || abs_fn(endpoint.y-startpoint.y)>=1e-9) {\r\n                // if we reach this point, cell needs to be closed by walking\r\n                // counterclockwise along the bounding box until it connects\r\n                // to next halfedge in the list\r\n                va = endpoint;\r\n                // walk downward along left side\r\n                if (this.equalWithEpsilon(endpoint.x,xl) && this.lessThanWithEpsilon(endpoint.y,yb)) {\r\n                    vb = new this.Vertex(xl, this.equalWithEpsilon(startpoint.x,xl) ? startpoint.y : yb);\r\n                }\r\n                // walk rightward along bottom side\r\n                else if (this.equalWithEpsilon(endpoint.y,yb) && this.lessThanWithEpsilon(endpoint.x,xr)) {\r\n                    vb = new this.Vertex(this.equalWithEpsilon(startpoint.y,yb) ? startpoint.x : xr, yb);\r\n                }\r\n                // walk upward along right side\r\n                else if (this.equalWithEpsilon(endpoint.x,xr) && this.greaterThanWithEpsilon(endpoint.y,yt)) {\r\n                    vb = new this.Vertex(xr, this.equalWithEpsilon(startpoint.x,xr) ? startpoint.y : yt);\r\n                }\r\n                // walk leftward along top side\r\n                else if (this.equalWithEpsilon(endpoint.y,yt) && this.greaterThanWithEpsilon(endpoint.x,xl)) {\r\n                    vb = new this.Vertex(this.equalWithEpsilon(startpoint.y,yt) ? startpoint.x : xl, yt);\r\n                }\r\n                edge = this.createBorderEdge(cell.site, va, vb);\r\n                halfedges.splice(iLeft+1, 0, new this.Halfedge(edge, cell.site, null));\r\n                nHalfedges = halfedges.length;\r\n            }\r\n            iLeft++;\r\n        }\r\n    }\r\n};\r\n\r\n// ---------------------------------------------------------------------------\r\n// Top-level Fortune loop\r\n\r\n// rhill 2011-05-19:\r\n//   Voronoi sites are kept client-side now, to allow\r\n//   user to freely modify content. At compute time,\r\n//   *references* to sites are copied locally.\r\nVoronoi.prototype.compute = function(sites, bbox) {\r\n    // to measure execution time\r\n    var startTime = new Date();\r\n\r\n    // init internal state\r\n    this.reset();\r\n\r\n    // Initialize site event queue\r\n    var siteEvents = sites.slice(0);\r\n    siteEvents.sort(function(a,b){\r\n        var r = b.y - a.y;\r\n        if (r) {return r;}\r\n        return b.x - a.x;\r\n    });\r\n\r\n    // process queue\r\n    var site = siteEvents.pop(),\r\n        siteid = 0,\r\n        xsitex = Number.MIN_VALUE, // to avoid duplicate sites\r\n        xsitey = Number.MIN_VALUE,\r\n        cells = this.cells,\r\n        circle;\r\n\r\n    // main loop\r\n    for (;;) {\r\n        // we need to figure whether we handle a site or circle event\r\n        // for this we find out if there is a site event and it is\r\n        // 'earlier' than the circle event\r\n        circle = this.firstCircleEvent;\r\n\r\n        // add beach section\r\n        if (site && (!circle || site.y < circle.y || (site.y === circle.y && site.x < circle.x))) {\r\n            // only if site is not a duplicate\r\n            if (site.x !== xsitex || site.y !== xsitey) {\r\n                // first create cell for new site\r\n                cells[siteid] = new this.Cell(site);\r\n                site.voronoiId = siteid++;\r\n                // then create a beachsection for that site\r\n                this.addBeachsection(site);\r\n                // remember last site coords to detect duplicate\r\n                xsitey = site.y;\r\n                xsitex = site.x;\r\n            }\r\n            site = siteEvents.pop();\r\n        }\r\n\r\n        // remove beach section\r\n        else if (circle) {\r\n            this.removeBeachsection(circle.arc);\r\n        }\r\n\r\n        // all done, quit\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    // wrapping-up:\r\n    //   connect dangling edges to bounding box\r\n    //   cut edges as per bounding box\r\n    //   discard edges completely outside bounding box\r\n    //   discard edges which are point-like\r\n    this.clipEdges(bbox);\r\n\r\n    //   add missing edges in order to close opened cells\r\n    this.closeCells(bbox);\r\n\r\n    // to measure execution time\r\n    var stopTime = new Date();\r\n\r\n    // prepare return values\r\n    var result = {\r\n        cells: this.cells,\r\n        edges: this.edges,\r\n        execTime: stopTime.getTime()-startTime.getTime()\r\n    };\r\n\r\n    // clean up\r\n    this.reset();\r\n\r\n    return result;\r\n};\r\n";
},719:function(t,n,r){r(382),r(383),t.exports=r(384)}},[719]);